---
title: 'Asset management : risque de march√©'
author : 
    - Cheryl Kouadio
    - "Sous la supervision de : Fai√ßal HIHI"    
jupyter: python3
date: "2025-01-27"
---


La gestion d'actifs (ou *asset management*) est l‚Äôart de g√©rer un portefeuille d‚Äôactifs financiers. Il s‚Äôagit de g√©rer l‚Äôargent de clients ‚Äî particuliers ou institutionnels ‚Äî avec pour objectif principal de maximiser le rendement tout en minimisant le risque.

**Les √©tapes usuelles de gestion du risque**

1. Identification des risques

On distingue g√©n√©ralement quatre grandes cat√©gories de risques :

- Risque de march√© : risque de perte en capital d√ª √† la variation des prix des actifs financiers.
- Risque de cr√©dit : risque de d√©faut d‚Äôun √©metteur, par exemple une entreprise qui ne rembourse pas ses obligations.
- Risque de liquidit√© : risque de ne pas pouvoir acheter ou vendre rapidement un actif sans influencer son prix de mani√®re significative.
- Risque op√©rationnel : risque de perte r√©sultant de processus internes d√©faillants, d‚Äôerreurs humaines ou de pannes de syst√®mes.


2. M√©triques de risque

Ce sont des mesures quantitatives du risque. Parmi les plus utilis√©es : la volatilit√©, qui mesure la variation des rendements d‚Äôun actif par rapport √† sa moyenne; la Value at Risk (VaR), qui mesure la perte maximale anticip√©e sur un portefeuille, avec un certain niveau de confiance $\alpha$, sur un horizon $T$, la Tracking Error, qui mesure l‚Äô√©cart de performance entre un portefeuille et son indice de r√©f√©rence.

3. Encadrement du risque

Il s‚Äôagit de mettre en place des r√®gles de gestion ou des limites pour √©viter des d√©rives du portefeuille. Cela peut inclure :

- des limites de taille de position,
- la diversification (√©viter la concentration sur un petit nombre d‚Äôactifs),
- l‚Äôusage de produits d√©riv√©s (options, futures) pour se couvrir contre les risques identifi√©s.


**Constitution du portefeuille**

Dans notre √©tude, nous allons constituer un portefeuille de 10 actions choisies dans l‚Äôindice CAC 40, en leur attribuant des poids al√©atoires.

Les actifs retenus sont les suivants :
- Sanofi  
- Soci√©t√© G√©n√©rale  
- Thales  
- Engie  
- Capgemini  
- Carrefour  
- Orange  
- Accor  
- L‚ÄôOr√©al  
- Cr√©dit Agricole

Puisque nous travaillons avec un portefeuille d‚Äôactions, donc le principal risque est le risque de march√© actions.
Nous allons donc nous int√©resser √† trois indicateurs de risque :
- la volatilit√© ex-ante,
- la Value at Risk ex-ante,
- la Tracking Error ex-ante  
c‚Äôest-√†-dire des mesures anticip√©es, bas√©es sur la composition actuelle du portefeuille, et non sur des donn√©es historiques (ex-post).

## R√©cup√©ration des donn√©es

```{python}
#------------------------------------#
#---------- Package Imports ---------#
#------------------------------------#

import warnings
warnings.filterwarnings("ignore")
from datetime import datetime, timedelta
import yfinance as yf 
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import norm
```

```{python}

def get_data(start_date, end_date, index_ticker, tickers):
    """
    Extraction de donn√©es de cours d'actions
    """
    # Extraction des prix historiques des composants
    data = yf.download(tickers, start=start_date, end=end_date, auto_adjust =True)['Close']

    # Extraction des prix historiques de l'indice CAC 40
    index = yf.download(index_ticker, start=start_date, end=end_date, auto_adjust =True)['Close']

    return {
        "portfolio_data": data,
        "benchmark_data": index,
    }
```

```{python}
end_date = pd.to_datetime("2025-01-27")
start_date = end_date - timedelta(days=2*365)

selected_assets = {
    "SAN.PA" : "Sanofi",
    "GLE.PA" : "Soci√©t√© g√©n√©rale",
    "HO.PA" : "Thales",
    "ENGI.PA" : "Engie",
    "CAP.PA" : "Capgemini",
    "CA.PA" : "Carrefour",
    "ORA.PA" : "Orange",
    "AC.PA" : "Accor",
    "OR.PA" : "L'Oreal",
    "ACA.PA" : "Cr√©dit agricole"
}

index = "^FCHI"

assets_ticker  = list(selected_assets.keys())

data = get_data(start_date,end_date, index, assets_ticker)
```

```{python}
portfolio_data = data["portfolio_data"]
portfolio_data.tail()
```

```{python}
benchmark_data = data["benchmark_data"]
benchmark_data.head()
```

```{python}
# On attribue des poids √©quitables pour chaque action
weights_by_asset = {ticker: 1 / len(assets_ticker) for ticker in assets_ticker}
```

Pour connaitre la valeur totale des actifs du portefeuille, nous allons utiliser la notion d'asset under management (AUM) d√©fini comme suit :

$$
AUM(T_n) = \sum_{i=1}^{10} \omega_i \times P_i(T_n),
$$

o√π $\omega_i$ est le poids de l'actif $i$ dans le portefeuille et $P_i(T_n)$ est le prix de l'actif $i$ √† la date $T_n$.

Puisque les rendements sont les seuls facteurs de risque de l'AUM, nous allons nous int√©resser √† la variation de l'AUM entre deux dates $T_n$ et $T_{n+1}$, soit :

$$
\Delta AUM(T_n, T_{n+1}) = AUM(T_{n+1}) - AUM(T_n) = \sum_{i=1}^{10} \omega_i \times (P_i(T_{n+1}) - P_i(T_n)).
$$

```{python}
aum_series = portfolio_data.apply(lambda row: sum(weights_by_asset[ticker] * row[ticker] for ticker in weights_by_asset), axis=1)
aum_series

AUM = pd.DataFrame(aum_series, columns=["AUM"])
AUM.head()
```

```{python}
# --------------------------------------------- #
# Evolution de la valeur totale du portefeuille
# ---------------------------------------------- #

plt.figure(figsize=(12, 4))
plt.plot(AUM, label="AUM")
plt.title("Evolution de l'actif sous gestion")
plt.xlabel("Date")
plt.ylabel("Valeur")
plt.legend()
plt.show()
```

```{python}
# On s'interesse aux variations/rendements de l'AUM
AUM["Variation"] = AUM["AUM"].pct_change()
AUM["Variation"].head()
```

### Estimation de la volatilit√©

Pour estimer la volatilit√© du portefeuille, on peut calculer l'√©cart-type des variations de l'AUM.
On fait le choix de calculer une volatilit√© ex-ante en se basant sur les variation historiques des prix des actifs avec une profondeur historique de 2 ans. Vu qu'on a une volatilit√© quotidienne, on va l'annualiser en multipliant par $\sqrt{252}$.

En g√©n√©ral, sur le march√© action, la volatilit√© quotidienne est environ de 1% et la volatilit√© annuelle est entre 10% et 20%.

```{python}
# Calcul de la volatilit√© du portefeuille
volatility_portfolio = np.std(AUM["Variation"])
annualized_volatility_portfolio = volatility_portfolio * np.sqrt(252)
print(f"Volatilit√© de la performance quotidienne : {volatility_portfolio : .2%}")
print(f"Volatilit√© de la performance annuelle : {annualized_volatility_portfolio : .2%}")
```

```{python}
# Calcul de la volatilit√© de l'indice CAC 40

benchmark_data["Variation"] = benchmark_data["^FCHI"].pct_change()
volatility_benchmark = np.std(benchmark_data["Variation"])
annualized_volatility_benchmark = volatility_benchmark * np.sqrt(252)

print(f"Volatilit√© de l'indice CAC 40 : {volatility_benchmark : .2%}")
print(f"Volatilit√© de l'indice CAC 40 annuelle : {annualized_volatility_benchmark : .2%}")
```

Notre portefeuille nous fournit une volatatilit√© quotidienne sup√©rieure de 3bps √† la volatilit√© du CAC 40. On retrouve sur √† peu pr√®s la m√™me volatilit√© du portefeuille et celle du CAC 40. Il y a donc une certaine homog√©n√©it√© dans le portefeuille que nous avons constitu√©.

> üí° *Note : bp = 0,01%*

### Estimation de la tracking error/erreur de suivi

La tracking error est une mesure de l'√©cart entre la performance d'un portefeuille et celle de son indice de r√©f√©rence. Elle est calcul√©e comme la volatilit√© de la diff√©rence entre les rendements du portefeuille et de l'indice de r√©f√©rence :

$$
TE = \sqrt{Var(R_p - R_b)}
$$

La tracking error mesure l'incercitude du portefeuille par rapport √† l'indice de r√©f√©rence, c'est une mesure relative. Plus la tracking error est √©lev√©e, plus le portefeuille est risqu√©. On ne souhaite sous ou sur-performer l'indice de r√©f√©rence. On souhaite suivre v√©ritablement l'indice de r√©f√©rence.

Pour l'annualiser, on multiplie par $\sqrt{252}$ en supposant que les performances quotidiennes sont ind√©pendantes et donc un utilise l'additivit√© des variances.

```{python}
performance_relative = AUM["Variation"] - benchmark_data["Variation"]

plt.figure(figsize=(12, 4))
plt.plot(performance_relative, label="Performance")
plt.title("Performance du portefeuille par rapport √† l'indice CAC 40")
plt.xlabel("Date")
plt.ylabel("Performance")
plt.legend()

plt.show()
```

```{python}
# Calcul de la tracking error

TE = np.std(AUM["Variation"] - benchmark_data["Variation"]) 
print(f"Tracking error : {TE : .2%}")

TE_annualized = TE * np.sqrt(252)
print(f"Tracking error annualis√© : {TE_annualized : .2%}")
```

### Estimation de la Value-at-Risk (VaR)

La VaR est une mesure de risque qui donne une estimation de la perte maximale que l'on peut subir avec un certain niveau de confiance $\alpha$ sur un horizon de temps donn√©. Par exemple, une VaR √† 5% sur 1 jour de 1000 euros signifie que 95% du temps, on ne perdra pas plus de 1000 euros sur un jour.

$$P(\text{Loss} < \text{VaR}) = \alpha.$$

On peut √©galement raisonner en terme de gain, i.e. Profit and Loss (PnL).

$$P(\text{PnL} > - \text{VaR}) = \alpha.$$

La VaR peut se calculer suivant trois approches :
1. Approche historique : On se base sur les rendements pass√©s selon l'horizon fix√© pour estimer la VaR, √† l'aide d'un quantile empirique d'ordre $\alpha$. Autrement, on peut se baser sur les rendements journaliers et utiliser la m√©thode de rescaling, i.e. $VaR = \sigma \times \Phi^{-1}(\alpha)$.
2. Approche param√©trique : On suppose que les rendements suivent une loi normale.
3. Approche Monte Carlo : On simule les rendements futurs.

Puisqu'on s'int√©resse √† un portefeuille d'actions qui a un indice de r√©f√©rence, on peut √©galement calculer la VaR relative.  La VaR relative suit une philosophie proche du tracking error. Elle se calcule sur les √©carts entre le portefeuille et le benchmark. Elle sert √† mesurer de combien mon portefeuille sous-performe par rapport √† l'indice de r√©f√©rence.

```{python}
# --------------------------------- #
# VaR historique
# --------------------------------- #

seuil = 99/100

VaR_hist_portfolio = np.percentile(AUM["Variation"].dropna(), 100*(1- seuil))
print(f"VaR historique sur le portefeuille : {- VaR_hist_portfolio : .2%}")
print(f"VaR historique sur 20 jours sur le portefeuille : {-VaR_hist_portfolio*np.sqrt(20) : .2%}")

print("=*="*10)

VaR_hist_benchmark = np.percentile(benchmark_data["Variation"].dropna(), 100*(1 - seuil))
print(f"VaR historique sur l'indice CAC 40 : {-VaR_hist_benchmark : .2%}")
print(f"VaR historique sur 20 jours sur l'indice CAC 40 : {-VaR_hist_benchmark*np.sqrt(20) : .2%}")
```

```{python}
# ---------------------------------- #
# VaR param√©trique
# ---------------------------------- #

# PnL ~ N(mu, sigma) ==> PnL = mu + sigma * Z, o√π Z ~ N(0,1)
# P(PnL > -VaR) = alpha <=> P(mu + sigma * Z > -VaR) = alpha <=> P(Z < (-VaR - mu) / sigma) = 1 - alpha
# Donc, -VaR = mu + sigma * quantile(1 - alpha), o√π quantile(1 - alpha) est le quantile de la loi normale standard


mu = np.mean(AUM["Variation"].dropna())
print(f"mu sur le portefeuille : {mu : .2}")
sigma = np.std(AUM["Variation"].dropna())
print(f"sigma sur le portefeuille : {sigma : .2}")

VaR_param_portfolio  = -(mu + sigma * norm.ppf(1 - seuil))

print(f"VaR param√©trique sur le portefeuille : {VaR_param_portfolio : .2%}")
print(f"VaR param√©trique sur 20 jours sur le portefeuille : {VaR_param_portfolio * np.sqrt(20): .2%}")

print("=*="*10)

mu = np.mean(benchmark_data["Variation"].dropna())
print(f"mu sur le benchmark: {mu : .2}")
sigma = np.std(benchmark_data["Variation"].dropna())
print(f"sigma sur le benchmark : {sigma : .2}")

VaR_param_benchmark  = -(mu + sigma * norm.ppf(1 - seuil))

print(f"VaR param√©trique sur le portefeuille : {VaR_param_benchmark : .2%}")
print(f"VaR param√©trique sur 20 jours sur le portefeuille : {VaR_param_benchmark * np.sqrt(20): .2%}")
```

```{python}
# ---------------------------------- #
# VaR relative
# ---------------------------------- #

VaR_hist_relative = np.percentile(performance_relative.dropna(), 100*(1- seuil))
print(f"VaR historique relative : {- VaR_hist_relative : .2%}")
print(f"VaR historique relative sur 20 jours : {-VaR_hist_relative*np.sqrt(20) : .2%}")

print("=*="*10)

mu = np.mean(performance_relative.dropna())
print(f"mu des performances relatives: {mu : .2}")
sigma = np.std(performance_relative.dropna())
print(f"sigma des performances relatives : {sigma : .2}")

VaR_param_relative  = -(mu + sigma * norm.ppf(1 - seuil))

print(f"VaR param√©trique relative : {VaR_param_relative : .2%}")
print(f"VaR param√©trique relative sur 20 jours : {VaR_param_relative * np.sqrt(20): .2%}")
```

# Stress test

Pour tester la robustesse du portefeuille, on peut r√©aliser des stress tests. Ces tests permettent d'√©valuer la performance du portefeuille dans des conditions extr√™mes de march√©. Ils sont souvent utilis√©s pour √©valuer la r√©silience d'un portefeuille face √† des √©v√©nements de march√© inattendus ou extr√™mes.

Ils sont de deux natures :

1. Stress test historique : On soumet le portefeuille √† une p√©riode historique ou on estime avoir eu une condition extr√™me (Covid, Subprime crisis). On rejoue un sc√©nario qui s'est d√©j√† pass√©.

2. Stress test hypoth√©tique : On joue un sc√©nario qui ne s'est jamais r√©alis√©. Exemple, si les actions chutent de 40%, notre portefeuille d'action chute de 40%.

Dans notre cas, nous allons r√©aliser un stress test historique sur la crise de covid. Pour cela, nous allons extraire le prix des actifs du 19 f√©vrier 2020 et du 18 mars 2020. Nous allons ensuite calculer la performance du portefeuille sur cette p√©riode. On va √©galement calculer la performance du CAC 40 sur cette p√©riode pour voir si notre portefeuille a √©t√© plus ou moins r√©silient que le march√©.

```{python}
# Recuperons les prix des actifs le 19/02/2020 et le 18/03/2020
# On va valoriser notre portefeuille √† ces dates et calculer les performances
# A ces dates, le CAC 40 a connu de fortes pertes pendant la COVID-19


start_date = pd.to_datetime("19-02-2020", dayfirst=True)
end_date = start_date + timedelta(days=1)


data_1902 = get_data(start_date,end_date, index, assets_ticker)
portfolio_data_1902=data_1902["portfolio_data"]
benchmark_data_1902=data_1902['benchmark_data']

start_date = pd.to_datetime("18-03-2020", dayfirst=True)
end_date = start_date + timedelta(days=1)


data_1803 = get_data(start_date,end_date, index, assets_ticker)
portfolio_data_1803=data_1803["portfolio_data"]
benchmark_data_1803=data_1803['benchmark_data']

# Concat√©ner les donn√©es des deux dates pour le portefeuille et le benchmark
portfolio_data_stress = pd.concat([portfolio_data_1902, portfolio_data_1803], ignore_index=False)
benchmark_data_stress = pd.concat([benchmark_data_1902, benchmark_data_1803], ignore_index=False)
```

```{python}
# Stress test covid sur le portefeuille
aum_series_stress = portfolio_data_stress.apply(lambda row: sum(weights_by_asset[ticker] * row[ticker] for ticker in weights_by_asset), axis=1)

AUM_stress = pd.DataFrame(aum_series_stress, columns=["AUM"])
AUM_stress["Variation"] = AUM_stress["AUM"].pct_change()

AUM_stress.iloc[-1]
```

```{python}
benchmark_data_stress["Variation"]=benchmark_data_stress["^FCHI"].pct_change()
benchmark_data_stress.iloc[-1]
```

Dans ce cas, nous constatons une perte d'environ 30.64% sur le portefeuille et une perte de 38.55% sur le CAC 40. De ce fait, notre portefeuille a √©t√© plus r√©silient que le march√©. En effet, la perte du portefeuille est inf√©rieure √† celle du CAC 40. On peut donc conclure que notre portefeuille permet de mieux resister au stress test covid que le CAC 40.

## Conclusion

Le risque de march√© constitue un enjeu central dans la gestion d‚Äôactifs. Il est inh√©rent √† toute exposition aux march√©s financiers et doit, √† ce titre, √™tre mesur√©, surveill√© et encadr√© avec rigueur afin de pr√©server les int√©r√™ts des investisseurs.

Des outils tels que la volatilit√©, la tracking error et la Value at Risk (VaR) permettent de quantifier l‚Äôincertitude li√©e aux rendements du portefeuille et d‚Äôanticiper les pertes potentielles dans des conditions normales de march√©.

En compl√©ment, les stress tests jouent un r√¥le fondamental : ils permettent d‚Äô√©valuer la r√©silience du portefeuille face √† des sc√©narios extr√™mes, souvent absents des donn√©es historiques, mais pourtant plausibles dans un contexte de crise.


