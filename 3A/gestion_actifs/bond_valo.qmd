---
title: Valorisation d'une obligation
jupyter: python3
author: "Cheryl Kouadio"
date: "2025-03-23"
---


Une obligation est un titre de cr√©ance √©mis par une entreprise ou une collectivit√© publique afin de financer un projet ou de refinancer une dette. Contrairement aux actions, qui conf√®rent un droit de propri√©t√©, les obligations sont des instruments de dette qui garantissent aux investisseurs des paiements p√©riodiques sous forme d‚Äôint√©r√™ts (coupons) et le remboursement du capital √† une √©ch√©ance d√©termin√©e.

Pour la valoriser, comme pour valoriser n'importe quel produit, nous devons faire l'esp√©rance de la valeur actualis√©e des flux futurs sous la probabilit√© risque neutre. En effet, cela permet de se mettre sous la perspective d'un investisseur qui est indiff√©rent au risque et qui ne demande qu'√† √™tre r√©mun√©r√© pour le temps qu'il pr√™te son argent.

$$
X_{t=0} = \mathbb{E}^Q \left[ e^{-r(T-t)} X_T \right]
$$

La valorisation d‚Äôune obligation repose principalement sur deux notions fondamentales :

- Le taux d‚Äôint√©r√™t : il repr√©sente le co√ªt du capital et refl√®te la r√©mun√©ration exig√©e par les investisseurs pour pr√™ter leur argent. Il peut √™tre per√ßu comme le "loyer" du capital pr√™t√© ou encore comme la compensation pour le risque associ√© √† l‚Äôinvestissement. Ce taux influence directement la valeur d‚Äôune obligation, car une hausse des taux entra√Æne g√©n√©ralement une baisse du prix des obligations existantes sur le march√© secondaire.
- Le taux de recouvrement : il correspond au pourcentage du capital que les investisseurs peuvent esp√©rer r√©cup√©rer en cas de d√©faut de l‚Äô√©metteur. Un taux de recouvrement √©lev√© signifie que, m√™me en cas de faillite, les cr√©anciers peuvent r√©cup√©rer une grande partie de leur investissement, tandis qu‚Äôun taux faible sugg√®re un risque de perte plus important. Historiquement, il est fix√© √† $R = 40\%$.

Valoriser une obligation revient donc √† calculer la valeur actualis√©e des flux futurs de paiement. De ce fait, cela revient √† valoriser les coupons, le nominal en cas de non d√©faut de la part de l'√©metteur et le recouvrement en cas de d√©faut de l'√©metteur.

#### a. Valorisation des coupons
Le coupon est le montant que l‚Äô√©metteur de l‚Äôobligation s‚Äôengage √† verser √† l‚Äôinvestisseur √† intervalles r√©guliers (g√©n√©ralement annuels ou semestriels) jusqu‚Äô√† l‚Äô√©ch√©ance de l‚Äôobligation. Il est exprim√© en pourcentage de la valeur nominale de l‚Äôobligation et peut √™tre fixe ou variable, en fonction des modalit√©s de l‚Äô√©mission.

Vu √† $t$, la valeur d'un coupon $c$ qui sera pay√© √† $T_i$ est donn√©e par :
$$
N \mathbb{E}^Q \left[ e^{-r(Ti-t)} c \right],
$$

o√π $c$ est le coupon, $r$ est le taux d'int√©r√™t sans risque et $T_i$ est la date de paiement du coupon.
Comme le taux d'int√©r√™t est constant, et le paiement du coupon d√©pend de la probabilit√© de survie de l'√©metteur, on peut r√©√©crire la formule pr√©c√©dente comme suit :

$$
N e^{-r(Ti-t)} c \mathbb{P}(\tau > T_i),
$$

o√π $\mathbb{P}(\tau > T_i)$ est la probabilit√© de survie de l'√©metteur √† la date $T_i$.
Le mod√®le utilis√© pour la probabilit√© de survie est le mod√®le √† intensit√© $\lambda$ de Jarrow et Turnbull. La probabilit√© de survie est donn√©e par :

$$
\mathbb{P}(\tau > T_i) = e^{-\int_{t}^{T_i} \lambda(s) ds} = e^{-\lambda \int_{t}^{T_i} ds} = e^{-\lambda (T_i - t)}.
$$

De ce fait, la valorisation du coupon est donn√©e par :

$$
C_{t} = \sum_{i=1}^{n} N \times c \times e^{-r(T_i-t)} \times e^{-\lambda (T_i - t)} = \sum_{i=1}^{n} N \times c \times e^{-(r + \lambda) \times (T_i-t)} \mathbb{1}_{T_i \geq t}
$$


#### b. Valorisation du nominal

Le nominal est le montant demand√© par l'√©metteur. Sa valorisation est donn√©e par :
$$
N_t = N \times e^{-r(T-t)} \times e^{-\lambda (T-t)} \mathbb{1}_{T \geq t}
$$

#### c. Valorisation du recouvrement

Pour valoriser le recouvrement, il est n√©cessaire de connaitre la probabilit√© de d√©faut √† l'instant pr√©cis $t$.

$$
\begin{aligned}
\mathbb{P}(\tau = u) &= \mathbb{P}(u \leq \tau \leq u + du) \\
&= \mathbb{P}(\tau \geq u) - \mathbb{P}(\tau \geq u + du)\\
&= - \frac{ \mathbb{P}(\tau \geq u + du) - \mathbb{P}(\tau \geq u) }{du} du\\
&= -\frac{\mathbb{P}(\tau \geq u)}{du}du \\
&= \lambda e^{\lambda (u-t)} du
\end{aligned}
$$

De ce fait, la valorisation du recouvrement √† t est :
$$
\begin{aligned}
R_t &= \int_t^T N R e^{-rt} \mathbb{P}(\tau = u)  \\
&= \int_t^T N R e^{-rt} \lambda e^{\lambda (u-t)} du \\
&= N \lambda R \times \frac{1 - e^{-(r+\lambda)(T-t)}}{r+\lambda} \mathbb{1}_{T \geq t}
\end{aligned}
$$


En se servant de ces formules, nous pouvons valoriser une obligation de la mani√®re suivante :
$$
\begin{aligned}
B_t &= C_t + N_t + R_t \\
&= N \left[ \sum_{i=1}^{n}  c \times e^{-(r + \lambda) \times (T_i
-t)} \mathbb{1}_{T_i \geq t} + e^{-(r+\lambda)(T-t)} \mathbb{1}_{T \geq t} +  \lambda R \times \frac{1 - e^{-(r+\lambda)(T-t)}}{r+\lambda} \mathbb{1}_{T \geq t} \right]
\end{aligned}


```{python}
import numpy as np
def pricing_bond(t,c,T,r,lambda_,R,N,dt=1):
    """
    Fonction qui calcule la valeur d'une obligation.
    t : date actuelle
    c : coupon
    T : date de maturit√©
    r : taux sans risque
    lambda_ : intensit√© de d√©faut
    R : taux de recouvrement
    N : nominal
    """

    ### Valorisation du coupon
    Ct = N * c * np.sum([np.exp(-(r+lambda_) * (Ti - t)) * (Ti>=t) for Ti in range(dt, T+dt,dt)])

    ### Valorisation du nominal
    #Proba de survie
    PS = np.exp( - lambda_ * (T - t))
    Nt = N * np.exp( -r * (T - t)) * PS * (T>=t)

    ### Valorisation du recouvrement
    if (r+lambda_)==0 :
        R_ = T-t
    else :
        R_ = N * lambda_ * R * ( 1 - np.exp( - (r+lambda_) * (T-t)))/(r+lambda_)
    Rt = R_ * (T >= t)

    ### Valorisation de l'obligation
    Bond = Ct + Nt + Rt
    return Bond
```

## I. Valorisation d'une obligation sans risque de d√©faut

Nous souhaitons valoriser une obligation sans risque de d√©faut, i.e. $\lambda = 0$. Pour ce faire, nous fixons les param√®tres suivants :
- $N = 1$ : le nominal de l'obligation
- $r = 0.02$ : le taux d'int√©r√™t sans risque
- $\lambda = 0$ : l'intensit√© de d√©faut
- $T = 10$ : l'√©ch√©ance de l'obligation
- $c = 0.02$ : le coupon annuel
- $R = 0.4$ : le taux de recouvrement
- $n = 10$ : le nombre de coupons
- $t = 0$ : l'instant pr√©sent


```{python}
t=0
lambda_ = 0
r = 2/100
T = 10
c = 2/100
R = 40/100
N=1

B_t = pricing_bond(t=t,c=c,T=T,r=r,lambda_=lambda_,R=R,N=N)
print(f"Prix de l'obligation vu √† t={t} : {B_t}")
```

En valorisant l'obligation, nous obtenons un prix de $B_0 \approx 0.99$. Ce prix est proche du nominal, car les taux de coupons sont √©gaux au taux de march√©. L'obligation est dite au pair (Prix = Nominal) car elle r√©mun√®re au taux de march√©. Si $c > r$, le prix de l'obligation sera sup√©rieur au nominal, car le march√© se serait ru√© sur cette obligation, car elle offrirait plus que le taux de march√©. Sinon, le prix de l'obligation sera inf√©rieur au nominal, car le march√© serait plus r√©ticent.

> üí° La condition dans laquelle l'obligation √©mise vaut 100% du nominal, i.e. au pair, est $c \approx r + \lambda$. C'est une obligation qui permet de recouvrir ausi bien le risque de taux ($r$) et le risque de cr√©dit li√© √† l'intensit√© de d√©faut ($\lambda$).
Pour voir ceci, nous avons impl√©ment√© ci-dessous une fonction qui permet d'extrait le coupon qui permet d'avoir une obligation au pair, avec les m√™mes param√®tres que pr√©c√©demment.

```{python}
t=0
lambda_ = 1/100
r = 2/100
T = 10
R = 40/100
N=1

# M√©thode de dichotomie
from scipy.optimize import bisect

def trouver_coupon(t, T, r, lambda_, R, N, dt=1, tol=1e-6):
    """
    Trouve le coupon c tel que la valeur de l'obligation soit √©gale √† N.
    """
    def equation(c):
        return pricing_bond(t, c, T, r, lambda_, R, N, dt) - N
    
    c_opt = bisect(equation, 0, 1, xtol=tol)  # Recherche de c dans l'intervalle [0,1]
    return c_opt

c_opt = trouver_coupon(t=t, T=T, r=r, lambda_=lambda_, R=R, N=N)
c_opt

print(f"Coupon pour avoir une obligation au pair vu √† t={t} : {c_opt:.2%}")
B_t = pricing_bond(t=t,c=c_opt,T=T,r=r,lambda_=lambda_,R=R,N=N)
print(f"Prix de l'obligation vu √† t={t} : {B_t}")
```

> De plus, lorsque l'intensit√© de d√©faut est tr√®s grande, on retrouve un prix √† peu pr√®s √©gal au taux de recouvrement. En effet, la probabilit√© de d√©faut est tr√®s grande et donc la probabilit√© qu'il y ait un recouvrement est tr√®s √©lev√©e. (voir exemple ci-dessous)

```{python}
t=0
lambda_ = 10
r = 2/100
T = 10
c = 2/100
R = 40/100
N=1


B_t = pricing_bond(t=t,c=c,T=T,r=r,lambda_=lambda_,R=R,N=N)
print(f"Prix de l'obligation vu √† t={t} : {B_t:.4f}")
print(f"Taux de recouvrement : {R:.4f}")
```

## II. Evolution du prix de l'obligation en fonction du temps

Durant la vie de l'obligation, son prix √©volue en fonction des paiements de coupons. √Ä chaque distribution de coupon, une chute du prix de l'obligation est observ√©e. Cette baisse s'explique par le fait que, juste avant le versement, le prix de l'obligation int√®gre la valeur du coupon √† percevoir. Une fois le coupon pay√© aux d√©tenteurs, cette valeur dispara√Æt, entra√Ænant m√©caniquement une diminution du prix de l'obligation, jusqu'√† atteindre le nominal de l'obligation ainsi que le dernier coupon.

Toutefois, apr√®s cette chute li√©e au d√©tachement du coupon, la valeur de l'obligation remonte progressivement √† mesure que l'√©ch√©ance du prochain coupon approche. Ce ph√©nom√®ne cr√©e une √©volution en dents de scie, o√π chaque baisse correspond √† un paiement de coupon et chaque remont√©e traduit l‚Äôaccumulation de la valeur du prochain paiement attendu.

Bien que ce ph√©nom√®ne soit logique et attendu, il peut √™tre per√ßu n√©gativement car la forme en dents de scie pourrait donner l‚Äôimpression d‚Äôune d√©gradation de la qualit√© de l'obligation. C‚Äôest pourquoi on distingue deux types de prix :

- Le dirty price (prix sale) : il correspond au prix de l'obligation tel qu'affich√© sur le march√©, int√©grant les variations dues aux paiements de coupons.
- Le clean price (prix net ou pied de coupon) : il correspond au prix de l'obligation "nettoy√©" des coupons accumul√©s. Ce prix est obtenu en soustrayant les int√©r√™ts courus au dirty price.
Ainsi, le clean price permet d'√©valuer plus pr√©cis√©ment la valeur intrins√®que de l'obligation sans √™tre pollu√© par les variations dues aux paiements p√©riodiques de coupons. C'est cette valeur qui est g√©n√©ralement utilis√©e pour comparer les obligations entre elles.


Pour illustrer cette √©volution, nous avons trac√© l'√©volution du prix de l'obligation en fonction du temps. Nous avons fix√© les param√®tres suivants :
- $N = 1$ : le nominal de l'obligation
- $r = 0.02$ : le taux d'int√©r√™t sans risque
- $\lambda = 0.01$ : l'intensit√© de d√©faut
- $T = 10$ : l'√©ch√©ance de l'obligation
- $c = 0.03$ : le coupon annuel
- $R = 0.4$ : le taux de recouvrement
- $n = 10$ : le nombre de coupons
- $t = 0$ : l'instant pr√©sent

```{python}
def myFloor(x):
    if x==0:
        return 0
    if x==np.floor(x):
        return x-1
    return np.floor(x)

def clean_price(t,c,T,r,lambda_,R,N,dt=1):
    """
    Fonction qui calcule le prix d'une obligation propre.
    """
    B_t = pricing_bond(t,c,T,r,lambda_,R,N,dt)
    cc = c * (t - myFloor(t))

    return B_t - cc
```

```{python}
t=0
lambda_ = 1/100
r = 2/100
T = 10
c = 3/100
R = 40/100
N=1


dirty_prices = []
clean_prices = []
grid_values_c = np.arange(0,T+0.001,0.001)
for t in grid_values_c:
    dirty_prices.append(pricing_bond(t,c,T,r,lambda_,R,N))
    clean_prices.append(clean_price(t,c,T,r,lambda_,R,N))


import matplotlib.pyplot as plt
plt.plot(grid_values_c,dirty_prices, label="Dirty prices")
plt.plot(grid_values_c,clean_prices, label="Clean prices")
plt.title("Dirty prices vs Clean prices")
plt.xlabel("t")
plt.grid()
plt.legend()
plt.ylabel("Prix de l'obligation")
```

### a. Cas extr√™mes  

Nous avons analys√© l'√©volution du prix de l'obligation dans deux cas extr√™mes afin d'observer l'impact du coupon sur la dynamique des prix. Toutes choses √©gales par ailleurs, nous avons modifi√© le coupon de l'obligation tout en conservant les autres param√®tres constants. Les deux sc√©narios √©tudi√©s sont les suivants :  
- $ c = 0.01 $ : le coupon est inf√©rieur au taux d'int√©r√™t sans risque.  
- $ c = 0.05 $ : le coupon est sup√©rieur au taux d'int√©r√™t sans risque.  

#### Cas 1 : $ c = 0.01 $  

Lorsque $ c = 1\% $ et que ce coupon est inf√©rieur au taux d'int√©r√™t sans risque $ r $, la valeur de l'obligation √©volue de mani√®re sp√©cifique :  

- Au d√©part, l'obligation est escompt√©e car le coupon est faible, et les investisseurs anticipent un rendement global inf√©rieur au taux du march√©.  
- √Ä mesure que l‚Äô√©ch√©ance approche, l'incertitude sur le paiement du coupon dispara√Æt progressivement. Les investisseurs deviennent de plus en plus certains que le paiement aura bien lieu.  
- √Ä la veille du paiement, l'obligation converge vers un prix proche de $ N + c $ pour le dirty price (car elle inclut le coupon accumul√©) et $ N $ pour le clean price (qui exclut le coupon accumul√©).  

Cela signifie que l‚Äôobligation s‚Äôappr√©cie au fil du temps en raison de la certitude croissante du paiement des flux futurs. En d‚Äôautres termes, plus l‚Äô√©ch√©ance se rapproche, plus l'investisseur est assur√© de recevoir ses paiements, ce qui entra√Æne une augmentation progressive de la valeur de l'obligation.  

```{python}
lambda_ = 1/100
r = 2/100
T = 10
c1 = 1/100
R = 40/100
N=1

clean_prices1 = []
dirty_prices1 = []
for t in grid_values_c:
    B_t_dirty = pricing_bond(t=t,c=c1,T=T,r=r,lambda_=lambda_,R=R,N=N)
    B_t_clean = clean_price(t=t,c=c1,T=T,r=r,lambda_=lambda_,R=R,N=N)
    clean_prices1.append(B_t_clean)
    dirty_prices1.append(B_t_dirty)

plt.plot(grid_values_c,clean_prices1, label="Clean prices")
plt.plot(grid_values_c,dirty_prices1, label="Dirty prices")
plt.title("Clean prices vs Dirty prices")
plt.legend()
plt.grid()
plt.xlabel("t")
plt.ylabel("Prix de l'obligation")
```

#### Cas 2 : $ c = 0.05 $  

Lorsque $ c = 5\% $ et que ce coupon est sup√©rieur au taux d'int√©r√™t sans risque $ r $, la dynamique du prix de l'obligation suit une √©volution inverse :  

- Au d√©part, l'obligation est pris√©e au-dessus du nominal (elle se n√©gocie avec une prime). Cela s'explique par le fait que son coupon g√©n√©reux attire les investisseurs, qui consid√®rent que le rendement offert par l'obligation compense largement le risque de cr√©dit et est plus attractif que les opportunit√©s de placement √† taux sans risque.  
- √Ä mesure que l‚Äô√©ch√©ance approche, la valeur de l'obligation se depr√©cie progressivement. En effet, √† chaque p√©riode, l'investisseur re√ßoit un coupon √©lev√©, mais √† l'√©ch√©ance, il ne r√©cup√®re que le nominal $ N $, ce qui entra√Æne une correction progressive du prix de march√©.  
- √Ä la veille du remboursement, l'obligation converge vers $ N + c $ pour le dirty price (qui inclut le dernier coupon √† verser) et vers $ N $ pour le clean price.  

Ainsi, cette obligation se d√©pr√©cie progressivement jusqu'√† l'√©ch√©ance, car l'effet attractif du coupon √©lev√© s'amenuise √† mesure que le remboursement du capital nominal devient imminent. En d'autres termes, l'obligation part d'une valeur sup√©rieure √† son nominal mais perd progressivement sa prime √† l'approche de l'√©ch√©ance.  

```{python}
lambda_ = 1/100
r = 2/100
T = 10
c2 = 5/100
R = 40/100
N=1

clean_prices2 = []
dirty_prices2 = []
for t in grid_values_c:
    B_t_dirty = pricing_bond(t=t,c=c2,T=T,r=r,lambda_=lambda_,R=R,N=N)
    B_t_clean = clean_price(t=t,c=c2,T=T,r=r,lambda_=lambda_,R=R,N=N)
    clean_prices2.append(B_t_clean)
    dirty_prices2.append(B_t_dirty)

plt.plot(grid_values_c,clean_prices2, label="Clean prices")
plt.plot(grid_values_c,dirty_prices2, label="Dirty prices")
plt.title("Clean prices vs Dirty prices")
plt.legend()
plt.grid()
plt.xlabel("t")
plt.ylabel("Prix de l'obligation")
```

## III. √âvolution du prix en fonction du taux d'int√©r√™t  

Le prix d'une obligation est une fonction d√©croissante du taux d'int√©r√™t. En effet, plus le taux d'int√©r√™t est √©lev√©, plus la valeur actualis√©e des flux futurs (coupons et remboursement du nominal) est faible, ce qui r√©duit m√©caniquement le prix de l'obligation.  

Dans cette analyse, il est inutile de distinguer le dirty price et le clean price, car la diff√©rence entre les deux ne d√©pend pas du taux d'int√©r√™t. De plus, en consid√©rant $t = 0 $, il n'y a pas encore d‚Äôint√©r√™ts courus ($c = 0 $), donc les deux prix co√Øncident.  

### Obligation au pair  

Autour de $c - \lambda = 2\% $, le prix de l'obligation est √©gal au nominal. Cela s'explique par le fait que le taux de coupon est exactement √©gal au taux de march√©. L'obligation est alors dite "au pair", car les investisseurs n'ont ni prime ni d√©cote √† appliquer sur son prix.  

### Explication de la relation n√©gative entre prix et taux  

La relation n√©gative entre le prix d'une obligation et le taux d'int√©r√™t s‚Äôexplique par l'effet de substitution avec les nouvelles √©missions obligataires.  

- Lorsque les taux d'int√©r√™t augmentent, de nouvelles obligations sont √©mises avec des coupons plus attractifs.  
- En cons√©quence, les obligations existantes, qui offrent un coupon fixe plus faible, deviennent moins int√©ressantes pour les investisseurs. Leur prix diminue afin d'ajuster leur rendement effectif au nouveau niveau des taux du march√©.  
- Inversement, si les taux d'int√©r√™t baissent, les obligations existantes deviennent plus attractives puisqu'elles offrent un coupon plus √©lev√© que les nouvelles √©missions, ce qui entra√Æne une hausse de leur prix sur le march√© secondaire.  

Ainsi, la sensibilit√© d'une obligation aux variations de taux d'int√©r√™t, appel√©e "duration", est un √©l√©ment cl√© dans l'√©valuation du risque de taux et la gestion de portefeuille obligataire.  

```{python}
t=0
lambda_ = 1/100
T = 10
c =3/100
R = 40/100
N=1

dirty_prices = []
grid_values_r = np.arange(0,1,0.001) 
for r in grid_values_r:
    B_t_dirty = pricing_bond(t=t,c=c,T=T,r=r,lambda_=lambda_,R=R,N=N)
    dirty_prices.append(B_t_dirty)

plt.plot(grid_values_r,dirty_prices, label="Dirty prices")
plt.title("Prix de l'obligation en fonction du taux d'int√©r√™t")
plt.legend()
plt.grid()
plt.xlabel("r")
plt.ylabel("Prix de l'obligation")
```

## IV. Sensibilit√© du prix de l'obligation au taux d'int√©r√™t / Duration  

La duration est une mesure de la sensibilit√© du prix d'une obligation aux variations du taux d'int√©r√™t. Elle permet d'√©valuer le risque de taux, c'est-√†-dire l'impact d'une variation des taux sur la valeur de l'obligation.  

> Dans le cas de l'√©volution du prix en fonction du taux d'int√©r√™t, la duration sera donc la pente de la courbe repr√©sentant cette relation.

Math√©matiquement, la duration est d√©finie comme la d√©riv√©e du prix de l'obligation par rapport au taux d'int√©r√™t :  

$$
\delta = - \frac{d B_t}{d r} \times \frac{1}{B_t}
$$

En utilisant une approximation en diff√©rences finies, on exprime cette d√©riv√©e de la mani√®re suivante :  

$$
\frac{d B_t}{d r}  \approx \frac{B_t(r+\Delta r) - B_t(r)}{\Delta r}
$$

Cette sensibilit√© permet de mesurer la variation du prix de l'obligation en r√©ponse √† une fluctuation du taux d'int√©r√™t, offrant ainsi une √©valuation directe du risque de taux auquel est expos√© l'investisseur. De ce fait, si les taux d'int√©r√™t bouge de $\Delta r$ = 1%, alors les prix bougeront de -sensibilit√© * $\Delta r$ .

Nous allons impl√©menter ce calcul en Python, en prenant $\Delta r = 1$ bp (soit $0.0001$ en notation d√©cimale).  

```{python}
def sensivity_to_rate(t,c,T,r,lambda_,R,N,dt=1,dr= 0.01/100):
    """
    Fonction qui calcule la sensibilit√© d'une obligation √† un taux d'int√©r√™t.
    """
    B_t = pricing_bond(t,c,T,r,lambda_,R,N,dt)
    B_t_plus = pricing_bond(t,c,T,r+dr,lambda_,R,N,dt)
    sensivity = -((B_t_plus - B_t)/dr) * (1/B_t)
    return sensivity
```

Si les taux d'int√©r√™t bouge de $\Delta r$ = 1%, alors les prix bougeront de -sensibilit√© * $\Delta r$ = -8,64 * 1%.
La duration va √™tre souvent proche de la maturit√©.

```{python}
t=0
lambda_ = 1/100
T = 10
c =3/100
R = 40/100
r = 2/100
N=1

sensivity_to_rate(t,c,T,r,lambda_,R,N)
```

D'un point de vue graphique, il existe une certaine identit√© entre la maturit√© et la duration, car cette derni√®re peut √™tre interpr√©t√©e comme le barycentre des flux futurs de l'obligation. Plus ces flux sont concentr√©s dans le temps, plus leur pond√©ration affecte la sensibilit√© du prix aux variations des taux d'int√©r√™t.  

#### Lien entre duration et maturit√©  

- La duration est une approximation de la dur√©e d'exposition au risque, ajust√©e en fonction des flux de paiements.  
- Elle est souvent proche de la maturit√© moyenne de l'obligation, bien que l√©g√®rement inf√©rieure (environ 80% de la maturit√© totale, en fonction des conditions de march√© et du niveau des coupons).  

Ainsi, plus l'√©ch√©ance de l'obligation se rapproche, plus la duration tend √† augmenter, car les flux futurs deviennent plus proches dans le temps, rendant l'obligation plus sensible aux variations des taux d'int√©r√™t.


>Lorsque la maturit√© de l'obligation approche, sa sensibilit√© au taux d'int√©r√™t tend √† augmenter. En effet, la duration peut √™tre interpr√©t√©e comme une mesure du temps moyen pond√©r√© pendant lequel l‚Äôinvestisseur est expos√© au risque de taux.  

```{python}
t=0
lambda_ = 1/100
r = 2/100
c =3/100
R = 40/100
N=1

dirty_prices = []
grid_values_T = np.arange(1,20,1)
for T in grid_values_T:
    B_t_dirty = sensivity_to_rate(t,c,T,r,lambda_,R,N)
    dirty_prices.append(B_t_dirty)

plt.plot(grid_values_T,dirty_prices, label="Dirty prices")
plt.title("Sensibilit√© en fonction de la maturit√©")
plt.legend()
plt.grid()
plt.xlabel("T")
plt.ylabel("Sensibilit√©")
```

#### Cas particulier : absence de coupon, de taux d'int√©r√™t et de risque de d√©faut  

Lorsque le coupon, le taux d'int√©r√™t et l'intensit√© de d√©faut sont nuls, la duration est exactement √©gale √† la maturit√© de l‚Äôobligation. Puisque la duration peut √™tre interpr√©t√©e comme le barycentre des flux futurs de l'obligation, lorsque le coupon et l'intensit√© de d√©faut sont nuls, tous les flux sont concentr√©s √† l'√©ch√©ance, ce qui √©quivaut √† la maturit√© de l'obligation.

```{python}
t=0
c = lambda_ = 10e-6
R = 40/100
N=1


dirty_prices = []
for T in grid_values_T:
    B_t_dirty = sensivity_to_rate(t,c,T,r,lambda_,R,N)
    dirty_prices.append(B_t_dirty)

plt.plot(grid_values_T,dirty_prices, label="Dirty prices")
plt.title("Sensibilit√© au taux en fonction de la maturit√©")
plt.legend()
plt.grid()
plt.xlabel("T")
plt.ylabel("Sensibilit√©")
```

>Dans le risque de taux, le principale indicateur est la duration.

## V. Mod√®lisation de la VaR

### V.1. Approche par la sensibilit√©

Selon le mod√®le de Hull et White, le taux d'int√©r√™t est mod√©lis√© par :

$$
dr = \theta ( \mu - r) dt + \sigma dW
$$

o√π $\theta$ est le coefficient de vitesse de r√©version, $\mu$ est le taux d'int√©r√™t moyen, $\sigma$ est la volatilit√© du taux d'int√©r√™t et $dW$ est un mouvement brownien.
Ce mod√®le a la sp√©cifit√© d'√™tre normale. De ce fait, $\Delta r \sim N(0, \sigma^2 \Delta t)$.
En faisant l'approximation de la variation du prix, il est possible d'approcher une VaR par la sensibilit√© :

$$
\begin{aligned}
Duration &= - \frac{d B_t}{d r} \times \frac{1}{B_t} \\
\frac{d B_t}{B_t} &\approx - Duration \times  \Delta r \\
\end{aligned}
$$

```{python}
# Objectif : √©crire une fonction qui calcule la VaR avec l'approche par duration
from scipy.stats import norm

def sensitive_VaR(mu,sigma,t,c,T,r,lambda_,R,N,h,dt=1,alpha=0.99) :
    """
    Calcul de la VaR gaussienne
    data : les rendements logarithmiques
    alpha : le niveau de confiance
    """
    Duration = sensivity_to_rate(t,c,T,r,lambda_,R,N,dt)

    return -(mu + Duration * sigma * np.sqrt(h) * norm.ppf(1 - alpha))

#--------------------------------------
# Param√®tres du mod√®le de taux
#---------------------------------------

mu = 0
h = 1/12
sigma = 0.01

#--------------------------------------
# Param√®tres de la valorisation du bond
#---------------------------------------

t=0
lambda_ = 1/100
r = 2/100
c =3/100
R = 40/100
N=1
T=10

VaR = sensitive_VaR(mu,sigma,t,c,T,r,lambda_,R,N,h=h,dt=1,alpha=0.99)
print(f"VaR estim√© par l'approche par la sensibilit√© : {VaR:.4%}")
```

Pour cette estimation, nous avions suppos√© que la volatilit√© $\sigma = 1\%$. Cependant, cette hypoth√®se pourrait s'√©carter de la r√©alit√©. Pour ce faire, nous allons extraire les donn√©es de taux d'int√©r√™t et calculer la volatilit√© empirique. L'ESTR est un taux un jour collat√©ralis√©,c'est donc quasiment sans risque. Nous allons donc utiliser ce taux pour calculer la volatilit√© empirique.
Pour cela, nous allons utiliser l'historique des taux d'int√©r√™t de l'ESTR sur une p√©riode de 5 ans, i.e. 10/03/2025 - 12/03/2020, disponible sur ce lien : y revenir.

Pour ce faire, nous utilisons la formule suivante :

$$
\sigma = \sqrt{\frac{1}{n-1} \sum_{i=1}^{n} (r_i - \bar{r})^2}
$$

Nous constatons que la volatilit√© empirique sur les 5 ans est de 25.45%. Cette valeur est tr√®s √©lev√©e, ce qui signifie que les taux d'int√©r√™t ont connu des variations importantes sur cette p√©riode. Cela peut √™tre du √† la trop grande p√©riode utilis√©e pour la calibration de la volatilit√©. 
Pour ce faire, nous avons restreint la p√©riode √† 1 an, i.e. 10/03/2025 - 10/03/2024. La volatilit√© empirique sur cette p√©riode est de 1.04%. Cette valeur est plus coh√©rente avec les taux d'int√©r√™t sans risque.

```{python}
import pandas as pd
estr_df = pd.read_excel("estr.xlsx", skiprows=6)
#date as date
estr_df["Date"] = pd.to_datetime(estr_df["Date"], format="%Y-%m-%d")
estr_df = estr_df.set_index("Date")
estr_df = estr_df.sort_index()

estr_df.head()
```

```{python}
vol_est = np.std(estr_df["PX_LAST"].pct_change())
print(f"Volatilit√© estim√©e sur 5 ans: {vol_est:.4f}")

# volatilit√© sur 1 an
vol_est= np.std(estr_df.loc["2024-03-10":"2025-03-10", "PX_LAST"].pct_change())
print(f"Volatilit√© estim√©e sur 1 an : {vol_est:.4f}")
```

### V.2. Approche avec un repricing

Cette approche consiste √† revaloriser, sous l'hypoth√®se de normalit√© des taux, l'obligation √† l'instant $t$ pour un taux $r + \Delta r$ et de calculer la perte maximale possible. De ce fait, elle est plus pr√©cise que l'approche par la sensibilit√©.

Puisque dans le cas d'une obligation, ce dont on veut se pr√©munir c'est de la hausse des taux (puisqu'elle fait baisser le taux d'int√©r√™t). De ce fait, la VaR est donn√©e par :

$$
\text{VaR} =  - \frac{B_t(r + \Delta r) - B_t }{B_t},
$$

o√π $\Delta r$ est la variation des taux d'int√©r√™t.

Par d√©finition, la VaR estim√©e sera plus basse que l'autre approche en raison de la convexit√© de l'√©volution du prix de l'obligation en fonction des taux d'int√©r√™t. La Var par l'approche de la sensibilit√©, quant √† elle, suppose une lin√©arit√© de l'√©volution du prix de l'obligation en fonction des taux d'int√©r√™t.

```{python}
def repricing_VaR(mu,sigma,t,c,T,r,lambda_,R,N,h,dt=1,alpha=0.99) :
    """
    Calcul de la VaR gaussienne
    data : les rendements logarithmiques
    alpha : le niveau de confiance
    """
    delta_r = mu + sigma * np.sqrt(h) * norm.ppf(alpha)
    P_t = pricing_bond(t,c,T,r,lambda_,R,N,dt)
    P_t_shocked = pricing_bond(t,c,T,r+delta_r,lambda_,R,N,dt)

    VAR = -( (P_t_shocked - P_t)/P_t)

    return VAR, delta_r


#--------------------------------------
# Param√®tres du mod√®le de taux
#---------------------------------------
mu = 0
h = 1/12
sigma = 0.01

#--------------------------------------
# Param√®tres de la valorisation du bond
#---------------------------------------
t=0
lambda_ = 1/100
r = 2/100
c =3/100
R = 40/100
N=1
T=10

VaR, delta_r = repricing_VaR(mu,sigma,t,c,T,r,lambda_,R,N,h=h,dt=1,alpha=0.99)

print(f"VaR estim√© par l'approche par le r√©ajustement : {VaR:.4%}")
print(f"Choc de taux : {delta_r:.2%}")
```

## VI. Focus risque de cr√©dit & contrepartie

### VI.1. Comment estimer l'intensit√© de d√©faut ?

Pr√©cedemment, nous avons valoriser l'obligation de la mani√®re suivante :

$$
\begin{aligned}
B_t &= C_t + N_t + R_t \\
&= N \left[ \sum_{i=1}^{n}  c \times e^{-(r + \lambda) \times (T_i
-t)} \mathbb{1}_{T_i \geq t} + e^{-(r+\lambda)(T-t)} \mathbb{1}_{T \geq t} +  \lambda R \times \frac{1 - e^{-(r+\lambda)(T-t)}}{r+\lambda} \mathbb{1}_{T \geq t} \right]
\end{aligned}
$$

et nous avons signfi√© la condition dans laquelle l'obligation √©mise vaut 100\% du nominal, i.e. au pair, est $c \approx r + \lambda$. Cependant, ce n'est pas exact.

Soit un coupon pay√© en continu, la valorisation de l'obligation est donn√©e par :

$$
\begin{aligned}
B_t &= N \left[ \int_{t}^{T} c e^{-(r + \lambda) \times (u-t)} du + e^{-(r+\lambda)(T-t)} +  \lambda R \times \frac{1 - e^{-(r+\lambda)(T-t)}}{r+\lambda} \right]\\
&= N \left[ \frac{c}{r + \lambda} \left(1 - e^{-(r + \lambda)(T-t)} \right) + e^{-(r+\lambda)(T-t)} +  \lambda R \times \frac{1 - e^{-(r+\lambda)(T-t)}}{r+\lambda} \right]\\
B_t = N &\Leftrightarrow c = r + \lambda (1 - R) \\
& c - r = \lambda (1 - R) 
\end{aligned}
$$

De ce fait, en extrayant $c$, la condition dans laquelle l'obligation √©mise vaut 100\% du nominal, i.e. au pair, est $c = r + \lambda (1 - R) $.

> üí° $s = c-r$ est la prime de cr√©dit ou encore le spread de cr√©dit. C'est la prime que l'investisseur demande pour le risque de cr√©dit. Si $c > r$, l'obligation est √©mise √† un prix sup√©rieur √† 100\% du nominal. Si $c < r$, l'obligation est √©mise √† un prix inf√©rieur √† 100\% du nominal. Ce spread permet de faire la relation entre la PD exprim√© par $\lambda$ et la LGD exprim√© par $1 -R$. Cette information est plus facile √† avoir que l'intensit√© de d√©faut car le spread est cot√© sur le march√© √† travers les CDS. Par d√©finition, on en d√©duit facilement que plus cettre prime est √©lev√©, plus l'emetteur est risqu√©.

Take away : Les notions de duration et de spread sont tr√®s importants dans la mod√©lisation du risque de taux

#### cas de l'argentine, pays risqu√©

```{python}
s = 1031/10000 
R = 0.4
lambda_ = s / (1 - R)
t=0

print(f"Spread de cr√©dit : {s:.2%}")
print(f"Recouvrement : {R:.2%}")
print(f"Intensit√© de d√©faut : {lambda_:.2%}")
PS = [np.exp( - lambda_ * (T - t)) for T in range(1, 21)]

plt.plot(range(1,21),PS)
plt.title("Probabilit√© de survie en fonction de la maturit√©")
plt.xlabel("T")
plt.ylabel("Probabilit√© de survie")
plt.grid()
```

#### cas de la France

```{python}
# Cas de la France
s = 32.4/10000 
R = 0.4
lambda_ = s / (1 - R)
t=0

print(f"Spread de cr√©dit : {s:.2%}")
print(f"Recouvrement : {R:.2%}")
print(f"Intensit√© de d√©faut : {lambda_:.2%}")
PS = [np.exp( - lambda_ * (T - t)) for T in range(1, 21)]

plt.plot(range(1,21),PS)
plt.title("Probabilit√© de survie en fonction de la maturit√©")
plt.xlabel("T")
plt.ylabel("Probabilit√© de survie")
plt.grid()
```

En comparant les deux pays, l'Argentine et la France. On sait que l'argentine est un pays plus risqu√© que la France. Cela se voit √©galement au niveau des spreads de cr√©dit.
En effet, le spread de l'Argentine est plus √©lev√© que celui de la France. Cela signifie que les investisseurs demandent une prime de risque plus √©lev√©e pour investir dans des obligations argentines que dans des obligations fran√ßaises. De plus, en regardant la probabilit√© de survie des deux pays, on constate que la probabilit√© de survie de l'Argentine est plus faible que celle de la France. Cela signifie que les investisseurs consid√®rent que l'Argentine est plus susceptible de faire d√©faut que la France.

### VI.2 Sensibilit√© cr√©dit

```{python}
def sensivity_to_credit(t,c,T,r,lambda_,R,N,dt=1,dlambda_= 0.01/100):
    """
    Fonction qui calcule la sensibilit√© d'une obligation √† un taux d'int√©r√™t.
    """
    B_t = pricing_bond(t,c,T,r,lambda_,R,N,dt)
    B_t_plus = pricing_bond(t,c,T,r,lambda_ + dlambda_,R,N,dt)
    
    sensivity = -((B_t_plus - B_t)/dlambda_) * (1/B_t) * (1/ (1-R))

    return sensivity
```

```{python}
t=0
lambda_ = 1/100
T = 10
c =3/100
R = 40/100
r = 2/100
N=1

sensivity_to_credit(t,c,T,r,lambda_,R,N,dlambda_=0.01/100)
```

```{python}
t=0
lambda_ = 1/100
r = 2/100
c =3/100
R = 40/100
N=1

dirty_prices = []
grid_values_T = np.arange(1,20,1)
for T in grid_values_T:
    B_t_dirty = sensivity_to_credit(t,c,T,r,lambda_,R,N)
    dirty_prices.append(B_t_dirty)

plt.plot(grid_values_T,dirty_prices, label="Dirty prices")
plt.title("Sensibilit√© cr√©dit en fonction de la maturit√©")
plt.legend()
plt.grid()
plt.xlabel("T")
plt.ylabel("Sensibilit√©")
```

Soit le mod√®le normale pour le taux :

$$
dr_t = \theta (\mu - r_t) dt + \sigma_r dW_t
$$

et un mod√®le log normale pour le spread de cr√©dit, puisqu'il ne peut √™tre n√©gatif :
$$
\frac{ds_t}{s_t} = \sigma_s dZ_t
$$  

Ces deux mod√®les sont li√©s par $dW_t dZ_t = \rho dt$. On peut exprimer cette relation par $Z_t = \rho W_t + \sqrt{1 - \rho^2} V_t$, o√π $V_t$ est un mouvement brownien standard ind√©pendant de $W_t$. Cette corr√©lation est positive. 
> üí° si les taux d'int√©r√™t montent, le risque de cr√©dit augmente puisque les entreprises ont plus de mal √† rembourser leur dette. De ce fait, le spread de cr√©dit augmente.

Supposons qu'on cherche √† calculer une VaR d'horizon $h$. Pour cela, il faudra faire des simulations de Monte Carlo pour les deux mod√®les. 

$$
\begin{aligned}
r_{t+h} &= r_t + \theta (\mu - r_t) h + \sigma_r \sqrt{h} W_t \\
s_{t+h} &= s_t \exp(\sigma_s \sqrt{h} Z_t) \\
ou \quad s_{t+h} &= s_t (1 + \sigma_s \sqrt{h} Z_t) \quad (\text{par DL})
\end{aligned}
$$

Posons les param√®tres suivants :
- $\theta = 0.1$ : le coefficient de vitesse de r√©version
- $\mu = 0.02$ : le taux d'int√©r√™t moyen
- $\sigma_r = 0.01$ : la volatilit√© du taux d'int√©r√™t
- $\sigma_s = 0.4$ : la volatilit√© du spread de cr√©dit
- $\rho = 0.4$ : la corr√©lation entre les deux mouvements browniens
- $r = 0.02$ : le taux d'int√©r√™t initial
- $h = 1/12$ : l'horizon de calcul de la VaR
- $c = 3\%$ : le coupon annuel
- $R = 40\%$ : le taux de recouvrement
- $N = 1$ : le nominal de l'obligation
- $T = 10$ : l'√©ch√©ance de l'obligation

```{python}
import numpy as np

def MC_VaR(c,T,r,lambda_,R,N,h,sigma_r, sigma_s, rho, alpha=0.99, N_MC=1000,dt=1):
    # print("Parameters")
    # print(f"coupon : {c:.2%}")
    # print(f"maturity : {T} years")
    # print(f"risk free rate : {r:.2%}")
    # print(f"credit spread : {lambda_:.2%}")
    # print(f"recovery rate : {R:.2%}")
    # print(f"nominal : {N}")

    prices = []
    
    P_0 = pricing_bond(t=0,c=c,T=T,r=r,lambda_=lambda_,R=R,N=N,dt=dt)
    # print(f"P0 : {P_0}")

    s_0 = lambda_ * (1 - R)
    r_0 = r

    for t in range(N_MC):
        # Generate correlated Brownian motions
        W1 = np.random.normal()
        W2 = rho * W1 + np.sqrt(1 - rho) * np.random.normal()

        # Euler discretization 
        r_h = r_0 + sigma_r * np.sqrt(h) * W1
        s_h = s_0 * ( 1 + sigma_s * np.sqrt(h) * W2)
        lambda_h = s_h / (1 - R)
        # print("="*30)
        # print("Parameters")
        # print(f"coupon : {c:.2%}")
        # print(f"maturity : {T} years")
        # print(f"risk free rate : {r_h:.2%}")
        # print(f"credit spread : {lambda_h:.2%}")
        # print(f"recovery rate : {R:.2%}")
        # print(f"nominal : {N}")

        P_h = pricing_bond(t=h,c=c,T=T,r=r_h,lambda_ = lambda_h,R=R,N=N,dt=dt)
        # print(f"Price : {P_h}")
        variation = (P_h - P_0)/P_0
        prices.append(variation)


    VaR = np.quantile(prices, 1 - alpha)

    return VaR

sigma_r = 0.01
sigma_s = 0.4
rho = 0.40

lambda_ = 1/100
r = 2/100
c =3/100
R = 40/100
N=1
h = 1/12
T= 10

VaR_monte_carlo = MC_VaR(c,T,r,lambda_,R,N,h,sigma_r, sigma_s, rho, alpha=0.99, N_MC=1000,dt=1)
print(f"VaR estim√© par Monte Carlo : {VaR_monte_carlo:.4%}")
```

Lorsque $ \rho $ (le coefficient de corr√©lation entre les taux d'int√©r√™t et le spread de cr√©dit) est positif, une hausse des taux d'int√©r√™t entra√Æne √©galement une hausse du spread de cr√©dit. Cette dynamique amplifie le risque global, car les pertes dues √† la hausse des taux s‚Äôajoutent aux pertes induites par l'√©largissement du spread de cr√©dit. Ainsi, la Value at Risk (VaR) est plus √©lev√©e, refl√©tant l‚Äôaccumulation des risques li√©s aux deux facteurs.  

En revanche, lorsque $ \rho $ est n√©gatif, une hausse des taux d'int√©r√™t tend √† r√©duire le spread de cr√©dit, et inversement. Il se cr√©e alors un effet de compensation : les pertes g√©n√©r√©es par l‚Äô√©volution des taux sont partiellement absorb√©es par les gains r√©sultant de la contraction du spread (ou inversement). C'est le principe de diversification.
Dans ce cas, la VaR est plus faible, car les effets du taux d‚Äôint√©r√™t et du spread de cr√©dit s'annulent en partie, r√©duisant ainsi l'ampleur des pertes potentielles.  

```{python}
# VaR en fonction de rho
from tqdm import tqdm 

rhos = np.linspace(-1,1,100)
VaRs = [MC_VaR(c,T,r,lambda_,R,N,h,sigma_r, sigma_s, rho, alpha=0.99, N_MC=1000,dt=1) for rho in tqdm(rhos)]

plt.plot(rhos,VaRs)
plt.title("VaR en fonction de la corr√©lation")
plt.xlabel("rho")
plt.ylabel("VaR")
plt.grid()
```

#### Estimation de la volatilit√© du spread de cr√©dit

Pour la volatilit√© du spread, nous avons suppos√© que $\sigma_s = 40\%$. Nous allons maintenant estimer cette volatilit√© √† partir des donn√©es de march√©, en utilisant l'historique des spreads de cr√©dit sur une p√©riode de 5 ans, i.e. 11/03/2025 - 11/03/2020, disponible sur ce lien : y revenir.

La volatilit√© du spread est une volatilit√© annualis√©e. De ce fait, la formulation de la volatilit√© empirique, lorsque la fr√©quence est quotidienne, est la suivante :

$$
\sigma_s = \sqrt{\frac{1}{n-1} \sum_{i=1}^{n} (s_i - \bar{s})^2} \times \sqrt{255}
$$

```{python}
cds_df = pd.read_excel("cds.xlsx", skiprows=6)
#date as date
cds_df["Date"] = pd.to_datetime(cds_df["Date"], format="%Y-%m-%d")
cds_df = cds_df.set_index("Date")
cds_df = cds_df.sort_index()

cds_df.head()
```

```{python}
vol_est = np.std(cds_df["PX_LAST"].pct_change())
print(f"Volatilit√© estim√©e sur 5 ans: {vol_est*np.sqrt(255):.4f}")

# volatilit√© sur 1 an
vol_est= np.std(cds_df.loc["2024-03-11":"2025-03-11", "PX_LAST"].pct_change())
print(f"Volatilit√© estim√©e sur 1 an : {vol_est*np.sqrt(255):.4f}")
```

# Risque de mod√®le et risque climatique

En dehors du risque de cr√©dit et du risque de march√©, il existe d'autres types de risques qui peuvent affecter les institutions financi√®res et les march√©s. Deux d‚Äôentre eux sont le risque de mod√®le et le risque climatique.

## Risque de mod√®le

Le risque de mod√®le est le risque associ√© √† une mauvaise utilisation d‚Äôun mod√®le dans le processus de prise de d√©cision. Il peut √™tre caus√© par :
- une incertitude sur les param√®tres,
- une qualit√© insuffisante des donn√©es,
- ou une inad√©quation structurelle du mod√®le par rapport √† la r√©alit√© observ√©e.

Ce risque peut conduire √† des erreurs de pr√©vision, √† des d√©cisions inappropri√©es ou √† des pertes financi√®res. Il est donc essentiel de bien comprendre les hypoth√®ses et limites des mod√®les employ√©s.

C‚Äôest une activit√© o√π l‚Äôintervention humaine reste indispensable : il est n√©cessaire de proc√©der √† des *sanity checks*, du *backtesting*, et de challenger les mod√®les √† l‚Äôaide de versions plus simples (*d√©g√©n√©r√©es*) ou plus riches, afin d‚Äôen comparer les r√©sultats et de mieux cerner leurs faiblesses.

Pour r√©duire le risque de mod√®le, il est courant de mettre en place une fonction ind√©pendante de validation, g√©n√©ralement assur√©e par les √©quipes MRM (Model Risk Management). Ces derni√®res sont charg√©es :
- d‚Äôauditer les mod√®les,
- de mener des tests de robustesse,
- et de recommander des provisions en cas de risque de sur√©valuation des actifs.

Les comp√©tences cl√©s pour cette activit√© incluent :
- les math√©matiques financi√®res,
- la connaissance des march√©s financiers et des mod√®les de risque,
- la programmation et l‚Äôutilisation d‚Äôoutils quantitatifs,
- ainsi que des aptitudes √† la communication, au travail en √©quipe et au raisonnement critique.


## Risque climatique

Le risque climatique d√©signe les impacts potentiels des changements climatiques et des politiques environnementales sur les entreprises et les march√©s financiers. Contrairement aux risques classiques, les trajectoires de r√©f√©rence sont d√©finies par des organismes scientifiques comme le GIEC, ce qui limite l‚Äôappropriation directe des mod√®les par les institutions financi√®res. Il s‚Äôagit donc d‚Äôun domaine o√π le risque de mod√®le est indirect.

Le r√©seau NGFS (Network for Greening the Financial System) a √©t√© mis en place pour aider les r√©gulateurs et les banques centrales √† mieux int√©grer les risques climatiques dans leurs cadres prudentiels.

√Ä l‚Äôheure actuelle, il n‚Äôexiste pas de consensus clair sur la mani√®re d‚Äôint√©grer pleinement le risque climatique dans les mod√®les financiers ; il s‚Äôagit plut√¥t de tentatives progressives d‚Äôadaptation. Le NGFS propose plusieurs sc√©narios climatiques, parmi lesquels :

- Current Policies : continuit√© des politiques actuelles sans nouvel engagement.
- NDC (Nationally Determined Contributions) : politiques actuelles + engagements annonc√©s par les √âtats.
- Disorderly Transition (1.5¬∞C) : les engagements sont mis en ≈ìuvre avec retard ou de fa√ßon d√©sorganis√©e.
- Net Zero / 2¬∞C : sc√©nario optimis√© pour limiter le r√©chauffement √† 2¬∞C ‚Äî le cadre le plus ambitieux et le plus stable.


On distingue g√©n√©ralement deux types de risques climatiques :

### 1. Risque physique

Ce risque est li√© aux cons√©quences directes des changements climatiques sur les infrastructures et l‚Äôenvironnement :
- Risques aigus : √©v√©nements extr√™mes (inondations, s√©cheresses, temp√™tes, etc.).
- Risques chroniques : √©volutions lentes (√©l√©vation du niveau des mers, hausse des temp√©ratures, etc.).

Ces risques peuvent entra√Æner :
- des pertes mat√©rielles,
- des interruptions d‚Äôactivit√©,
- des co√ªts de r√©paration et d‚Äôadaptation.

### 2. Risque de transition

Ce risque est associ√© aux mesures prises pour r√©duire les √©missions de gaz √† effet de serre et passer √† une √©conomie bas carbone. Il peut provoquer :
- des pertes de valeur sur certains actifs,
- des co√ªts de transition √©lev√©s,
- des bouleversements sectoriels et technologiques.

Il comprend deux composantes :
- le risque politique (durcissement r√©glementaire, interdictions, fiscalit√© verte, etc.),
- et le risque/opportunit√© technologique (√©mergence de nouvelles technologies, changement dans les pr√©f√©rences de consommation, etc.).

On peut formuler ce risque comme une relation :

$$
\text{Risque de transition} = \text{Risque politique} - \text{Opportunit√©s technologiques}
$$

Ainsi, une entreprise bien positionn√©e sur les technologies vertes peut compenser tout ou partie du risque politique subi.

- Le risque physique est plus √©lev√© dans les sc√©narios Current Policies, NDC, et Disorderly Transition, car ils impliquent une action climatique insuffisante ou retard√©e.
- √Ä l‚Äôinverse, le risque de transition est plus important dans les sc√©narios ambitieux comme Net Zero, o√π les ajustements politiques et √©conomiques sont rapides et profonds.



