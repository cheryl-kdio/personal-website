{
  "hash": "0499a13bbdf696f591a74521ab251a20",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Asset management : risque de march√©'\nauthor : \n    - Cheryl Kouadio\n    - \"Sous la supervision de : Fai√ßal HIHI\"    \njupyter: python3\ndate: \"2025-01-27\"\n---\n\n\n\n\n\n\n\nLa gestion d'actifs (ou *asset management*) est l‚Äôart de g√©rer un portefeuille d‚Äôactifs financiers. Il s‚Äôagit de g√©rer l‚Äôargent de clients ‚Äî particuliers ou institutionnels ‚Äî avec pour objectif principal de maximiser le rendement tout en minimisant le risque.\n\n**Les √©tapes usuelles de gestion du risque**\n\n1. Identification des risques\n\nOn distingue g√©n√©ralement quatre grandes cat√©gories de risques :\n\n- Risque de march√© : risque de perte en capital d√ª √† la variation des prix des actifs financiers.\n- Risque de cr√©dit : risque de d√©faut d‚Äôun √©metteur, par exemple une entreprise qui ne rembourse pas ses obligations.\n- Risque de liquidit√© : risque de ne pas pouvoir acheter ou vendre rapidement un actif sans influencer son prix de mani√®re significative.\n- Risque op√©rationnel : risque de perte r√©sultant de processus internes d√©faillants, d‚Äôerreurs humaines ou de pannes de syst√®mes.\n\n\n2. M√©triques de risque\n\nCe sont des mesures quantitatives du risque. Parmi les plus utilis√©es : la volatilit√©, qui mesure la variation des rendements d‚Äôun actif par rapport √† sa moyenne; la Value at Risk (VaR), qui mesure la perte maximale anticip√©e sur un portefeuille, avec un certain niveau de confiance $\\alpha$, sur un horizon $T$, la Tracking Error, qui mesure l‚Äô√©cart de performance entre un portefeuille et son indice de r√©f√©rence.\n\n3. Encadrement du risque\n\nIl s‚Äôagit de mettre en place des r√®gles de gestion ou des limites pour √©viter des d√©rives du portefeuille. Cela peut inclure :\n\n- des limites de taille de position,\n- la diversification (√©viter la concentration sur un petit nombre d‚Äôactifs),\n- l‚Äôusage de produits d√©riv√©s (options, futures) pour se couvrir contre les risques identifi√©s.\n\n\n**Constitution du portefeuille**\n\nDans notre √©tude, nous allons constituer un portefeuille de 10 actions choisies dans l‚Äôindice CAC 40, en leur attribuant des poids al√©atoires.\n\nLes actifs retenus sont les suivants :\n- Sanofi  \n- Soci√©t√© G√©n√©rale  \n- Thales  \n- Engie  \n- Capgemini  \n- Carrefour  \n- Orange  \n- Accor  \n- L‚ÄôOr√©al  \n- Cr√©dit Agricole\n\nPuisque nous travaillons avec un portefeuille d‚Äôactions, donc le principal risque est le risque de march√© actions.\nNous allons donc nous int√©resser √† trois indicateurs de risque :\n- la volatilit√© ex-ante,\n- la Value at Risk ex-ante,\n- la Tracking Error ex-ante  \nc‚Äôest-√†-dire des mesures anticip√©es, bas√©es sur la composition actuelle du portefeuille, et non sur des donn√©es historiques (ex-post).\n\n## R√©cup√©ration des donn√©es\n\n::: {#87994148 .cell execution_count=2}\n``` {.python .cell-code}\n#------------------------------------#\n#---------- Package Imports ---------#\n#------------------------------------#\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom datetime import datetime, timedelta\nimport yfinance as yf \nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n```\n:::\n\n\n::: {#da2d6c8e .cell execution_count=3}\n``` {.python .cell-code}\ndef get_data(start_date, end_date, index_ticker, tickers):\n    \"\"\"\n    Extraction de donn√©es de cours d'actions\n    \"\"\"\n    # Extraction des prix historiques des composants\n    data = yf.download(tickers, start=start_date, end=end_date, auto_adjust =True)['Close']\n\n    # Extraction des prix historiques de l'indice CAC 40\n    index = yf.download(index_ticker, start=start_date, end=end_date, auto_adjust =True)['Close']\n\n    return {\n        \"portfolio_data\": data,\n        \"benchmark_data\": index,\n    }\n```\n:::\n\n\n::: {#11a2cb6a .cell execution_count=4}\n``` {.python .cell-code}\nend_date = pd.to_datetime(\"2025-01-27\")\nstart_date = end_date - timedelta(days=2*365)\n\nselected_assets = {\n    \"SAN.PA\" : \"Sanofi\",\n    \"GLE.PA\" : \"Soci√©t√© g√©n√©rale\",\n    \"HO.PA\" : \"Thales\",\n    \"ENGI.PA\" : \"Engie\",\n    \"CAP.PA\" : \"Capgemini\",\n    \"CA.PA\" : \"Carrefour\",\n    \"ORA.PA\" : \"Orange\",\n    \"AC.PA\" : \"Accor\",\n    \"OR.PA\" : \"L'Oreal\",\n    \"ACA.PA\" : \"Cr√©dit agricole\"\n}\n\nindex = \"^FCHI\"\n\nassets_ticker  = list(selected_assets.keys())\n\ndata = get_data(start_date,end_date, index, assets_ticker)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[**********************50%                       ]  5 of 10 completed\r[**********************50%                       ]  5 of 10 completed\r[**********************50%                       ]  5 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[**********************90%******************     ]  9 of 10 completed\r[*********************100%***********************]  10 of 10 completed\n\r[*********************100%***********************]  1 of 1 completed\n```\n:::\n:::\n\n\n::: {#9eac7ea8 .cell execution_count=5}\n``` {.python .cell-code}\nportfolio_data = data[\"portfolio_data\"]\nportfolio_data.tail()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Ticker</th>\n      <th>AC.PA</th>\n      <th>ACA.PA</th>\n      <th>CA.PA</th>\n      <th>CAP.PA</th>\n      <th>ENGI.PA</th>\n      <th>GLE.PA</th>\n      <th>HO.PA</th>\n      <th>OR.PA</th>\n      <th>ORA.PA</th>\n      <th>SAN.PA</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2025-01-20</th>\n      <td>48.259998</td>\n      <td>14.175</td>\n      <td>13.540</td>\n      <td>161.899994</td>\n      <td>15.800</td>\n      <td>29.465000</td>\n      <td>149.600006</td>\n      <td>340.799988</td>\n      <td>10.290</td>\n      <td>98.849998</td>\n    </tr>\n    <tr>\n      <th>2025-01-21</th>\n      <td>48.320000</td>\n      <td>14.170</td>\n      <td>13.470</td>\n      <td>163.399994</td>\n      <td>15.695</td>\n      <td>29.320000</td>\n      <td>151.149994</td>\n      <td>341.200012</td>\n      <td>10.325</td>\n      <td>99.019997</td>\n    </tr>\n    <tr>\n      <th>2025-01-22</th>\n      <td>49.049999</td>\n      <td>14.065</td>\n      <td>13.145</td>\n      <td>162.500000</td>\n      <td>15.525</td>\n      <td>29.320000</td>\n      <td>152.149994</td>\n      <td>349.649994</td>\n      <td>10.230</td>\n      <td>98.849998</td>\n    </tr>\n    <tr>\n      <th>2025-01-23</th>\n      <td>48.580002</td>\n      <td>14.245</td>\n      <td>13.225</td>\n      <td>164.100006</td>\n      <td>15.500</td>\n      <td>29.985001</td>\n      <td>152.850006</td>\n      <td>354.549988</td>\n      <td>10.205</td>\n      <td>99.889999</td>\n    </tr>\n    <tr>\n      <th>2025-01-24</th>\n      <td>48.980000</td>\n      <td>14.225</td>\n      <td>13.300</td>\n      <td>167.500000</td>\n      <td>15.500</td>\n      <td>30.065001</td>\n      <td>152.300003</td>\n      <td>358.450012</td>\n      <td>10.155</td>\n      <td>100.160004</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#80d14631 .cell execution_count=6}\n``` {.python .cell-code}\nbenchmark_data = data[\"benchmark_data\"]\nbenchmark_data.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Ticker</th>\n      <th>^FCHI</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2023-01-30</th>\n      <td>7082.009766</td>\n    </tr>\n    <tr>\n      <th>2023-01-31</th>\n      <td>7082.419922</td>\n    </tr>\n    <tr>\n      <th>2023-02-01</th>\n      <td>7077.109863</td>\n    </tr>\n    <tr>\n      <th>2023-02-02</th>\n      <td>7166.270020</td>\n    </tr>\n    <tr>\n      <th>2023-02-03</th>\n      <td>7233.939941</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#176a2048 .cell execution_count=7}\n``` {.python .cell-code}\n# On attribue des poids √©quitables pour chaque action\nweights_by_asset = {ticker: 1 / len(assets_ticker) for ticker in assets_ticker}\n```\n:::\n\n\nPour connaitre la valeur totale des actifs du portefeuille, nous allons utiliser la notion d'asset under management (AUM) d√©fini comme suit :\n\n$$\nAUM(T_n) = \\sum_{i=1}^{10} \\omega_i \\times P_i(T_n),\n$$\n\no√π $\\omega_i$ est le poids de l'actif $i$ dans le portefeuille et $P_i(T_n)$ est le prix de l'actif $i$ √† la date $T_n$.\n\nPuisque les rendements sont les seuls facteurs de risque de l'AUM, nous allons nous int√©resser √† la variation de l'AUM entre deux dates $T_n$ et $T_{n+1}$, soit :\n\n$$\n\\Delta AUM(T_n, T_{n+1}) = AUM(T_{n+1}) - AUM(T_n) = \\sum_{i=1}^{10} \\omega_i \\times (P_i(T_{n+1}) - P_i(T_n)).\n$$\n\n::: {#4e14a756 .cell execution_count=8}\n``` {.python .cell-code}\naum_series = portfolio_data.apply(lambda row: sum(weights_by_asset[ticker] * row[ticker] for ticker in weights_by_asset), axis=1)\naum_series\n\nAUM = pd.DataFrame(aum_series, columns=[\"AUM\"])\nAUM.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>AUM</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2023-01-30</th>\n      <td>82.874494</td>\n    </tr>\n    <tr>\n      <th>2023-01-31</th>\n      <td>82.658040</td>\n    </tr>\n    <tr>\n      <th>2023-02-01</th>\n      <td>82.421504</td>\n    </tr>\n    <tr>\n      <th>2023-02-02</th>\n      <td>83.536796</td>\n    </tr>\n    <tr>\n      <th>2023-02-03</th>\n      <td>84.256732</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#8b138694 .cell execution_count=9}\n``` {.python .cell-code}\n# --------------------------------------------- #\n# Evolution de la valeur totale du portefeuille\n# ---------------------------------------------- #\n\nplt.figure(figsize=(12, 4))\nplt.plot(AUM, label=\"AUM\")\nplt.title(\"Evolution de l'actif sous gestion\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Valeur\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](TP-1_files/figure-ipynb/cell-9-output-1.png){}\n:::\n:::\n\n\n::: {#b0200ccf .cell execution_count=10}\n``` {.python .cell-code}\n# On s'interesse aux variations/rendements de l'AUM\nAUM[\"Variation\"] = AUM[\"AUM\"].pct_change()\nAUM[\"Variation\"].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nDate\n2023-01-30         NaN\n2023-01-31   -0.002612\n2023-02-01   -0.002862\n2023-02-02    0.013532\n2023-02-03    0.008618\nName: Variation, dtype: float64\n```\n:::\n:::\n\n\n### Estimation de la volatilit√©\n\nPour estimer la volatilit√© du portefeuille, on peut calculer l'√©cart-type des variations de l'AUM.\nOn fait le choix de calculer une volatilit√© ex-ante en se basant sur les variation historiques des prix des actifs avec une profondeur historique de 2 ans. Vu qu'on a une volatilit√© quotidienne, on va l'annualiser en multipliant par $\\sqrt{252}$.\n\nEn g√©n√©ral, sur le march√© action, la volatilit√© quotidienne est environ de 1% et la volatilit√© annuelle est entre 10% et 20%.\n\n::: {#d077e501 .cell execution_count=11}\n``` {.python .cell-code}\n# Calcul de la volatilit√© du portefeuille\nvolatility_portfolio = np.std(AUM[\"Variation\"])\nannualized_volatility_portfolio = volatility_portfolio * np.sqrt(252)\nprint(f\"Volatilit√© de la performance quotidienne : {volatility_portfolio : .2%}\")\nprint(f\"Volatilit√© de la performance annuelle : {annualized_volatility_portfolio : .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVolatilit√© de la performance quotidienne :  0.87%\nVolatilit√© de la performance annuelle :  13.75%\n```\n:::\n:::\n\n\n::: {#57f84fe7 .cell execution_count=12}\n``` {.python .cell-code}\n# Calcul de la volatilit√© de l'indice CAC 40\n\nbenchmark_data[\"Variation\"] = benchmark_data[\"^FCHI\"].pct_change()\nvolatility_benchmark = np.std(benchmark_data[\"Variation\"])\nannualized_volatility_benchmark = volatility_benchmark * np.sqrt(252)\n\nprint(f\"Volatilit√© de l'indice CAC 40 : {volatility_benchmark : .2%}\")\nprint(f\"Volatilit√© de l'indice CAC 40 annuelle : {annualized_volatility_benchmark : .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVolatilit√© de l'indice CAC 40 :  0.84%\nVolatilit√© de l'indice CAC 40 annuelle :  13.37%\n```\n:::\n:::\n\n\nNotre portefeuille nous fournit une volatatilit√© quotidienne sup√©rieure de 3bps √† la volatilit√© du CAC 40. On retrouve sur √† peu pr√®s la m√™me volatilit√© du portefeuille et celle du CAC 40. Il y a donc une certaine homog√©n√©it√© dans le portefeuille que nous avons constitu√©.\n\n> üí° *Note : bp = 0,01%*\n\n### Estimation de la tracking error/erreur de suivi\n\nLa tracking error est une mesure de l'√©cart entre la performance d'un portefeuille et celle de son indice de r√©f√©rence. Elle est calcul√©e comme la volatilit√© de la diff√©rence entre les rendements du portefeuille et de l'indice de r√©f√©rence :\n\n$$\nTE = \\sqrt{Var(R_p - R_b)}\n$$\n\nLa tracking error mesure l'incercitude du portefeuille par rapport √† l'indice de r√©f√©rence, c'est une mesure relative. Plus la tracking error est √©lev√©e, plus le portefeuille est risqu√©. On ne souhaite sous ou sur-performer l'indice de r√©f√©rence. On souhaite suivre v√©ritablement l'indice de r√©f√©rence.\n\nPour l'annualiser, on multiplie par $\\sqrt{252}$ en supposant que les performances quotidiennes sont ind√©pendantes et donc un utilise l'additivit√© des variances.\n\n::: {#a0566c18 .cell execution_count=13}\n``` {.python .cell-code}\nperformance_relative = AUM[\"Variation\"] - benchmark_data[\"Variation\"]\n\nplt.figure(figsize=(12, 4))\nplt.plot(performance_relative, label=\"Performance\")\nplt.title(\"Performance du portefeuille par rapport √† l'indice CAC 40\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Performance\")\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](TP-1_files/figure-ipynb/cell-13-output-1.png){}\n:::\n:::\n\n\n::: {#6cee53cd .cell execution_count=14}\n``` {.python .cell-code}\n# Calcul de la tracking error\n\nTE = np.std(AUM[\"Variation\"] - benchmark_data[\"Variation\"]) \nprint(f\"Tracking error : {TE : .2%}\")\n\nTE_annualized = TE * np.sqrt(252)\nprint(f\"Tracking error annualis√© : {TE_annualized : .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTracking error :  0.51%\nTracking error annualis√© :  8.05%\n```\n:::\n:::\n\n\n### Estimation de la Value-at-Risk (VaR)\n\nLa VaR est une mesure de risque qui donne une estimation de la perte maximale que l'on peut subir avec un certain niveau de confiance $\\alpha$ sur un horizon de temps donn√©. Par exemple, une VaR √† 5% sur 1 jour de 1000 euros signifie que 95% du temps, on ne perdra pas plus de 1000 euros sur un jour.\n\n$$P(\\text{Loss} < \\text{VaR}) = \\alpha.$$\n\nOn peut √©galement raisonner en terme de gain, i.e. Profit and Loss (PnL).\n\n$$P(\\text{PnL} > - \\text{VaR}) = \\alpha.$$\n\nLa VaR peut se calculer suivant trois approches :\n1. Approche historique : On se base sur les rendements pass√©s selon l'horizon fix√© pour estimer la VaR, √† l'aide d'un quantile empirique d'ordre $\\alpha$. Autrement, on peut se baser sur les rendements journaliers et utiliser la m√©thode de rescaling, i.e. $VaR = \\sigma \\times \\Phi^{-1}(\\alpha)$.\n2. Approche param√©trique : On suppose que les rendements suivent une loi normale.\n3. Approche Monte Carlo : On simule les rendements futurs.\n\nPuisqu'on s'int√©resse √† un portefeuille d'actions qui a un indice de r√©f√©rence, on peut √©galement calculer la VaR relative.  La VaR relative suit une philosophie proche du tracking error. Elle se calcule sur les √©carts entre le portefeuille et le benchmark. Elle sert √† mesurer de combien mon portefeuille sous-performe par rapport √† l'indice de r√©f√©rence.\n\n::: {#50c1d163 .cell execution_count=15}\n``` {.python .cell-code}\n# --------------------------------- #\n# VaR historique\n# --------------------------------- #\n\nseuil = 99/100\n\nVaR_hist_portfolio = np.percentile(AUM[\"Variation\"].dropna(), 100*(1- seuil))\nprint(f\"VaR historique sur le portefeuille : {- VaR_hist_portfolio : .2%}\")\nprint(f\"VaR historique sur 20 jours sur le portefeuille : {-VaR_hist_portfolio*np.sqrt(20) : .2%}\")\n\nprint(\"=*=\"*10)\n\nVaR_hist_benchmark = np.percentile(benchmark_data[\"Variation\"].dropna(), 100*(1 - seuil))\nprint(f\"VaR historique sur l'indice CAC 40 : {-VaR_hist_benchmark : .2%}\")\nprint(f\"VaR historique sur 20 jours sur l'indice CAC 40 : {-VaR_hist_benchmark*np.sqrt(20) : .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVaR historique sur le portefeuille :  2.29%\nVaR historique sur 20 jours sur le portefeuille :  10.25%\n=*==*==*==*==*==*==*==*==*==*=\nVaR historique sur l'indice CAC 40 :  2.13%\nVaR historique sur 20 jours sur l'indice CAC 40 :  9.53%\n```\n:::\n:::\n\n\n::: {#1ba91f72 .cell execution_count=16}\n``` {.python .cell-code}\n# ---------------------------------- #\n# VaR param√©trique\n# ---------------------------------- #\n\n# PnL ~ N(mu, sigma) ==> PnL = mu + sigma * Z, o√π Z ~ N(0,1)\n# P(PnL > -VaR) = alpha <=> P(mu + sigma * Z > -VaR) = alpha <=> P(Z < (-VaR - mu) / sigma) = 1 - alpha\n# Donc, -VaR = mu + sigma * quantile(1 - alpha), o√π quantile(1 - alpha) est le quantile de la loi normale standard\n\n\nmu = np.mean(AUM[\"Variation\"].dropna())\nprint(f\"mu sur le portefeuille : {mu : .2}\")\nsigma = np.std(AUM[\"Variation\"].dropna())\nprint(f\"sigma sur le portefeuille : {sigma : .2}\")\n\nVaR_param_portfolio  = -(mu + sigma * norm.ppf(1 - seuil))\n\nprint(f\"VaR param√©trique sur le portefeuille : {VaR_param_portfolio : .2%}\")\nprint(f\"VaR param√©trique sur 20 jours sur le portefeuille : {VaR_param_portfolio * np.sqrt(20): .2%}\")\n\nprint(\"=*=\"*10)\n\nmu = np.mean(benchmark_data[\"Variation\"].dropna())\nprint(f\"mu sur le benchmark: {mu : .2}\")\nsigma = np.std(benchmark_data[\"Variation\"].dropna())\nprint(f\"sigma sur le benchmark : {sigma : .2}\")\n\nVaR_param_benchmark  = -(mu + sigma * norm.ppf(1 - seuil))\n\nprint(f\"VaR param√©trique sur le portefeuille : {VaR_param_benchmark : .2%}\")\nprint(f\"VaR param√©trique sur 20 jours sur le portefeuille : {VaR_param_benchmark * np.sqrt(20): .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmu sur le portefeuille :  0.00022\nsigma sur le portefeuille :  0.0087\nVaR param√©trique sur le portefeuille :  1.99%\nVaR param√©trique sur 20 jours sur le portefeuille :  8.91%\n=*==*==*==*==*==*==*==*==*==*=\nmu sur le benchmark:  0.00026\nsigma sur le benchmark :  0.0084\nVaR param√©trique sur le portefeuille :  1.93%\nVaR param√©trique sur 20 jours sur le portefeuille :  8.65%\n```\n:::\n:::\n\n\n::: {#7574ea75 .cell execution_count=17}\n``` {.python .cell-code}\n# ---------------------------------- #\n# VaR relative\n# ---------------------------------- #\n\nVaR_hist_relative = np.percentile(performance_relative.dropna(), 100*(1- seuil))\nprint(f\"VaR historique relative : {- VaR_hist_relative : .2%}\")\nprint(f\"VaR historique relative sur 20 jours : {-VaR_hist_relative*np.sqrt(20) : .2%}\")\n\nprint(\"=*=\"*10)\n\nmu = np.mean(performance_relative.dropna())\nprint(f\"mu des performances relatives: {mu : .2}\")\nsigma = np.std(performance_relative.dropna())\nprint(f\"sigma des performances relatives : {sigma : .2}\")\n\nVaR_param_relative  = -(mu + sigma * norm.ppf(1 - seuil))\n\nprint(f\"VaR param√©trique relative : {VaR_param_relative : .2%}\")\nprint(f\"VaR param√©trique relative sur 20 jours : {VaR_param_relative * np.sqrt(20): .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVaR historique relative :  1.07%\nVaR historique relative sur 20 jours :  4.80%\n=*==*==*==*==*==*==*==*==*==*=\nmu des performances relatives: -3.5e-05\nsigma des performances relatives :  0.0051\nVaR param√©trique relative :  1.18%\nVaR param√©trique relative sur 20 jours :  5.29%\n```\n:::\n:::\n\n\n# Stress test\n\nPour tester la robustesse du portefeuille, on peut r√©aliser des stress tests. Ces tests permettent d'√©valuer la performance du portefeuille dans des conditions extr√™mes de march√©. Ils sont souvent utilis√©s pour √©valuer la r√©silience d'un portefeuille face √† des √©v√©nements de march√© inattendus ou extr√™mes.\n\nIls sont de deux natures :\n\n1. Stress test historique : On soumet le portefeuille √† une p√©riode historique ou on estime avoir eu une condition extr√™me (Covid, Subprime crisis). On rejoue un sc√©nario qui s'est d√©j√† pass√©.\n\n2. Stress test hypoth√©tique : On joue un sc√©nario qui ne s'est jamais r√©alis√©. Exemple, si les actions chutent de 40%, notre portefeuille d'action chute de 40%.\n\nDans notre cas, nous allons r√©aliser un stress test historique sur la crise de covid. Pour cela, nous allons extraire le prix des actifs du 19 f√©vrier 2020 et du 18 mars 2020. Nous allons ensuite calculer la performance du portefeuille sur cette p√©riode. On va √©galement calculer la performance du CAC 40 sur cette p√©riode pour voir si notre portefeuille a √©t√© plus ou moins r√©silient que le march√©.\n\n::: {#5f38ee90 .cell execution_count=18}\n``` {.python .cell-code}\n# Recuperons les prix des actifs le 19/02/2020 et le 18/03/2020\n# On va valoriser notre portefeuille √† ces dates et calculer les performances\n# A ces dates, le CAC 40 a connu de fortes pertes pendant la COVID-19\n\n\nstart_date = pd.to_datetime(\"19-02-2020\", dayfirst=True)\nend_date = start_date + timedelta(days=1)\n\n\ndata_1902 = get_data(start_date,end_date, index, assets_ticker)\nportfolio_data_1902=data_1902[\"portfolio_data\"]\nbenchmark_data_1902=data_1902['benchmark_data']\n\nstart_date = pd.to_datetime(\"18-03-2020\", dayfirst=True)\nend_date = start_date + timedelta(days=1)\n\n\ndata_1803 = get_data(start_date,end_date, index, assets_ticker)\nportfolio_data_1803=data_1803[\"portfolio_data\"]\nbenchmark_data_1803=data_1803['benchmark_data']\n\n# Concat√©ner les donn√©es des deux dates pour le portefeuille et le benchmark\nportfolio_data_stress = pd.concat([portfolio_data_1902, portfolio_data_1803], ignore_index=False)\nbenchmark_data_stress = pd.concat([benchmark_data_1902, benchmark_data_1803], ignore_index=False)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r[                       0%                       ]\r[**********            20%                       ]  2 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[**********************90%******************     ]  9 of 10 completed\r[*********************100%***********************]  10 of 10 completed\n\r[*********************100%***********************]  1 of 1 completed\n\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[**********************60%****                   ]  6 of 10 completed\r[**********************70%*********              ]  7 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[*********************100%***********************]  10 of 10 completed\n\r[*********************100%***********************]  1 of 1 completed\n```\n:::\n:::\n\n\n::: {#aa59f90e .cell execution_count=19}\n``` {.python .cell-code}\n# Stress test covid sur le portefeuille\naum_series_stress = portfolio_data_stress.apply(lambda row: sum(weights_by_asset[ticker] * row[ticker] for ticker in weights_by_asset), axis=1)\n\nAUM_stress = pd.DataFrame(aum_series_stress, columns=[\"AUM\"])\nAUM_stress[\"Variation\"] = AUM_stress[\"AUM\"].pct_change()\n\nAUM_stress.iloc[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nAUM          43.756625\nVariation    -0.306542\nName: 2020-03-18 00:00:00, dtype: float64\n```\n:::\n:::\n\n\n::: {#8ea0947f .cell execution_count=20}\n``` {.python .cell-code}\nbenchmark_data_stress[\"Variation\"]=benchmark_data_stress[\"^FCHI\"].pct_change()\nbenchmark_data_stress.iloc[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nTicker\n^FCHI        3754.840088\nVariation      -0.385585\nName: 2020-03-18 00:00:00, dtype: float64\n```\n:::\n:::\n\n\nDans ce cas, nous constatons une perte d'environ 30.64% sur le portefeuille et une perte de 38.55% sur le CAC 40. De ce fait, notre portefeuille a √©t√© plus r√©silient que le march√©. En effet, la perte du portefeuille est inf√©rieure √† celle du CAC 40. On peut donc conclure que notre portefeuille permet de mieux resister au stress test covid que le CAC 40.\n\n## Conclusion\n\nLe risque de march√© constitue un enjeu central dans la gestion d‚Äôactifs. Il est inh√©rent √† toute exposition aux march√©s financiers et doit, √† ce titre, √™tre mesur√©, surveill√© et encadr√© avec rigueur afin de pr√©server les int√©r√™ts des investisseurs.\n\nDes outils tels que la volatilit√©, la tracking error et la Value at Risk (VaR) permettent de quantifier l‚Äôincertitude li√©e aux rendements du portefeuille et d‚Äôanticiper les pertes potentielles dans des conditions normales de march√©.\n\nEn compl√©ment, les stress tests jouent un r√¥le fondamental : ils permettent d‚Äô√©valuer la r√©silience du portefeuille face √† des sc√©narios extr√™mes, souvent absents des donn√©es historiques, mais pourtant plausibles dans un contexte de crise.\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /Users/cherylkouadio/Documents/Repositories/personal-website/.venv/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.9.6\n---\n",
    "supporting": [
      "TP-1_files/figure-ipynb"
    ],
    "filters": []
  }
}