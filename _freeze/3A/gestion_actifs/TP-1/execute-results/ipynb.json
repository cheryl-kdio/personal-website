{
  "hash": "0499a13bbdf696f591a74521ab251a20",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Asset management : risque de marché'\nauthor : \n    - Cheryl Kouadio\n    - \"Sous la supervision de : Faiçal HIHI\"    \njupyter: python3\ndate: \"2025-01-27\"\n---\n\n\n\n\n\n\n\nLa gestion d'actifs (ou *asset management*) est l’art de gérer un portefeuille d’actifs financiers. Il s’agit de gérer l’argent de clients — particuliers ou institutionnels — avec pour objectif principal de maximiser le rendement tout en minimisant le risque.\n\n**Les étapes usuelles de gestion du risque**\n\n1. Identification des risques\n\nOn distingue généralement quatre grandes catégories de risques :\n\n- Risque de marché : risque de perte en capital dû à la variation des prix des actifs financiers.\n- Risque de crédit : risque de défaut d’un émetteur, par exemple une entreprise qui ne rembourse pas ses obligations.\n- Risque de liquidité : risque de ne pas pouvoir acheter ou vendre rapidement un actif sans influencer son prix de manière significative.\n- Risque opérationnel : risque de perte résultant de processus internes défaillants, d’erreurs humaines ou de pannes de systèmes.\n\n\n2. Métriques de risque\n\nCe sont des mesures quantitatives du risque. Parmi les plus utilisées : la volatilité, qui mesure la variation des rendements d’un actif par rapport à sa moyenne; la Value at Risk (VaR), qui mesure la perte maximale anticipée sur un portefeuille, avec un certain niveau de confiance $\\alpha$, sur un horizon $T$, la Tracking Error, qui mesure l’écart de performance entre un portefeuille et son indice de référence.\n\n3. Encadrement du risque\n\nIl s’agit de mettre en place des règles de gestion ou des limites pour éviter des dérives du portefeuille. Cela peut inclure :\n\n- des limites de taille de position,\n- la diversification (éviter la concentration sur un petit nombre d’actifs),\n- l’usage de produits dérivés (options, futures) pour se couvrir contre les risques identifiés.\n\n\n**Constitution du portefeuille**\n\nDans notre étude, nous allons constituer un portefeuille de 10 actions choisies dans l’indice CAC 40, en leur attribuant des poids aléatoires.\n\nLes actifs retenus sont les suivants :\n- Sanofi  \n- Société Générale  \n- Thales  \n- Engie  \n- Capgemini  \n- Carrefour  \n- Orange  \n- Accor  \n- L’Oréal  \n- Crédit Agricole\n\nPuisque nous travaillons avec un portefeuille d’actions, donc le principal risque est le risque de marché actions.\nNous allons donc nous intéresser à trois indicateurs de risque :\n- la volatilité ex-ante,\n- la Value at Risk ex-ante,\n- la Tracking Error ex-ante  \nc’est-à-dire des mesures anticipées, basées sur la composition actuelle du portefeuille, et non sur des données historiques (ex-post).\n\n## Récupération des données\n\n::: {#87994148 .cell execution_count=2}\n``` {.python .cell-code}\n#------------------------------------#\n#---------- Package Imports ---------#\n#------------------------------------#\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom datetime import datetime, timedelta\nimport yfinance as yf \nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n```\n:::\n\n\n::: {#da2d6c8e .cell execution_count=3}\n``` {.python .cell-code}\ndef get_data(start_date, end_date, index_ticker, tickers):\n    \"\"\"\n    Extraction de données de cours d'actions\n    \"\"\"\n    # Extraction des prix historiques des composants\n    data = yf.download(tickers, start=start_date, end=end_date, auto_adjust =True)['Close']\n\n    # Extraction des prix historiques de l'indice CAC 40\n    index = yf.download(index_ticker, start=start_date, end=end_date, auto_adjust =True)['Close']\n\n    return {\n        \"portfolio_data\": data,\n        \"benchmark_data\": index,\n    }\n```\n:::\n\n\n::: {#11a2cb6a .cell execution_count=4}\n``` {.python .cell-code}\nend_date = pd.to_datetime(\"2025-01-27\")\nstart_date = end_date - timedelta(days=2*365)\n\nselected_assets = {\n    \"SAN.PA\" : \"Sanofi\",\n    \"GLE.PA\" : \"Société générale\",\n    \"HO.PA\" : \"Thales\",\n    \"ENGI.PA\" : \"Engie\",\n    \"CAP.PA\" : \"Capgemini\",\n    \"CA.PA\" : \"Carrefour\",\n    \"ORA.PA\" : \"Orange\",\n    \"AC.PA\" : \"Accor\",\n    \"OR.PA\" : \"L'Oreal\",\n    \"ACA.PA\" : \"Crédit agricole\"\n}\n\nindex = \"^FCHI\"\n\nassets_ticker  = list(selected_assets.keys())\n\ndata = get_data(start_date,end_date, index, assets_ticker)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[**********************50%                       ]  5 of 10 completed\r[**********************50%                       ]  5 of 10 completed\r[**********************50%                       ]  5 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[**********************90%******************     ]  9 of 10 completed\r[*********************100%***********************]  10 of 10 completed\n\r[*********************100%***********************]  1 of 1 completed\n```\n:::\n:::\n\n\n::: {#9eac7ea8 .cell execution_count=5}\n``` {.python .cell-code}\nportfolio_data = data[\"portfolio_data\"]\nportfolio_data.tail()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Ticker</th>\n      <th>AC.PA</th>\n      <th>ACA.PA</th>\n      <th>CA.PA</th>\n      <th>CAP.PA</th>\n      <th>ENGI.PA</th>\n      <th>GLE.PA</th>\n      <th>HO.PA</th>\n      <th>OR.PA</th>\n      <th>ORA.PA</th>\n      <th>SAN.PA</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2025-01-20</th>\n      <td>48.259998</td>\n      <td>14.175</td>\n      <td>13.540</td>\n      <td>161.899994</td>\n      <td>15.800</td>\n      <td>29.465000</td>\n      <td>149.600006</td>\n      <td>340.799988</td>\n      <td>10.290</td>\n      <td>98.849998</td>\n    </tr>\n    <tr>\n      <th>2025-01-21</th>\n      <td>48.320000</td>\n      <td>14.170</td>\n      <td>13.470</td>\n      <td>163.399994</td>\n      <td>15.695</td>\n      <td>29.320000</td>\n      <td>151.149994</td>\n      <td>341.200012</td>\n      <td>10.325</td>\n      <td>99.019997</td>\n    </tr>\n    <tr>\n      <th>2025-01-22</th>\n      <td>49.049999</td>\n      <td>14.065</td>\n      <td>13.145</td>\n      <td>162.500000</td>\n      <td>15.525</td>\n      <td>29.320000</td>\n      <td>152.149994</td>\n      <td>349.649994</td>\n      <td>10.230</td>\n      <td>98.849998</td>\n    </tr>\n    <tr>\n      <th>2025-01-23</th>\n      <td>48.580002</td>\n      <td>14.245</td>\n      <td>13.225</td>\n      <td>164.100006</td>\n      <td>15.500</td>\n      <td>29.985001</td>\n      <td>152.850006</td>\n      <td>354.549988</td>\n      <td>10.205</td>\n      <td>99.889999</td>\n    </tr>\n    <tr>\n      <th>2025-01-24</th>\n      <td>48.980000</td>\n      <td>14.225</td>\n      <td>13.300</td>\n      <td>167.500000</td>\n      <td>15.500</td>\n      <td>30.065001</td>\n      <td>152.300003</td>\n      <td>358.450012</td>\n      <td>10.155</td>\n      <td>100.160004</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#80d14631 .cell execution_count=6}\n``` {.python .cell-code}\nbenchmark_data = data[\"benchmark_data\"]\nbenchmark_data.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Ticker</th>\n      <th>^FCHI</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2023-01-30</th>\n      <td>7082.009766</td>\n    </tr>\n    <tr>\n      <th>2023-01-31</th>\n      <td>7082.419922</td>\n    </tr>\n    <tr>\n      <th>2023-02-01</th>\n      <td>7077.109863</td>\n    </tr>\n    <tr>\n      <th>2023-02-02</th>\n      <td>7166.270020</td>\n    </tr>\n    <tr>\n      <th>2023-02-03</th>\n      <td>7233.939941</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#176a2048 .cell execution_count=7}\n``` {.python .cell-code}\n# On attribue des poids équitables pour chaque action\nweights_by_asset = {ticker: 1 / len(assets_ticker) for ticker in assets_ticker}\n```\n:::\n\n\nPour connaitre la valeur totale des actifs du portefeuille, nous allons utiliser la notion d'asset under management (AUM) défini comme suit :\n\n$$\nAUM(T_n) = \\sum_{i=1}^{10} \\omega_i \\times P_i(T_n),\n$$\n\noù $\\omega_i$ est le poids de l'actif $i$ dans le portefeuille et $P_i(T_n)$ est le prix de l'actif $i$ à la date $T_n$.\n\nPuisque les rendements sont les seuls facteurs de risque de l'AUM, nous allons nous intéresser à la variation de l'AUM entre deux dates $T_n$ et $T_{n+1}$, soit :\n\n$$\n\\Delta AUM(T_n, T_{n+1}) = AUM(T_{n+1}) - AUM(T_n) = \\sum_{i=1}^{10} \\omega_i \\times (P_i(T_{n+1}) - P_i(T_n)).\n$$\n\n::: {#4e14a756 .cell execution_count=8}\n``` {.python .cell-code}\naum_series = portfolio_data.apply(lambda row: sum(weights_by_asset[ticker] * row[ticker] for ticker in weights_by_asset), axis=1)\naum_series\n\nAUM = pd.DataFrame(aum_series, columns=[\"AUM\"])\nAUM.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>AUM</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2023-01-30</th>\n      <td>82.874494</td>\n    </tr>\n    <tr>\n      <th>2023-01-31</th>\n      <td>82.658040</td>\n    </tr>\n    <tr>\n      <th>2023-02-01</th>\n      <td>82.421504</td>\n    </tr>\n    <tr>\n      <th>2023-02-02</th>\n      <td>83.536796</td>\n    </tr>\n    <tr>\n      <th>2023-02-03</th>\n      <td>84.256732</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#8b138694 .cell execution_count=9}\n``` {.python .cell-code}\n# --------------------------------------------- #\n# Evolution de la valeur totale du portefeuille\n# ---------------------------------------------- #\n\nplt.figure(figsize=(12, 4))\nplt.plot(AUM, label=\"AUM\")\nplt.title(\"Evolution de l'actif sous gestion\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Valeur\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](TP-1_files/figure-ipynb/cell-9-output-1.png){}\n:::\n:::\n\n\n::: {#b0200ccf .cell execution_count=10}\n``` {.python .cell-code}\n# On s'interesse aux variations/rendements de l'AUM\nAUM[\"Variation\"] = AUM[\"AUM\"].pct_change()\nAUM[\"Variation\"].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nDate\n2023-01-30         NaN\n2023-01-31   -0.002612\n2023-02-01   -0.002862\n2023-02-02    0.013532\n2023-02-03    0.008618\nName: Variation, dtype: float64\n```\n:::\n:::\n\n\n### Estimation de la volatilité\n\nPour estimer la volatilité du portefeuille, on peut calculer l'écart-type des variations de l'AUM.\nOn fait le choix de calculer une volatilité ex-ante en se basant sur les variation historiques des prix des actifs avec une profondeur historique de 2 ans. Vu qu'on a une volatilité quotidienne, on va l'annualiser en multipliant par $\\sqrt{252}$.\n\nEn général, sur le marché action, la volatilité quotidienne est environ de 1% et la volatilité annuelle est entre 10% et 20%.\n\n::: {#d077e501 .cell execution_count=11}\n``` {.python .cell-code}\n# Calcul de la volatilité du portefeuille\nvolatility_portfolio = np.std(AUM[\"Variation\"])\nannualized_volatility_portfolio = volatility_portfolio * np.sqrt(252)\nprint(f\"Volatilité de la performance quotidienne : {volatility_portfolio : .2%}\")\nprint(f\"Volatilité de la performance annuelle : {annualized_volatility_portfolio : .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVolatilité de la performance quotidienne :  0.87%\nVolatilité de la performance annuelle :  13.75%\n```\n:::\n:::\n\n\n::: {#57f84fe7 .cell execution_count=12}\n``` {.python .cell-code}\n# Calcul de la volatilité de l'indice CAC 40\n\nbenchmark_data[\"Variation\"] = benchmark_data[\"^FCHI\"].pct_change()\nvolatility_benchmark = np.std(benchmark_data[\"Variation\"])\nannualized_volatility_benchmark = volatility_benchmark * np.sqrt(252)\n\nprint(f\"Volatilité de l'indice CAC 40 : {volatility_benchmark : .2%}\")\nprint(f\"Volatilité de l'indice CAC 40 annuelle : {annualized_volatility_benchmark : .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVolatilité de l'indice CAC 40 :  0.84%\nVolatilité de l'indice CAC 40 annuelle :  13.37%\n```\n:::\n:::\n\n\nNotre portefeuille nous fournit une volatatilité quotidienne supérieure de 3bps à la volatilité du CAC 40. On retrouve sur à peu près la même volatilité du portefeuille et celle du CAC 40. Il y a donc une certaine homogénéité dans le portefeuille que nous avons constitué.\n\n> 💡 *Note : bp = 0,01%*\n\n### Estimation de la tracking error/erreur de suivi\n\nLa tracking error est une mesure de l'écart entre la performance d'un portefeuille et celle de son indice de référence. Elle est calculée comme la volatilité de la différence entre les rendements du portefeuille et de l'indice de référence :\n\n$$\nTE = \\sqrt{Var(R_p - R_b)}\n$$\n\nLa tracking error mesure l'incercitude du portefeuille par rapport à l'indice de référence, c'est une mesure relative. Plus la tracking error est élevée, plus le portefeuille est risqué. On ne souhaite sous ou sur-performer l'indice de référence. On souhaite suivre véritablement l'indice de référence.\n\nPour l'annualiser, on multiplie par $\\sqrt{252}$ en supposant que les performances quotidiennes sont indépendantes et donc un utilise l'additivité des variances.\n\n::: {#a0566c18 .cell execution_count=13}\n``` {.python .cell-code}\nperformance_relative = AUM[\"Variation\"] - benchmark_data[\"Variation\"]\n\nplt.figure(figsize=(12, 4))\nplt.plot(performance_relative, label=\"Performance\")\nplt.title(\"Performance du portefeuille par rapport à l'indice CAC 40\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Performance\")\nplt.legend()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](TP-1_files/figure-ipynb/cell-13-output-1.png){}\n:::\n:::\n\n\n::: {#6cee53cd .cell execution_count=14}\n``` {.python .cell-code}\n# Calcul de la tracking error\n\nTE = np.std(AUM[\"Variation\"] - benchmark_data[\"Variation\"]) \nprint(f\"Tracking error : {TE : .2%}\")\n\nTE_annualized = TE * np.sqrt(252)\nprint(f\"Tracking error annualisé : {TE_annualized : .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTracking error :  0.51%\nTracking error annualisé :  8.05%\n```\n:::\n:::\n\n\n### Estimation de la Value-at-Risk (VaR)\n\nLa VaR est une mesure de risque qui donne une estimation de la perte maximale que l'on peut subir avec un certain niveau de confiance $\\alpha$ sur un horizon de temps donné. Par exemple, une VaR à 5% sur 1 jour de 1000 euros signifie que 95% du temps, on ne perdra pas plus de 1000 euros sur un jour.\n\n$$P(\\text{Loss} < \\text{VaR}) = \\alpha.$$\n\nOn peut également raisonner en terme de gain, i.e. Profit and Loss (PnL).\n\n$$P(\\text{PnL} > - \\text{VaR}) = \\alpha.$$\n\nLa VaR peut se calculer suivant trois approches :\n1. Approche historique : On se base sur les rendements passés selon l'horizon fixé pour estimer la VaR, à l'aide d'un quantile empirique d'ordre $\\alpha$. Autrement, on peut se baser sur les rendements journaliers et utiliser la méthode de rescaling, i.e. $VaR = \\sigma \\times \\Phi^{-1}(\\alpha)$.\n2. Approche paramétrique : On suppose que les rendements suivent une loi normale.\n3. Approche Monte Carlo : On simule les rendements futurs.\n\nPuisqu'on s'intéresse à un portefeuille d'actions qui a un indice de référence, on peut également calculer la VaR relative.  La VaR relative suit une philosophie proche du tracking error. Elle se calcule sur les écarts entre le portefeuille et le benchmark. Elle sert à mesurer de combien mon portefeuille sous-performe par rapport à l'indice de référence.\n\n::: {#50c1d163 .cell execution_count=15}\n``` {.python .cell-code}\n# --------------------------------- #\n# VaR historique\n# --------------------------------- #\n\nseuil = 99/100\n\nVaR_hist_portfolio = np.percentile(AUM[\"Variation\"].dropna(), 100*(1- seuil))\nprint(f\"VaR historique sur le portefeuille : {- VaR_hist_portfolio : .2%}\")\nprint(f\"VaR historique sur 20 jours sur le portefeuille : {-VaR_hist_portfolio*np.sqrt(20) : .2%}\")\n\nprint(\"=*=\"*10)\n\nVaR_hist_benchmark = np.percentile(benchmark_data[\"Variation\"].dropna(), 100*(1 - seuil))\nprint(f\"VaR historique sur l'indice CAC 40 : {-VaR_hist_benchmark : .2%}\")\nprint(f\"VaR historique sur 20 jours sur l'indice CAC 40 : {-VaR_hist_benchmark*np.sqrt(20) : .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVaR historique sur le portefeuille :  2.29%\nVaR historique sur 20 jours sur le portefeuille :  10.25%\n=*==*==*==*==*==*==*==*==*==*=\nVaR historique sur l'indice CAC 40 :  2.13%\nVaR historique sur 20 jours sur l'indice CAC 40 :  9.53%\n```\n:::\n:::\n\n\n::: {#1ba91f72 .cell execution_count=16}\n``` {.python .cell-code}\n# ---------------------------------- #\n# VaR paramétrique\n# ---------------------------------- #\n\n# PnL ~ N(mu, sigma) ==> PnL = mu + sigma * Z, où Z ~ N(0,1)\n# P(PnL > -VaR) = alpha <=> P(mu + sigma * Z > -VaR) = alpha <=> P(Z < (-VaR - mu) / sigma) = 1 - alpha\n# Donc, -VaR = mu + sigma * quantile(1 - alpha), où quantile(1 - alpha) est le quantile de la loi normale standard\n\n\nmu = np.mean(AUM[\"Variation\"].dropna())\nprint(f\"mu sur le portefeuille : {mu : .2}\")\nsigma = np.std(AUM[\"Variation\"].dropna())\nprint(f\"sigma sur le portefeuille : {sigma : .2}\")\n\nVaR_param_portfolio  = -(mu + sigma * norm.ppf(1 - seuil))\n\nprint(f\"VaR paramétrique sur le portefeuille : {VaR_param_portfolio : .2%}\")\nprint(f\"VaR paramétrique sur 20 jours sur le portefeuille : {VaR_param_portfolio * np.sqrt(20): .2%}\")\n\nprint(\"=*=\"*10)\n\nmu = np.mean(benchmark_data[\"Variation\"].dropna())\nprint(f\"mu sur le benchmark: {mu : .2}\")\nsigma = np.std(benchmark_data[\"Variation\"].dropna())\nprint(f\"sigma sur le benchmark : {sigma : .2}\")\n\nVaR_param_benchmark  = -(mu + sigma * norm.ppf(1 - seuil))\n\nprint(f\"VaR paramétrique sur le portefeuille : {VaR_param_benchmark : .2%}\")\nprint(f\"VaR paramétrique sur 20 jours sur le portefeuille : {VaR_param_benchmark * np.sqrt(20): .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmu sur le portefeuille :  0.00022\nsigma sur le portefeuille :  0.0087\nVaR paramétrique sur le portefeuille :  1.99%\nVaR paramétrique sur 20 jours sur le portefeuille :  8.91%\n=*==*==*==*==*==*==*==*==*==*=\nmu sur le benchmark:  0.00026\nsigma sur le benchmark :  0.0084\nVaR paramétrique sur le portefeuille :  1.93%\nVaR paramétrique sur 20 jours sur le portefeuille :  8.65%\n```\n:::\n:::\n\n\n::: {#7574ea75 .cell execution_count=17}\n``` {.python .cell-code}\n# ---------------------------------- #\n# VaR relative\n# ---------------------------------- #\n\nVaR_hist_relative = np.percentile(performance_relative.dropna(), 100*(1- seuil))\nprint(f\"VaR historique relative : {- VaR_hist_relative : .2%}\")\nprint(f\"VaR historique relative sur 20 jours : {-VaR_hist_relative*np.sqrt(20) : .2%}\")\n\nprint(\"=*=\"*10)\n\nmu = np.mean(performance_relative.dropna())\nprint(f\"mu des performances relatives: {mu : .2}\")\nsigma = np.std(performance_relative.dropna())\nprint(f\"sigma des performances relatives : {sigma : .2}\")\n\nVaR_param_relative  = -(mu + sigma * norm.ppf(1 - seuil))\n\nprint(f\"VaR paramétrique relative : {VaR_param_relative : .2%}\")\nprint(f\"VaR paramétrique relative sur 20 jours : {VaR_param_relative * np.sqrt(20): .2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVaR historique relative :  1.07%\nVaR historique relative sur 20 jours :  4.80%\n=*==*==*==*==*==*==*==*==*==*=\nmu des performances relatives: -3.5e-05\nsigma des performances relatives :  0.0051\nVaR paramétrique relative :  1.18%\nVaR paramétrique relative sur 20 jours :  5.29%\n```\n:::\n:::\n\n\n# Stress test\n\nPour tester la robustesse du portefeuille, on peut réaliser des stress tests. Ces tests permettent d'évaluer la performance du portefeuille dans des conditions extrêmes de marché. Ils sont souvent utilisés pour évaluer la résilience d'un portefeuille face à des événements de marché inattendus ou extrêmes.\n\nIls sont de deux natures :\n\n1. Stress test historique : On soumet le portefeuille à une période historique ou on estime avoir eu une condition extrême (Covid, Subprime crisis). On rejoue un scénario qui s'est déjà passé.\n\n2. Stress test hypothétique : On joue un scénario qui ne s'est jamais réalisé. Exemple, si les actions chutent de 40%, notre portefeuille d'action chute de 40%.\n\nDans notre cas, nous allons réaliser un stress test historique sur la crise de covid. Pour cela, nous allons extraire le prix des actifs du 19 février 2020 et du 18 mars 2020. Nous allons ensuite calculer la performance du portefeuille sur cette période. On va également calculer la performance du CAC 40 sur cette période pour voir si notre portefeuille a été plus ou moins résilient que le marché.\n\n::: {#5f38ee90 .cell execution_count=18}\n``` {.python .cell-code}\n# Recuperons les prix des actifs le 19/02/2020 et le 18/03/2020\n# On va valoriser notre portefeuille à ces dates et calculer les performances\n# A ces dates, le CAC 40 a connu de fortes pertes pendant la COVID-19\n\n\nstart_date = pd.to_datetime(\"19-02-2020\", dayfirst=True)\nend_date = start_date + timedelta(days=1)\n\n\ndata_1902 = get_data(start_date,end_date, index, assets_ticker)\nportfolio_data_1902=data_1902[\"portfolio_data\"]\nbenchmark_data_1902=data_1902['benchmark_data']\n\nstart_date = pd.to_datetime(\"18-03-2020\", dayfirst=True)\nend_date = start_date + timedelta(days=1)\n\n\ndata_1803 = get_data(start_date,end_date, index, assets_ticker)\nportfolio_data_1803=data_1803[\"portfolio_data\"]\nbenchmark_data_1803=data_1803['benchmark_data']\n\n# Concaténer les données des deux dates pour le portefeuille et le benchmark\nportfolio_data_stress = pd.concat([portfolio_data_1902, portfolio_data_1803], ignore_index=False)\nbenchmark_data_stress = pd.concat([benchmark_data_1902, benchmark_data_1803], ignore_index=False)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r[                       0%                       ]\r[**********            20%                       ]  2 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[**********************90%******************     ]  9 of 10 completed\r[*********************100%***********************]  10 of 10 completed\n\r[*********************100%***********************]  1 of 1 completed\n\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[**********************60%****                   ]  6 of 10 completed\r[**********************70%*********              ]  7 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[*********************100%***********************]  10 of 10 completed\n\r[*********************100%***********************]  1 of 1 completed\n```\n:::\n:::\n\n\n::: {#aa59f90e .cell execution_count=19}\n``` {.python .cell-code}\n# Stress test covid sur le portefeuille\naum_series_stress = portfolio_data_stress.apply(lambda row: sum(weights_by_asset[ticker] * row[ticker] for ticker in weights_by_asset), axis=1)\n\nAUM_stress = pd.DataFrame(aum_series_stress, columns=[\"AUM\"])\nAUM_stress[\"Variation\"] = AUM_stress[\"AUM\"].pct_change()\n\nAUM_stress.iloc[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nAUM          43.756625\nVariation    -0.306542\nName: 2020-03-18 00:00:00, dtype: float64\n```\n:::\n:::\n\n\n::: {#8ea0947f .cell execution_count=20}\n``` {.python .cell-code}\nbenchmark_data_stress[\"Variation\"]=benchmark_data_stress[\"^FCHI\"].pct_change()\nbenchmark_data_stress.iloc[-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\nTicker\n^FCHI        3754.840088\nVariation      -0.385585\nName: 2020-03-18 00:00:00, dtype: float64\n```\n:::\n:::\n\n\nDans ce cas, nous constatons une perte d'environ 30.64% sur le portefeuille et une perte de 38.55% sur le CAC 40. De ce fait, notre portefeuille a été plus résilient que le marché. En effet, la perte du portefeuille est inférieure à celle du CAC 40. On peut donc conclure que notre portefeuille permet de mieux resister au stress test covid que le CAC 40.\n\n## Conclusion\n\nLe risque de marché constitue un enjeu central dans la gestion d’actifs. Il est inhérent à toute exposition aux marchés financiers et doit, à ce titre, être mesuré, surveillé et encadré avec rigueur afin de préserver les intérêts des investisseurs.\n\nDes outils tels que la volatilité, la tracking error et la Value at Risk (VaR) permettent de quantifier l’incertitude liée aux rendements du portefeuille et d’anticiper les pertes potentielles dans des conditions normales de marché.\n\nEn complément, les stress tests jouent un rôle fondamental : ils permettent d’évaluer la résilience du portefeuille face à des scénarios extrêmes, souvent absents des données historiques, mais pourtant plausibles dans un contexte de crise.\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /Users/cherylkouadio/Documents/Repositories/personal-website/.venv/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.9.6\n---\n",
    "supporting": [
      "TP-1_files/figure-ipynb"
    ],
    "filters": []
  }
}