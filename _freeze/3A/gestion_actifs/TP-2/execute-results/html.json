{
  "hash": "77a4b6e97a3744b314b840a89e3f108c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Asset management : Risques de liquidité (profil d'écoulement / de liquidation d’un portefeuille d’actifs)\"\nauthor : \n    - Cheryl Kouadio\n    - \"Sous la supervision de : Faiçal HIHI\"\njupyter: python3\ndate: \"2025-01-27\"\n---\n\n\nLe risque de liquidité est l’une des quatre grandes catégories de risques auxquels une banque peut être exposée. Il concerne à la fois la liquidité du marché et le risque opérationnel de financement.\n\n- La liquidité du marché fait référence à la capacité d’un investisseur à acheter ou vendre un actif sans en affecter significativement le prix.\n- Le risque opérationnel de financement concerne la capacité à lever des fonds pour financer ses activités.\n\nAinsi, le risque de liquidité est crucial dans la gestion d’un portefeuille, notamment en période de tensions sur les marchés. Si un investisseur doit liquider un actif, il peut être contraint de le vendre à un prix inférieur à sa valeur fondamentale, entraînant ainsi une perte importante.\n\nPour évaluer ce risque, plusieurs indicateurs sont utilisés :\n- le coût de liquidité,\n- le profil d’écoulement (ou profil de liquidation),\n- les gaps de liquidité,\n- les stress tests de liquidité.\n\nDans le cadre de notre étude, nous nous concentrons sur le profil d’écoulement d’un portefeuille composé de 10 actifs, et ce dans les quatre scénarios suivants :\n\n**1. Conditions normales avec déformation :**\nOn considère les volumes moyens de marché, que l’on déforme pour obtenir les quantités effectivement liquidées.  \nLa liquidation débute avec les actifs les plus liquides et se termine avec les plus illiquides.  \nCe processus entraîne une déformation du portefeuille :  \nles premiers investisseurs récupèrent une part plus liquide, tandis que ceux qui restent se retrouvent avec des actifs plus illiquides.\n\n**2. Conditions normales sans déformation :**\nDans ce cas, on cherche à préserver l’équilibre du portefeuille, afin de ne pas pénaliser les investisseurs restants.  \nLa liquidation est répartie uniformément, sans privilégier les actifs les plus liquides.\n\n**3. Conditions stressées avec déformation :**\nLes marchés sont en tension, les volumes chutent drastiquement.  \nOn liquide en priorité les actifs les plus liquides, ce qui accentue l’illiquidité résiduelle du portefeuille.\n\n**4. Conditions stressées sans déformation :**\nMême en période de stress, on cherche à conserver une proportionnalité équitable dans la liquidation, pour éviter une concentration d’actifs illiquides pour les investisseurs restants.\n\n**Étapes de mise en œuvre**\n\nPour chaque scénario, on procède selon les étapes suivantes :\n\n1. Récupération des volumes journaliers sur une période historique de 3 mois, à compter de la date d'aujourd'hui, i.e. le 28 mars 2025.\n2. Calcul de l’ADV sur 3 mois *(Average Daily Volume)* :  \n   $$\n   \\text{ADV}_{T=3M} = \\frac{1}{T} \\sum_{t=1}^{T} V_t,\n   $$\n\n   où $V_t$ est le volume quotidien et $T$ le nombre de jours ouvrés sur les 3 mois.\n\n3. Génération des quantités associées à chaque actif dans le portefeuille.\n4. Pour obtenir un portefeuille ni trop liquide, ni trop illiquide, on applique la formule :\n   $$\n   Q_i = 1.5 \\times \\text{randn}() \\times \\text{ADV}_{3M}^{(i)},\n   $$\n\n   où $\\text{randn}() \\sim \\mathcal{U}[0, 1]$ est une variable aléatoire uniforme, et $\\text{ADV}_{3M}^{(i)}$ l’ADV de l’actif $i$.\n\n5. Calcul du profil de liquidation :\n   Ce profil est construit en fonction de la quantité liquidée chaque jour, en tenant compte de la limite fixée par le volume moyen quotidien de chaque actif.\n\nNous utiliserons un portefeuille fictif de 10 actifs du CAC, à savoir :\n- Sanofi\n- Societe Generale\n- Thales\n- Engie\n- Capgemini\n- Carrefour\n- Orange\n- Accor\n- L'Oreal\n- Crédit agricole\n\n\n### Récupération des données\n\n::: {#891f1d13 .cell execution_count=2}\n``` {.python .cell-code}\n#------------------------------------#\n#---------- Package Imports ---------#\n#------------------------------------#\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\nfrom datetime import datetime, timedelta\nimport yfinance as yf \nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n::: {#83ff6db8 .cell execution_count=3}\n``` {.python .cell-code}\ndef get_data(start_date, end_date, index_ticker, tickers, column=\"Close\"):\n    \"\"\"\n    Extraction de prix de clôture d'actions\n    \"\"\"\n    # Extraction des volumes historiques des composants\n    data = yf.download(tickers, start=start_date, end=end_date, auto_adjust =True)[column]\n\n    # Extraction des volumes historiques de l'indice de reférence\n    index = yf.download(index_ticker, start=start_date, end=end_date, auto_adjust =True)[column]\n\n    return {\n        \"portfolio_data\": data,\n        \"benchmark_data\": index,\n    }\n\nend_date = datetime.now()\nstart_date = end_date - timedelta(days=3*31)\n\nselected_assets = {\n    \"SAN.PA\" : \"Sanofi\",\n    \"GLE.PA\" : \"Société générale\",\n    \"HO.PA\" : \"Thales\",\n    \"ENGI.PA\" : \"Engie\",\n    \"CAP.PA\" : \"Capgemini\",\n    \"CA.PA\" : \"Carrefour\",\n    \"ORA.PA\" : \"Orange\",\n    \"AC.PA\" : \"Accor\",\n    \"OR.PA\" : \"L'Oreal\",\n    \"ACA.PA\" : \"Crédit agricole\",\n    }\n\nindex = \"^FCHI\"\n\nassets_ticker  = list(selected_assets.keys())\n\ndata = get_data(start_date,end_date, index, assets_ticker, column=\"Volume\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[                       0%                       ]\r[**********************80%*************          ]  8 of 10 completed\r[**********************90%******************     ]  9 of 10 completed\r[*********************100%***********************]  10 of 10 completed\n\r[*********************100%***********************]  1 of 1 completed\n```\n:::\n:::\n\n\n::: {#b2223ffc .cell execution_count=4}\n``` {.python .cell-code}\nportfolio_data = data[\"portfolio_data\"]\nportfolio_data.tail()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Ticker</th>\n      <th>AC.PA</th>\n      <th>ACA.PA</th>\n      <th>CA.PA</th>\n      <th>CAP.PA</th>\n      <th>ENGI.PA</th>\n      <th>GLE.PA</th>\n      <th>HO.PA</th>\n      <th>OR.PA</th>\n      <th>ORA.PA</th>\n      <th>SAN.PA</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2025-03-24</th>\n      <td>730382</td>\n      <td>5071701</td>\n      <td>3617903</td>\n      <td>534016</td>\n      <td>5262159</td>\n      <td>2127625</td>\n      <td>371968</td>\n      <td>411521</td>\n      <td>7155931</td>\n      <td>1913393</td>\n    </tr>\n    <tr>\n      <th>2025-03-25</th>\n      <td>562409</td>\n      <td>6524905</td>\n      <td>2255242</td>\n      <td>558654</td>\n      <td>5809793</td>\n      <td>2587026</td>\n      <td>321188</td>\n      <td>353058</td>\n      <td>6643361</td>\n      <td>2079709</td>\n    </tr>\n    <tr>\n      <th>2025-03-26</th>\n      <td>655970</td>\n      <td>4275680</td>\n      <td>1989898</td>\n      <td>570364</td>\n      <td>5282143</td>\n      <td>2412206</td>\n      <td>300659</td>\n      <td>415637</td>\n      <td>7164082</td>\n      <td>2056619</td>\n    </tr>\n    <tr>\n      <th>2025-03-27</th>\n      <td>654205</td>\n      <td>4746013</td>\n      <td>2208609</td>\n      <td>560011</td>\n      <td>6384021</td>\n      <td>3124962</td>\n      <td>317644</td>\n      <td>371877</td>\n      <td>7035243</td>\n      <td>1645925</td>\n    </tr>\n    <tr>\n      <th>2025-03-28</th>\n      <td>973322</td>\n      <td>5792588</td>\n      <td>2671535</td>\n      <td>465431</td>\n      <td>5227544</td>\n      <td>2992606</td>\n      <td>298259</td>\n      <td>418671</td>\n      <td>5970202</td>\n      <td>2141022</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nL'Average Daily Volume (ADV) ou ATV (Average Traded Volume) est un indicateur clé en finance, qui permet de mesurer la liquidité d'un actif. Il est calculé en prenant la moyenne des volumes échangés sur une période donnée. Plus l'ADV est élevé, plus l'actif est liquide, et plus il est facile de le vendre sans impacter le prix du marché.\n\nEn général, c'est l'ADV sur 3 mois qui est utilisé, car il permet de lisser les variations quotidiennes et de donner une vision plus précise de la liquidité d'un actif. \n\n$$ADV = \\frac{\\sum_{i=1}^{n} V_i}{n},$$\n\noù $V_i$ est le volume échangé le jour $i$, et $n$ est le nombre de jours sur la période considérée.\n\nDans le code ci-dessous, nous avons calculé l'ADV sur 3 mois pour chaque actif du portefeuille. Nous constatons que l'actif le plus liquide est **Orange**, avec un ADV d'environ 7,7 million d'actions échangées par jour, tandis que l'actif le moins liquide est **Thales**, avec un ADV d'environ 0,4 million d'actions échangées par jour. De ce fait, durant ces trois mois, l'action Orange a été plus plus liquide que l'action Thales.\n\n::: {#d863552d .cell execution_count=5}\n``` {.python .cell-code}\n#---------------------#\n# Calcul des ADV 3Mois#\n#---------------------#\n\nadv_3m = {ticker : np.mean(portfolio_data[ticker]) for ticker in assets_ticker}\nadv_3m\n\nADV = pd.DataFrame.from_dict(adv_3m, orient='index', columns=['ADV'])\n\n# trier par ADV\nADV.sort_values(by='ADV', ascending=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ADV</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>ORA.PA</th>\n      <td>7.681298e+06</td>\n    </tr>\n    <tr>\n      <th>ACA.PA</th>\n      <td>6.942001e+06</td>\n    </tr>\n    <tr>\n      <th>ENGI.PA</th>\n      <td>6.072020e+06</td>\n    </tr>\n    <tr>\n      <th>GLE.PA</th>\n      <td>3.524290e+06</td>\n    </tr>\n    <tr>\n      <th>CA.PA</th>\n      <td>3.008415e+06</td>\n    </tr>\n    <tr>\n      <th>SAN.PA</th>\n      <td>1.827452e+06</td>\n    </tr>\n    <tr>\n      <th>AC.PA</th>\n      <td>6.501683e+05</td>\n    </tr>\n    <tr>\n      <th>CAP.PA</th>\n      <td>5.081382e+05</td>\n    </tr>\n    <tr>\n      <th>OR.PA</th>\n      <td>4.590586e+05</td>\n    </tr>\n    <tr>\n      <th>HO.PA</th>\n      <td>3.903374e+05</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nPour générer le volume détenu dans notre portefeuille, nous allons utiliser la formule suivante :\n\n$$\n\\text{Volume détenu} = 1.5 \\times \\text{randn()} \\times \\text{ADV 3M}\n$$\n\nCette formule sert à simuler un portefeuille réaliste où les tailles de position sont ajustées à la liquidité de chaque actif, avec une variabilité aléatoire maîtrisée. Elle est simple, mais très utile pour tester des hypothèses de liquidation, de stress, ou de concentration.\n\n::: {#630d1816 .cell execution_count=6}\n``` {.python .cell-code}\n# Génération des quantités\nnp.random.seed(123)\nADV[\"Quantity\"] =  round(1.5 * np.random.rand(len(ADV[\"ADV\"])) * ADV[\"ADV\"])\nADV\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ADV</th>\n      <th>Quantity</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>SAN.PA</th>\n      <td>1.827452e+06</td>\n      <td>1909146.0</td>\n    </tr>\n    <tr>\n      <th>GLE.PA</th>\n      <td>3.524290e+06</td>\n      <td>1512657.0</td>\n    </tr>\n    <tr>\n      <th>HO.PA</th>\n      <td>3.903374e+05</td>\n      <td>132823.0</td>\n    </tr>\n    <tr>\n      <th>ENGI.PA</th>\n      <td>6.072020e+06</td>\n      <td>5021391.0</td>\n    </tr>\n    <tr>\n      <th>CAP.PA</th>\n      <td>5.081382e+05</td>\n      <td>548385.0</td>\n    </tr>\n    <tr>\n      <th>CA.PA</th>\n      <td>3.008415e+06</td>\n      <td>1909319.0</td>\n    </tr>\n    <tr>\n      <th>ORA.PA</th>\n      <td>7.681298e+06</td>\n      <td>11300313.0</td>\n    </tr>\n    <tr>\n      <th>AC.PA</th>\n      <td>6.501683e+05</td>\n      <td>667882.0</td>\n    </tr>\n    <tr>\n      <th>OR.PA</th>\n      <td>4.590586e+05</td>\n      <td>331164.0</td>\n    </tr>\n    <tr>\n      <th>ACA.PA</th>\n      <td>6.942001e+06</td>\n      <td>4083121.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nEn plus de la génération des quantités, il est utile de connaitre la quantité qu'on peut liquider en une journée. En effet, la liquidité d'un actif n'est pas infinie, et il est important de savoir combien on peut vendre sans impacter le prix de manière significative. Pour cela, on utilise la notion de profondeur de marché.\n\nLa profondeur de marché est une quantité à partir de laquelle on ne peut plus vendre sans impacter le prix de façon considérable. On fait l'hypothèse que la profondeur de marché est de 20%. Cela signifie que l'on peut vendre 20% de la quantité sans impacter le prix de façon considérable. Au-delà, le prix est impacté. Cette profondeur est ce qui est observé en pratique dans les carnets d'ordre à tel point que l'AMF le recommande.\n\nA l'aide de cette profondeur de marché, on peut déterminer la quantité liquidable en une journée de la manière suivante :\n$$\nADV 3M \\times 0.2\n$$\n\nLe nombre de jours de liquidation peut être ainsi déterminé :\n$$\n\\frac{\\text{Quantité à liquider}}{\\text{Quantité liquidable en une journée}}\n$$\n\nCe nombre de jours est généralement arrondi à l'entier supérieur et flooré à 1. Plus ce nombre est élevé, plus la liquidation sera longue, et plus le risque de marché sera élevé. En effet, plus la liquidation est longue, plus le risque de marché est élevé, car il y a plus de chances que le prix de l'actif évolue entre le moment où l'investisseur décide de liquider et le moment où la liquidation est terminée.\n\n::: {#45282566 .cell execution_count=7}\n``` {.python .cell-code}\n# Quantité liquidable en 1 jour\nmarket_depth = 20/100\nADV[\"Quantity in 1day\"] = round(ADV[\"ADV\"] * market_depth)\n\n# Calcul du nombre de jours de liquidation\nADV[\"Days of liquidation\"] = ADV[\"Quantity\"]/ADV[\"Quantity in 1day\"]\n\n# floor to 1 and round\nADV[\"Days of liquidation\"] = ADV[\"Days of liquidation\"].apply(lambda x: max(1, round(x)))\nADV\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ADV</th>\n      <th>Quantity</th>\n      <th>Quantity in 1day</th>\n      <th>Days of liquidation</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>SAN.PA</th>\n      <td>1.827452e+06</td>\n      <td>1909146.0</td>\n      <td>365490.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>GLE.PA</th>\n      <td>3.524290e+06</td>\n      <td>1512657.0</td>\n      <td>704858.0</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>HO.PA</th>\n      <td>3.903374e+05</td>\n      <td>132823.0</td>\n      <td>78067.0</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>ENGI.PA</th>\n      <td>6.072020e+06</td>\n      <td>5021391.0</td>\n      <td>1214404.0</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>CAP.PA</th>\n      <td>5.081382e+05</td>\n      <td>548385.0</td>\n      <td>101628.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>CA.PA</th>\n      <td>3.008415e+06</td>\n      <td>1909319.0</td>\n      <td>601683.0</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>ORA.PA</th>\n      <td>7.681298e+06</td>\n      <td>11300313.0</td>\n      <td>1536260.0</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>AC.PA</th>\n      <td>6.501683e+05</td>\n      <td>667882.0</td>\n      <td>130034.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>OR.PA</th>\n      <td>4.590586e+05</td>\n      <td>331164.0</td>\n      <td>91812.0</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>ACA.PA</th>\n      <td>6.942001e+06</td>\n      <td>4083121.0</td>\n      <td>1388400.0</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#169715d6 .cell execution_count=8}\n``` {.python .cell-code}\ntime_elapsed = ADV['Days of liquidation'].max()\nprint(f\"Temps de liquidation du portefeuille : {time_elapsed} jours\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemps de liquidation du portefeuille : 7 jours\n```\n:::\n:::\n\n\nEn calcucant le nombre de jours de liquidation pour chaque actif, on constate que les actifs qui se liquide le plus vite sont les actifs Thales et Société Générale. L'actif qui quant à lui prend le plus de temps à se liquider est l'actif Orange. Cela peut sembler paradoxal, car Orange est l'actif le plus liquide,compte tenu de son ADV. Cependant, cela s'explique par le fait que la quantité à liquider est dépendante de l'ADV, et est de ce fait très importante, et que la profondeur de marché est faible. En effet, même si l'ADV est élevé, la profondeur de marché est faible, ce qui rend la liquidation plus difficile. Un actif avec un petit ADV peut se liquider plus vite simplement parce qu'on lui aura affecté d'un petit coefficient aléatoire, dans la génération des quantités initiales. \n\n> 💡 La liquidité d'un portefeuille dépend de la liquidité intrinsèque des titres et la quantité de titres.\n\n## Présence de déformation\n\nLa déformation dans le cadre de la liquidation d'un portefeuille d'actifs fait référence à la manière dont les quantités liquidées sont réparties entre les différents actifs du portefeuille. En effet, lorsque l'on liquide un portefeuille, on ne peut pas simplement vendre tous les actifs en même temps, compte tenu de leur liquidité respective. La déformation se produit lorsque l'on liquide d'abord les actifs les plus liquides, ce qui entraîne une concentration d'actifs illiquides dans le portefeuille restant. Cela peut avoir un impact significatif sur la valeur du portefeuille et sur le risque de liquidité.\n\n### Sous conditions normales avec déformation (waterfall liquidation)\n\nPour connaître la quantité d'actifs liquidés chaque jour, on fait l'hypothèse que les liquidations futures se feront aux prix observés aujourd'hui. En pratique, ce que l’on peut réellement liquider en une journée correspond à la quantité que l’on peut vendre sans impacter le prix, c’est-à-dire min(quantité liquidable en 1 jour, quantité restant dans le portefeuille).\n\nSur cette base, on peut calculer la valeur de marché du portefeuille, aussi bien au moment initial qu'à chaque jour de liquidation. Cette valeur est généralement exprimée en pourcentage de l'encours total.\n\nOn peut ensuite calculer le cumul des pourcentages liquidés au fil des jours. Cette courbe cumulative représente ce que l’on appelle le profil d’écoulement du portefeuille.\n\nDans le code ci-dessous, nous présentons les quantités liquidées par jour pour chaque actif.\n\n> 💡 Par convention, le jour 0 correspond à la quantité initialement détenue dans le portefeuille, avant toute opération de liquidation.\n\n::: {#dc38ecb7 .cell execution_count=9}\n``` {.python .cell-code}\n#---------------------------#\n# Liquidation du portefeuille\n#---------------------------#\n\nADV[\"Quantity liquidated\"] = 0  # Initialement, rien n'est liquidé\n\n# Au jour 0, on a liquidé 0. La colonne 0 sert de quantité initiale\nquantity_liquidated_per_day = [ADV[\"Quantity\"]]\n\nwhile (ADV[\"Quantity\"] - ADV[\"Quantity liquidated\"]).sum() > 0 : # Tant qu'il y a des liquidations à faire\n    # Calculer la quantité liquide au jour i\n    liquidated_today = np.minimum(ADV[\"Quantity in 1day\"], ADV[\"Quantity\"] - ADV[\"Quantity liquidated\"])\n    \n    # Mettre à jour les quantités liquidées dans le DataFrame\n    ADV[\"Quantity liquidated\"] += liquidated_today\n    \n    # Stocker les quantités liquidées ce jour dans une liste\n    quantity_liquidated_per_day.append(liquidated_today)\n\nliquidation_df = pd.DataFrame(quantity_liquidated_per_day).T\nliquidation_df.columns = [f\"{i}\" for i in range(len(quantity_liquidated_per_day))]\n\nliquidation_df\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n      <th>7</th>\n      <th>8</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>SAN.PA</th>\n      <td>1909146.0</td>\n      <td>365490.0</td>\n      <td>365490.0</td>\n      <td>365490.0</td>\n      <td>365490.0</td>\n      <td>365490.0</td>\n      <td>81696.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>GLE.PA</th>\n      <td>1512657.0</td>\n      <td>704858.0</td>\n      <td>704858.0</td>\n      <td>102941.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>HO.PA</th>\n      <td>132823.0</td>\n      <td>78067.0</td>\n      <td>54756.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>ENGI.PA</th>\n      <td>5021391.0</td>\n      <td>1214404.0</td>\n      <td>1214404.0</td>\n      <td>1214404.0</td>\n      <td>1214404.0</td>\n      <td>163775.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>CAP.PA</th>\n      <td>548385.0</td>\n      <td>101628.0</td>\n      <td>101628.0</td>\n      <td>101628.0</td>\n      <td>101628.0</td>\n      <td>101628.0</td>\n      <td>40245.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>CA.PA</th>\n      <td>1909319.0</td>\n      <td>601683.0</td>\n      <td>601683.0</td>\n      <td>601683.0</td>\n      <td>104270.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>ORA.PA</th>\n      <td>11300313.0</td>\n      <td>1536260.0</td>\n      <td>1536260.0</td>\n      <td>1536260.0</td>\n      <td>1536260.0</td>\n      <td>1536260.0</td>\n      <td>1536260.0</td>\n      <td>1536260.0</td>\n      <td>546493.0</td>\n    </tr>\n    <tr>\n      <th>AC.PA</th>\n      <td>667882.0</td>\n      <td>130034.0</td>\n      <td>130034.0</td>\n      <td>130034.0</td>\n      <td>130034.0</td>\n      <td>130034.0</td>\n      <td>17712.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>OR.PA</th>\n      <td>331164.0</td>\n      <td>91812.0</td>\n      <td>91812.0</td>\n      <td>91812.0</td>\n      <td>55728.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>ACA.PA</th>\n      <td>4083121.0</td>\n      <td>1388400.0</td>\n      <td>1388400.0</td>\n      <td>1306321.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#c8558629 .cell execution_count=10}\n``` {.python .cell-code}\nend_date = datetime.now()\nstart_date = end_date - timedelta(days=5)\nprice_data = get_data(start_date, end_date, index, assets_ticker, column=\"Close\")\n\nprice_data[\"portfolio_data\"].head()\nprice_dict = price_data[\"portfolio_data\"].iloc[-1].to_dict()\n\nprint(\"=\"*50)\nprint(\"Prix des actifs à la date du jour\")\nprint(\"=\"*50)\nfor ticker, price in price_dict.items():\n    print(f\"Le prix de l'actif {selected_assets[ticker]} est de {price} €\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r[                       0%                       ]\r[**********            20%                       ]  2 of 10 completed\r[**************        30%                       ]  3 of 10 completed\r[*******************   40%                       ]  4 of 10 completed\r[**********************50%                       ]  5 of 10 completed\r[**********************50%                       ]  5 of 10 completed\r[**********************50%                       ]  5 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[**********************80%*************          ]  8 of 10 completed\r[*********************100%***********************]  10 of 10 completed\n\r[*********************100%***********************]  1 of 1 completed\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n==================================================\nPrix des actifs à la date du jour\n==================================================\nLe prix de l'actif Accor est de 42.790000915527344 €\nLe prix de l'actif Crédit agricole est de 16.94499969482422 €\nLe prix de l'actif Carrefour est de 13.255000114440918 €\nLe prix de l'actif Capgemini est de 145.3000030517578 €\nLe prix de l'actif Engie est de 18.059999465942383 €\nLe prix de l'actif Société générale est de 42.540000915527344 €\nLe prix de l'actif Thales est de 246.60000610351562 €\nLe prix de l'actif L'Oreal est de 345.1000061035156 €\nLe prix de l'actif Orange est de 11.850000381469727 €\nLe prix de l'actif Sanofi est de 103.4000015258789 €\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n:::\n\n\n::: {#0d9f1a78 .cell execution_count=11}\n``` {.python .cell-code}\n# Valeur liquide des actions par jour de liquidation\nmarket_value =[\n    price_dict[ticker] * liquidation_df.loc[ticker]\n    for ticker in selected_assets\n]\n\nmarket_value = pd.DataFrame(market_value, index=selected_assets, columns=liquidation_df.columns)\nmarket_value\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n      <th>7</th>\n      <th>8</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>SAN.PA</th>\n      <td>1.974057e+08</td>\n      <td>3.779167e+07</td>\n      <td>3.779167e+07</td>\n      <td>3.779167e+07</td>\n      <td>3.779167e+07</td>\n      <td>3.779167e+07</td>\n      <td>8.447367e+06</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>GLE.PA</th>\n      <td>6.434843e+07</td>\n      <td>2.998466e+07</td>\n      <td>2.998466e+07</td>\n      <td>4.379110e+06</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>HO.PA</th>\n      <td>3.275415e+07</td>\n      <td>1.925132e+07</td>\n      <td>1.350283e+07</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>ENGI.PA</th>\n      <td>9.068632e+07</td>\n      <td>2.193214e+07</td>\n      <td>2.193214e+07</td>\n      <td>2.193214e+07</td>\n      <td>2.193214e+07</td>\n      <td>2.957776e+06</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>CAP.PA</th>\n      <td>7.968034e+07</td>\n      <td>1.476655e+07</td>\n      <td>1.476655e+07</td>\n      <td>1.476655e+07</td>\n      <td>1.476655e+07</td>\n      <td>1.476655e+07</td>\n      <td>5.847599e+06</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>CA.PA</th>\n      <td>2.530802e+07</td>\n      <td>7.975308e+06</td>\n      <td>7.975308e+06</td>\n      <td>7.975308e+06</td>\n      <td>1.382099e+06</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>ORA.PA</th>\n      <td>1.339087e+08</td>\n      <td>1.820468e+07</td>\n      <td>1.820468e+07</td>\n      <td>1.820468e+07</td>\n      <td>1.820468e+07</td>\n      <td>1.820468e+07</td>\n      <td>1.820468e+07</td>\n      <td>1.820468e+07</td>\n      <td>6.475942e+06</td>\n    </tr>\n    <tr>\n      <th>AC.PA</th>\n      <td>2.857867e+07</td>\n      <td>5.564155e+06</td>\n      <td>5.564155e+06</td>\n      <td>5.564155e+06</td>\n      <td>5.564155e+06</td>\n      <td>5.564155e+06</td>\n      <td>7.578965e+05</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>OR.PA</th>\n      <td>1.142847e+08</td>\n      <td>3.168432e+07</td>\n      <td>3.168432e+07</td>\n      <td>3.168432e+07</td>\n      <td>1.923173e+07</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n    </tr>\n    <tr>\n      <th>ACA.PA</th>\n      <td>6.918848e+07</td>\n      <td>2.352644e+07</td>\n      <td>2.352644e+07</td>\n      <td>2.213561e+07</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n      <td>0.000000e+00</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#940ab7af .cell execution_count=12}\n``` {.python .cell-code}\n# Calcul de la valeur de marché initiale et totale\nmarket_value_0 = market_value.iloc[:, 0]\ntotal_market_value_0 = market_value_0.sum()\n\nprint(f\" La valeur de marché initiale est de {total_market_value_0}€\")\n\n# Calcul de la valeur de marché cumulée (à partir de la colonne 1)\ncumsum_market_value = market_value.iloc[:, 1:].cumsum(axis=1)\ncumsum_total_market_value = market_value.iloc[:, 1:].sum(axis=0).cumsum()\ncumsum_market_value = pd.concat([pd.DataFrame(0, index=market_value.index, columns=[0]), cumsum_market_value], axis=1)\ncumsum_total_market_value = pd.concat([pd.Series(0, index=[0]), cumsum_total_market_value])\n\nweights = {}\nfor ticker in assets_ticker :\n    weights[ticker] = (market_value_0.loc[ticker] - cumsum_market_value.loc[ticker]) / (total_market_value_0 - cumsum_total_market_value)\n\nweights = pd.DataFrame(weights).T\nweights.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n La valeur de marché initiale est de 836143533.8764086€\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n      <th>7</th>\n      <th>8</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>SAN.PA</th>\n      <td>0.236091</td>\n      <td>0.255194</td>\n      <td>0.289688</td>\n      <td>0.328122</td>\n      <td>0.336963</td>\n      <td>0.145800</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>GLE.PA</th>\n      <td>0.076959</td>\n      <td>0.054941</td>\n      <td>0.010413</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>HO.PA</th>\n      <td>0.039173</td>\n      <td>0.021589</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>ENGI.PA</th>\n      <td>0.108458</td>\n      <td>0.109925</td>\n      <td>0.111341</td>\n      <td>0.097190</td>\n      <td>0.021555</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>CAP.PA</th>\n      <td>0.095295</td>\n      <td>0.103785</td>\n      <td>0.119248</td>\n      <td>0.138154</td>\n      <td>0.150224</td>\n      <td>0.100928</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#6d364d06 .cell execution_count=13}\n``` {.python .cell-code}\nplt.figure(figsize=(12, 6))\n\n# Barplot empilé\nbottom = None\nfor asset in weights.index:\n    plt.bar(\n        pd.to_numeric(weights.columns),  \n        weights.loc[asset],  \n        bottom=bottom,  \n        label=selected_assets[asset]  \n    )\n    bottom = weights.loc[asset] if bottom is None else bottom + weights.loc[asset]\n\nplt.xlabel(\"Days of Liquidation\")\nplt.ylabel(\"Portfolio Weights\")\nplt.title(\"Déformation du portefeuille\")\nplt.xticks(rotation=45)\nplt.legend(title=\"Assets\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", fontsize=8, ncol=2)\nplt.tight_layout()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-13-output-1.png){width=1138 height=566}\n:::\n:::\n\n\nNous constatons avec ce profile de liquidation que les actifs les plus liquides sont liquidés en premier, ce qui entraîne une concentration d'actifs illiquides dans le portefeuille restant. Cela peut avoir un impact significatif sur la valeur du portefeuille et sur le risque de liquidité. En effet, à la fin de la période de liquidation, le portefeuille est uniquement constitué de l'actif Orange, qui nous avons vu précédemment est l'actif le plus illiquide.\n\n<blockquote> \n💡 Bon à savoir : Pour un fonds de droit français réglementé, il est interdit d’investir plus de 5 % du portefeuille dans un seul émetteur.\nCependant, à titre exceptionnel, il est possible d’investir jusqu’à 10 % dans certains titres, à condition que la somme des expositions supérieures à 5 % ne dépasse pas 40 % du portefeuille.\nC’est ce que l’on appelle la règle des 5/10/40, un ratio réglementaire applicable aux OPC (organismes de placement collectif).\nToutes les pertes liées à un non-respect de ce ratio doivent être supportées par la société de gestion. De plus, tout dépassement doit être déclaré à l’AMF.\n</blockquote> \n\n::: {#1e2a7006 .cell execution_count=14}\n``` {.python .cell-code}\n# Valeur liquide du portefeuille\nmarket_value_df = pd.DataFrame()\n\nmarket_value_df[\"market_value\"] = market_value.sum(axis=0)\n\n# Calculer la valeur liquide relative par rapport au jour 0\nmarket_value_df[\"relative value\"] = market_value_df[\"market_value\"] / market_value_df[\"market_value\"].iloc[0]\n\n# Calculer la valeur cumulée liquide relative du portefeuille\nmarket_value_df[\"cumulative value\"] = market_value_df[\"relative value\"].cumsum() - 1\n\nmarket_value_df\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>market_value</th>\n      <th>relative value</th>\n      <th>cumulative value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>8.361435e+08</td>\n      <td>1.000000</td>\n      <td>0.000000</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2.106812e+08</td>\n      <td>0.251968</td>\n      <td>0.251968</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2.049327e+08</td>\n      <td>0.245093</td>\n      <td>0.497061</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1.644335e+08</td>\n      <td>0.196657</td>\n      <td>0.693718</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1.188730e+08</td>\n      <td>0.142168</td>\n      <td>0.835886</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>7.928483e+07</td>\n      <td>0.094822</td>\n      <td>0.930708</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>3.325754e+07</td>\n      <td>0.039775</td>\n      <td>0.970483</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>1.820468e+07</td>\n      <td>0.021772</td>\n      <td>0.992255</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>6.475942e+06</td>\n      <td>0.007745</td>\n      <td>1.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#70980370 .cell execution_count=15}\n``` {.python .cell-code}\nmarket_value_df = market_value_df.iloc[1:]\n\nplt.figure(figsize=(12, 6))\nbars = plt.bar(market_value_df.index, market_value_df[\"cumulative value\"] * 100, color=\"skyblue\")\n\nfor bar in bars:\n    height = bar.get_height()\n    plt.text(\n        bar.get_x() + bar.get_width() / 2,  # Center text\n        height,  # Position slightly above the bar\n        f'{height:.2f}',  # Format with 2 decimal places\n        ha='center',  # Center horizontally\n        va='bottom',  # Position text at the bottom\n        fontsize=10, color=\"black\"\n    )\n\nplt.xlabel(\"Days\")\nplt.ylabel(\"Cumulative Value (%)\")\nplt.title(\"Profil de liquidation du portefeuille\")\nplt.xticks(rotation=45)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-15-output-1.png){width=965 height=526}\n:::\n:::\n\n\nPour voir ce qui arrive au profil d'écoulement lorsque les quantités varient, on va utiliser un facteur de modulation de la quantité. Cela permet de déterminer quelle est la taille cible du portefeuille qui permet d'avoir la liquidité pour un certain niveau en nombre de jours qu'on se fixe. Cet exercice est fait une seule fois à l'initialisation du portefeuille.\n\nPour facilier l'implémentation, nous allons utiliser une fonction `liquidation_profile` qui va nous permettre de calculer le profil d'écoulement du portefeuille, en intégrant le facteur de modulation. Lorsqu'on ne souhaite pas de modulation, on peut simplement passer un facteur de modulation de 1.\n\n::: {#87ca3ef2 .cell execution_count=16}\n``` {.python .cell-code}\ndef waterfall_liquidation(ADV, price_dict, selected_assets, fact_modulation=0.30, plot_graphs=True):\n    \"\"\"\n    Calcule le profil de liquidation et visualise les graphiques des poids et des valeurs cumulées.\n    \"\"\"\n    \n    # Initialisation des quantités liquidées\n    ADV = ADV.copy()\n    ADV[\"Quantity\"] = round(ADV[\"Quantity\"] * fact_modulation)\n\n    ADV[\"Quantity liquidated\"] = 0\n    quantity_liquidated_per_day = [ADV[\"Quantity\"]]\n    \n    time_elapsed = 0 \n    # Calcul des quantités liquidées par jour\n    while (ADV[\"Quantity\"] - ADV[\"Quantity liquidated\"]).sum() > 0 :\n        liquidated_today = np.minimum(\n            ADV[\"Quantity in 1day\"], \n            ADV[\"Quantity\"] - ADV[\"Quantity liquidated\"]\n        )\n        ADV[\"Quantity liquidated\"] += liquidated_today\n        quantity_liquidated_per_day.append(liquidated_today)\n        time_elapsed += 1\n    \n    print(f\"Temps de liquidation du portefeuille : {time_elapsed} jours\")\n    \n    # Conversion des résultats en DataFrame\n    liquidation_df = pd.DataFrame(quantity_liquidated_per_day).T\n    liquidation_df.columns = [f\"{i}\" for i in range(len(quantity_liquidated_per_day))]\n    \n    # Calcul de la valeur liquide par actif et par jour\n    market_value = [\n        price_dict[ticker] * liquidation_df.loc[ticker]\n        for ticker in selected_assets\n    ]\n    market_value = pd.DataFrame(market_value, index=selected_assets, columns=liquidation_df.columns)\n    \n    #---------------------------#\n    # Calcul des poids par jour #\n    #---------------------------#\n\n    market_value_0 = market_value.iloc[:, 0]\n    total_market_value_0 = market_value_0.sum()\n\n    # Calcul de la valeur de marché cumulée (à partir de la colonne 1)\n    cumsum_market_value = market_value.iloc[:, 1:].cumsum(axis=1)\n    cumsum_total_market_value = market_value.iloc[:, 1:].sum(axis=0).cumsum()\n    cumsum_market_value = pd.concat([pd.DataFrame(0, index=market_value.index, columns=[0]), cumsum_market_value], axis=1)\n    cumsum_total_market_value = pd.concat([pd.Series(0, index=[0]), cumsum_total_market_value])\n\n    weights = {}\n    for ticker in selected_assets :\n        weights[ticker] = (market_value_0.loc[ticker] - cumsum_market_value.loc[ticker]) / (total_market_value_0 - cumsum_total_market_value)\n\n    weights = pd.DataFrame(weights).T\n    \n    # Visualisation des poids\n    if plot_graphs:\n        # Initialiser le graphique\n        plt.figure(figsize=(10, 4))\n        \n\n        # Barplot empilé\n        bottom = None\n        for asset in weights.index:\n            plt.bar(\n                pd.to_numeric(weights.columns), \n                weights.loc[asset],  \n                bottom=bottom, \n                label=selected_assets[asset]  \n            )\n            bottom = weights.loc[asset] if bottom is None else bottom + weights.loc[asset]\n\n        plt.xlabel(\"Days of Liquidation\")\n        plt.ylabel(\"Portfolio Weights\")\n        plt.title(\"Déformation du portefeuille\")\n        plt.xticks(rotation=45)\n        plt.legend(title=\"Assets\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", fontsize=8, ncol=2)\n        plt.tight_layout()\n\n        plt.show()\n\n    \n    #---------------------------#\n    #   Profil de liquidation   #\n    #---------------------------#\n\n    market_value_df = pd.DataFrame()\n    market_value_df[\"market_value\"] = market_value.sum(axis=0)\n    \n    # Calcul des valeurs relatives et cumulées\n    market_value_df[\"relative value\"] = market_value_df[\"market_value\"] / market_value_df[\"market_value\"].iloc[0]\n    market_value_df[\"cumulative value\"] = market_value_df[\"relative value\"].cumsum() - 1\n    market_value_df = market_value_df.iloc[1:]  # Retirer le jour 0 pour l'analyse cumulée\n    \n    # Visualisation de la valeur cumulative (barplot)\n    if plot_graphs:\n        plt.figure(figsize=(10, 4))\n        bars = plt.bar(market_value_df.index, market_value_df[\"cumulative value\"] * 100, color=\"skyblue\")\n        for bar in bars:\n            height = bar.get_height()\n            plt.text(\n                bar.get_x() + bar.get_width() / 2,  # Center text\n                height,  # Position slightly above the bar\n                f'{height:.2f}',  # Format with 2 decimal places\n                ha='center',  # Center horizontally\n                va='bottom',  # Position text at the bottom\n                fontsize=10, color=\"black\"\n            )\n        plt.xlabel(\"Days\")\n        plt.ylabel(\"Cumulative Value (%)\")\n        plt.title(\"Profil de liquidation du portefeuille\")\n        plt.xticks(rotation=45)\n        plt.show()\n\n    return market_value_df, market_value, weights\n```\n:::\n\n\nNous constatons qu'en utilisant un facteur de modulation de 0.3, le temps de liquidation est réduit à 3 jours, ce qui est plus rapide que le temps de liquidation initial de 8 jours. Cela montre l'impact significatif de la modulation sur le profil de liquidation du portefeuille.\n\n::: {#d27867a7 .cell execution_count=17}\n``` {.python .cell-code}\nfact_modulation= 0.3\nnew_market_value_df, new_market_value, new_weights = waterfall_liquidation(ADV, price_dict, selected_assets, fact_modulation, plot_graphs=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemps de liquidation du portefeuille : 3 jours\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-17-output-2.png){width=945 height=374}\n:::\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-17-output-3.png){width=816 height=378}\n:::\n:::\n\n\n### Sous conditions stressées avec déformation\n\nPour stresser le portefeuille, à la baisse, on va diviser la profondeur de marché par 2. Cela signifie que l'on peut vendre moins d'actifs sans impacter le prix de manière significative. En conséquence, le temps de liquidation augmente, car il faut plus de temps pour liquider la même quantité d'actifs. Il est également possible d'avoir des conditions stressées à la hausse, où l'on multiplie la profondeur de marché par 2. Cela signifie que l'on peut vendre plus d'actifs sans impacter le prix de manière significative. En conséquence, le temps de liquidation diminue, car il faut moins de temps pour liquider la même quantité d'actifs.\n\nDans notre cas, en stressant le portefeuille à la baisse, nous constatons que le temps de liquidation augmente. On passe de 8 jours de liquidatin à 15 jours.\n\n::: {#44705e69 .cell execution_count=18}\n``` {.python .cell-code}\n#---------------------------#\n# Stress Test\n#---------------------------#\nADV_stressed = ADV.copy()\n\n# Quantité journalière\nmarket_depth = (20/100)/2  # On stresse la liquidité à la baisse\nADV_stressed[\"Quantity in 1day\"] = round(ADV_stressed[\"ADV\"] * market_depth)\n\n# Calcul du nombre de jours de liquidation\nADV_stressed[\"Days of liquidation\"] = ADV_stressed[\"Quantity\"]/ADV_stressed[\"Quantity in 1day\"]\n\n# floor to 1 and round\nADV_stressed[\"Days of liquidation\"] = ADV_stressed[\"Days of liquidation\"].apply(lambda x: max(1, round(x)))\n\ntime_elapsed = ADV_stressed['Days of liquidation'].max()\nprint(f\"Temps de liquidation du portefeuille stressé: {time_elapsed} jours\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemps de liquidation du portefeuille stressé: 15 jours\n```\n:::\n:::\n\n\n::: {#7a8c37d7 .cell execution_count=19}\n``` {.python .cell-code}\nstressed_market_value_df, stressed_market_value, stressed_weights = waterfall_liquidation(ADV=ADV_stressed, price_dict=price_dict, selected_assets=selected_assets, fact_modulation=1, plot_graphs=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemps de liquidation du portefeuille : 15 jours\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-19-output-2.png){width=945 height=374}\n:::\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-19-output-3.png){width=816 height=384}\n:::\n:::\n\n\n## Absence de déformation du portefeuille (pro forma)\n\nNous avons vu dans la section précédente que, lors de la liquidation d’un portefeuille, on a tendance à commencer par les actifs les plus liquides. Cela conduit à une concentration progressive d’actifs illiquides dans le portefeuille résiduel, ce qui peut affecter significativement sa valeur et accroître le risque de liquidité.\n\nDans cette section, nous allons étudier comment éviter cette déformation en procédant à une liquidation proportionnelle : l’objectif est de préserver la répartition initiale du portefeuille tout au long du processus de liquidation.\n\nPour cela, on commence par estimer, comme précédemment, la quantité liquidable en un jour pour chaque titre. Cette estimation permet d’en déduire le pourcentage liquidable quotidien par rapport à la position totale sur chaque actif.\nSi l’on souhaite que tous les titres soient liquidés à la même vitesse, il faut adopter le rythme de liquidation de l’actif le plus lent. Ainsi, on calcule le pourcentage liquidable en un jour pour chaque titre, puis on en retient le minimum. Ce minimum définit alors le pourcentage quotidien de liquidation appliqué à l’ensemble du portefeuille.\nCe procédé allonge la durée totale de liquidation, mais il permet de conserver une structure de portefeuille stable. Néanmoins, une légère déformation peut subsister, notamment en raison des arrondis et des limites pratiques de liquidité sur certains actifs.\n\n::: {#36fe858d .cell execution_count=20}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef pro_forma_liquidation(ADV, price_dict, selected_assets, fact_modulation=0.30, plot_graphs=True):\n    \"\"\"\n    Calcule le profil de liquidation pro forma et visualise les graphiques des poids et des valeurs cumulées.\n    \"\"\"\n\n    ADV = ADV.copy()\n    ADV[\"Quantity\"] = ADV[\"Quantity\"] * fact_modulation\n\n    time_elapsed = ADV['Days of liquidation'].max()\n\n    ADV[\"Quantity liquidated\"] = 0\n    quantity_liquidated_per_day = [ADV[\"Quantity\"]]\n    \n    min_liquidated_today = np.ones(len(ADV[\"Quantity\"]))\n    time_elapsed = 0 \n\n    # Calcul des quantités liquidées par jour\n    while min_liquidated_today.sum() > 0:  \n\n        liquidated_today = np.minimum(\n            ADV[\"Quantity in 1day\"], \n            ADV[\"Quantity\"] - ADV[\"Quantity liquidated\"]\n        ) / ADV[\"Quantity\"]\n        min_liquidated_today = round(np.min(liquidated_today) * ADV[\"Quantity\"])# On liquide à la vitesse de l'actif le moins liquide\n        ADV[\"Quantity liquidated\"] += min_liquidated_today\n        quantity_liquidated_per_day.append(min_liquidated_today)\n        time_elapsed += 1\n    \n    print(f\"Temps de liquidation du portefeuille : {time_elapsed} jours\")\n    \n    # Conversion des résultats en DataFrame\n    liquidation_df = pd.DataFrame(quantity_liquidated_per_day).T\n    liquidation_df.columns = [f\"{i}\" for i in range(len(quantity_liquidated_per_day))]\n    \n    # Calcul de la valeur liquide par actif et par jour\n    market_value = [\n        price_dict[ticker] * liquidation_df.loc[ticker]\n        for ticker in selected_assets\n    ]\n    market_value = pd.DataFrame(market_value, index=selected_assets, columns=liquidation_df.columns)\n    \n    #---------------------------#\n    # Calcul des poids par jour\n    #---------------------------#\n\n    # Calcul de la valeur de marché initiale et totale\n    market_value_0 = market_value.iloc[:, 0]\n    total_market_value_0 = market_value_0.sum()\n\n    # Calcul de la valeur de marché cumulée (à partir de la colonne 1)\n    cumsum_market_value = market_value.iloc[:, 1:].cumsum(axis=1)\n    cumsum_total_market_value = market_value.iloc[:, 1:].sum(axis=0).cumsum()\n    cumsum_market_value = pd.concat([pd.DataFrame(0, index=market_value.index, columns=[0]), cumsum_market_value], axis=1)\n    cumsum_total_market_value = pd.concat([pd.Series(0, index=[0]), cumsum_total_market_value])\n    \n    weights = {}\n    for ticker in selected_assets :\n        weights[ticker] = (market_value_0.loc[ticker] - cumsum_market_value.loc[ticker]) / (total_market_value_0 - cumsum_total_market_value)\n\n    weights = pd.DataFrame(weights).T\n\n    if plot_graphs:\n        plt.figure(figsize=(10, 4))\n\n        bottom = None\n        for asset in weights.index:\n            plt.bar(\n                pd.to_numeric(weights.columns), \n                weights.loc[asset],  \n                bottom=bottom, \n                label=selected_assets[asset]  \n            )\n            bottom = weights.loc[asset] if bottom is None else bottom + weights.loc[asset]\n\n        plt.xlabel(\"Days of Liquidation\")\n        plt.ylabel(\"Portfolio Weights\")\n        plt.title(\"Déformation du portefeuille\")\n        plt.xticks(rotation=45)\n        plt.legend(title=\"Assets\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", fontsize=8, ncol=2)\n        plt.tight_layout()\n        plt.show()\n\n    \n    #---------------------------#\n    #   Profil de liquidation   #\n    #---------------------------#\n    \n    market_value_df = pd.DataFrame()\n    market_value_df[\"market_value\"] = market_value.sum(axis=0)\n    \n    # Calcul des valeurs relatives et cumulées\n    market_value_df[\"relative value\"] = market_value_df[\"market_value\"] / market_value_df[\"market_value\"].iloc[0]\n    market_value_df[\"cumulative value\"] = market_value_df[\"relative value\"].cumsum() - 1\n    market_value_df = market_value_df.iloc[1:]  # Retirer le jour 0 pour l'analyse cumulée\n    \n    # Visualisation de la valeur cumulative (barplot)\n    if plot_graphs:\n        plt.figure(figsize=(10, 4))\n        bars = plt.bar(market_value_df.index, market_value_df[\"cumulative value\"] * 100, color=\"skyblue\")\n        for bar in bars:\n            height = bar.get_height()\n            plt.text(\n                bar.get_x() + bar.get_width() / 2,  # Center text\n                height,  # Position slightly above the bar\n                f'{height:.2f}',  # Format with 2 decimal places\n                ha='center',  # Center horizontally\n                va='bottom',  # Position text at the bottom\n                fontsize=10, color=\"black\"\n            )\n        plt.xlabel(\"Days\")\n        plt.ylabel(\"Cumulative Value (%)\")\n        plt.title(\"Profil de liquidation du portefeuille\")\n        plt.xticks(rotation=45)\n        plt.show()\n    return market_value_df, market_value, weights\n```\n:::\n\n\n### Sous condition normale sans déformation\n\n::: {#919c1745 .cell execution_count=21}\n``` {.python .cell-code}\nproforma_market_value_df, proforma_market_value, proforma_weights = pro_forma_liquidation(ADV=ADV, price_dict=price_dict, selected_assets=selected_assets, fact_modulation=1, plot_graphs=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemps de liquidation du portefeuille : 9 jours\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-21-output-2.png){width=945 height=374}\n:::\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-21-output-3.png){width=816 height=378}\n:::\n:::\n\n\n### Sous conditions stressées sans déformation\n\n::: {#19d50a58 .cell execution_count=22}\n``` {.python .cell-code}\nproforma_s_market_value_df, proforma_s_market_value, proforma_s_weights = pro_forma_liquidation(ADV=ADV_stressed, price_dict=price_dict, selected_assets=selected_assets, fact_modulation=1, plot_graphs=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemps de liquidation du portefeuille : 16 jours\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-22-output-2.png){width=945 height=374}\n:::\n\n::: {.cell-output .cell-output-display}\n![](TP-2_files/figure-html/cell-22-output-3.png){width=816 height=384}\n:::\n:::\n\n\n## Conclusion\n\nLa liquidation d’un portefeuille est un exercice complexe qui nécessite de prendre en compte plusieurs facteurs : la liquidité des actifs, la taille du portefeuille, et les conditions de marché. En utilisant des outils tels que le profil d’écoulement (ou profil de liquidation), les investisseurs peuvent mieux anticiper l’impact potentiel de leurs transactions sur les prix de marché, et ainsi minimiser l’effet de marché.\n\nLe processus de liquidation choisi peut conduire à des rythmes de sortie différents, et il est essentiel d’en tenir compte dans la gestion active du portefeuille.\n\nPour préserver la liquidité d’un portefeuille, notamment en période de tension sur les marchés, plusieurs mécanismes réglementaires et opérationnels existent. Ils visent à protéger les investisseurs restants et à maintenir la qualité du portefeuille. En cas de crise financière ou de forte volatilité, les sociétés de gestion de portefeuille (SGP) peuvent activer ces dispositifs, conformément aux dispositions prévues par la réglementation.\n\nCes mesures permettent d’éviter des ventes forcées d’actifs et de limiter les effets de contagion sur le reste du portefeuille.\n\n**Principaux mécanismes de gestion de la liquidité :**\n\n1. Les gates (plafonnement de rachat)\n\n    Les gates permettent de limiter les rachats quotidiens à un certain pourcentage de l’actif net du fonds. En général, si les rachats dépassent 5 % de l’actif net, la SGP a le droit (mais non l’obligation) de n’honorer que les premiers 5 % et de reporter le reste sur les jours suivants, en fonction des conditions de marché.\n\n    Ce mécanisme permet de réduire l’impact sur les prix de marché, en évitant une vente massive d’actifs en un seul jour.\n    C’est une mesure de protection des porteurs restants, bien que son activation soit souvent perçue comme un signal négatif.\n\n    L’existence du mécanisme des gates doit figurer dans le prospectus du fonds, sauf justification spécifique de la SGP. Il convient de noter que l’activation des gates est optionnelle.\n\n2. **La suspension des souscriptions et des rachats**\n\n    Il s’agit d’une mesure plus radicale, qui consiste à geler temporairement les opérations d’entrée et de sortie du fonds.\n    Elle est utilisée dans des situations exceptionnelles, telles que des crises de marché ou une volatilité extrême, lorsque la valorisation des actifs devient incertaine ou que la liquidité disparaît.\n    Ce mécanisme vise à : préserver l’égalité de traitement entre les investisseurs, éviter des ventes précipitées d’actifs, stabiliser la structure du portefeuille.\n    La suspension doit être justifiée et temporaire, et elle est levée dès que les conditions de marché se normalisent.\n\n3. **Les mécanismes de déformation du portefeuille**\n\n    Il s’agit de mesures proactives consistant à adapter la composition du portefeuille lors des rachats, pour préserver la liquidité résiduelle.\n    Concrètement, la SGP peut choisir de vendre en priorité les actifs les plus liquides, ce qui permet de répondre rapidement aux demandes de rachat sans impacter significativement les prix.\n    Ces mécanismes sont particulièrement utilisés en cas de rachats massifs, pour : limiter l’impact de marché, protéger les investisseurs restants, éviter une déstabilisation du portefeuille.\n\n    Néanmoins, cela entraîne une déformation du portefeuille, c’est-à-dire que les investisseurs qui restent se retrouvent avec une part moins liquide du portefeuille initial. Ce compromis doit être géré avec prudence.\n\n",
    "supporting": [
      "TP-2_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}