{
  "hash": "9aa7bf0b395355e2088a4512928ca0a3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Valorisation d'une obligation\njupyter: python3\nauthor: \"Cheryl Kouadio\"\ndate: \"2025-03-23\"\n---\n\n\n\n\n\n\n\nUne obligation est un titre de cr√©ance √©mis par une entreprise ou une collectivit√© publique afin de financer un projet ou de refinancer une dette. Contrairement aux actions, qui conf√®rent un droit de propri√©t√©, les obligations sont des instruments de dette qui garantissent aux investisseurs des paiements p√©riodiques sous forme d‚Äôint√©r√™ts (coupons) et le remboursement du capital √† une √©ch√©ance d√©termin√©e.\n\nPour la valoriser, comme pour valoriser n'importe quel produit, nous devons faire l'esp√©rance de la valeur actualis√©e des flux futurs sous la probabilit√© risque neutre. En effet, cela permet de se mettre sous la perspective d'un investisseur qui est indiff√©rent au risque et qui ne demande qu'√† √™tre r√©mun√©r√© pour le temps qu'il pr√™te son argent.\n\n$$\nX_{t=0} = \\mathbb{E}^Q \\left[ e^{-r(T-t)} X_T \\right]\n$$\n\nLa valorisation d‚Äôune obligation repose principalement sur deux notions fondamentales :\n\n- Le taux d‚Äôint√©r√™t : il repr√©sente le co√ªt du capital et refl√®te la r√©mun√©ration exig√©e par les investisseurs pour pr√™ter leur argent. Il peut √™tre per√ßu comme le \"loyer\" du capital pr√™t√© ou encore comme la compensation pour le risque associ√© √† l‚Äôinvestissement. Ce taux influence directement la valeur d‚Äôune obligation, car une hausse des taux entra√Æne g√©n√©ralement une baisse du prix des obligations existantes sur le march√© secondaire.\n- Le taux de recouvrement : il correspond au pourcentage du capital que les investisseurs peuvent esp√©rer r√©cup√©rer en cas de d√©faut de l‚Äô√©metteur. Un taux de recouvrement √©lev√© signifie que, m√™me en cas de faillite, les cr√©anciers peuvent r√©cup√©rer une grande partie de leur investissement, tandis qu‚Äôun taux faible sugg√®re un risque de perte plus important. Historiquement, il est fix√© √† $R = 40\\%$.\n\nValoriser une obligation revient donc √† calculer la valeur actualis√©e des flux futurs de paiement. De ce fait, cela revient √† valoriser les coupons, le nominal en cas de non d√©faut de la part de l'√©metteur et le recouvrement en cas de d√©faut de l'√©metteur.\n\n#### a. Valorisation des coupons\nLe coupon est le montant que l‚Äô√©metteur de l‚Äôobligation s‚Äôengage √† verser √† l‚Äôinvestisseur √† intervalles r√©guliers (g√©n√©ralement annuels ou semestriels) jusqu‚Äô√† l‚Äô√©ch√©ance de l‚Äôobligation. Il est exprim√© en pourcentage de la valeur nominale de l‚Äôobligation et peut √™tre fixe ou variable, en fonction des modalit√©s de l‚Äô√©mission.\n\nVu √† $t$, la valeur d'un coupon $c$ qui sera pay√© √† $T_i$ est donn√©e par :\n$$\nN \\mathbb{E}^Q \\left[ e^{-r(Ti-t)} c \\right],\n$$\n\no√π $c$ est le coupon, $r$ est le taux d'int√©r√™t sans risque et $T_i$ est la date de paiement du coupon.\nComme le taux d'int√©r√™t est constant, et le paiement du coupon d√©pend de la probabilit√© de survie de l'√©metteur, on peut r√©√©crire la formule pr√©c√©dente comme suit :\n\n$$\nN e^{-r(Ti-t)} c \\mathbb{P}(\\tau > T_i),\n$$\n\no√π $\\mathbb{P}(\\tau > T_i)$ est la probabilit√© de survie de l'√©metteur √† la date $T_i$.\nLe mod√®le utilis√© pour la probabilit√© de survie est le mod√®le √† intensit√© $\\lambda$ de Jarrow et Turnbull. La probabilit√© de survie est donn√©e par :\n\n$$\n\\mathbb{P}(\\tau > T_i) = e^{-\\int_{t}^{T_i} \\lambda(s) ds} = e^{-\\lambda \\int_{t}^{T_i} ds} = e^{-\\lambda (T_i - t)}.\n$$\n\nDe ce fait, la valorisation du coupon est donn√©e par :\n\n$$\nC_{t} = \\sum_{i=1}^{n} N \\times c \\times e^{-r(T_i-t)} \\times e^{-\\lambda (T_i - t)} = \\sum_{i=1}^{n} N \\times c \\times e^{-(r + \\lambda) \\times (T_i-t)} \\mathbb{1}_{T_i \\geq t}\n$$\n\n\n#### b. Valorisation du nominal\n\nLe nominal est le montant demand√© par l'√©metteur. Sa valorisation est donn√©e par :\n$$\nN_t = N \\times e^{-r(T-t)} \\times e^{-\\lambda (T-t)} \\mathbb{1}_{T \\geq t}\n$$\n\n#### c. Valorisation du recouvrement\n\nPour valoriser le recouvrement, il est n√©cessaire de connaitre la probabilit√© de d√©faut √† l'instant pr√©cis $t$.\n\n$$\n\\begin{aligned}\n\\mathbb{P}(\\tau = u) &= \\mathbb{P}(u \\leq \\tau \\leq u + du) \\\\\n&= \\mathbb{P}(\\tau \\geq u) - \\mathbb{P}(\\tau \\geq u + du)\\\\\n&= - \\frac{ \\mathbb{P}(\\tau \\geq u + du) - \\mathbb{P}(\\tau \\geq u) }{du} du\\\\\n&= -\\frac{\\mathbb{P}(\\tau \\geq u)}{du}du \\\\\n&= \\lambda e^{\\lambda (u-t)} du\n\\end{aligned}\n$$\n\nDe ce fait, la valorisation du recouvrement √† t est :\n$$\n\\begin{aligned}\nR_t &= \\int_t^T N R e^{-rt} \\mathbb{P}(\\tau = u)  \\\\\n&= \\int_t^T N R e^{-rt} \\lambda e^{\\lambda (u-t)} du \\\\\n&= N \\lambda R \\times \\frac{1 - e^{-(r+\\lambda)(T-t)}}{r+\\lambda} \\mathbb{1}_{T \\geq t}\n\\end{aligned}\n$$\n\n\nEn se servant de ces formules, nous pouvons valoriser une obligation de la mani√®re suivante :\n$$\n\\begin{aligned}\nB_t &= C_t + N_t + R_t \\\\\n&= N \\left[ \\sum_{i=1}^{n}  c \\times e^{-(r + \\lambda) \\times (T_i\n-t)} \\mathbb{1}_{T_i \\geq t} + e^{-(r+\\lambda)(T-t)} \\mathbb{1}_{T \\geq t} +  \\lambda R \\times \\frac{1 - e^{-(r+\\lambda)(T-t)}}{r+\\lambda} \\mathbb{1}_{T \\geq t} \\right]\n\\end{aligned}\n\n::: {#8648ee52 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\ndef pricing_bond(t,c,T,r,lambda_,R,N,dt=1):\n    \"\"\"\n    Fonction qui calcule la valeur d'une obligation.\n    t : date actuelle\n    c : coupon\n    T : date de maturit√©\n    r : taux sans risque\n    lambda_ : intensit√© de d√©faut\n    R : taux de recouvrement\n    N : nominal\n    \"\"\"\n\n    ### Valorisation du coupon\n    Ct = N * c * np.sum([np.exp(-(r+lambda_) * (Ti - t)) * (Ti>=t) for Ti in range(dt, T+dt,dt)])\n\n    ### Valorisation du nominal\n    #Proba de survie\n    PS = np.exp( - lambda_ * (T - t))\n    Nt = N * np.exp( -r * (T - t)) * PS * (T>=t)\n\n    ### Valorisation du recouvrement\n    if (r+lambda_)==0 :\n        R_ = T-t\n    else :\n        R_ = N * lambda_ * R * ( 1 - np.exp( - (r+lambda_) * (T-t)))/(r+lambda_)\n    Rt = R_ * (T >= t)\n\n    ### Valorisation de l'obligation\n    Bond = Ct + Nt + Rt\n    return Bond\n```\n:::\n\n\n## I. Valorisation d'une obligation sans risque de d√©faut\n\nNous souhaitons valoriser une obligation sans risque de d√©faut, i.e. $\\lambda = 0$. Pour ce faire, nous fixons les param√®tres suivants :\n- $N = 1$ : le nominal de l'obligation\n- $r = 0.02$ : le taux d'int√©r√™t sans risque\n- $\\lambda = 0$ : l'intensit√© de d√©faut\n- $T = 10$ : l'√©ch√©ance de l'obligation\n- $c = 0.02$ : le coupon annuel\n- $R = 0.4$ : le taux de recouvrement\n- $n = 10$ : le nombre de coupons\n- $t = 0$ : l'instant pr√©sent\n\n::: {#bd00c350 .cell execution_count=3}\n``` {.python .cell-code}\nt=0\nlambda_ = 0\nr = 2/100\nT = 10\nc = 2/100\nR = 40/100\nN=1\n\nB_t = pricing_bond(t=t,c=c,T=T,r=r,lambda_=lambda_,R=R,N=N)\nprint(f\"Prix de l'obligation vu √† t={t} : {B_t}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrix de l'obligation vu √† t=0 : 0.9981933497987289\n```\n:::\n:::\n\n\nEn valorisant l'obligation, nous obtenons un prix de $B_0 \\approx 0.99$. Ce prix est proche du nominal, car les taux de coupons sont √©gaux au taux de march√©. L'obligation est dite au pair (Prix = Nominal) car elle r√©mun√®re au taux de march√©. Si $c > r$, le prix de l'obligation sera sup√©rieur au nominal, car le march√© se serait ru√© sur cette obligation, car elle offrirait plus que le taux de march√©. Sinon, le prix de l'obligation sera inf√©rieur au nominal, car le march√© serait plus r√©ticent.\n\n> üí° La condition dans laquelle l'obligation √©mise vaut 100% du nominal, i.e. au pair, est $c \\approx r + \\lambda$. C'est une obligation qui permet de recouvrir ausi bien le risque de taux ($r$) et le risque de cr√©dit li√© √† l'intensit√© de d√©faut ($\\lambda$).\nPour voir ceci, nous avons impl√©ment√© ci-dessous une fonction qui permet d'extrait le coupon qui permet d'avoir une obligation au pair, avec les m√™mes param√®tres que pr√©c√©demment.\n\n::: {#c4f847ee .cell execution_count=4}\n``` {.python .cell-code}\nt=0\nlambda_ = 1/100\nr = 2/100\nT = 10\nR = 40/100\nN=1\n\n# M√©thode de dichotomie\nfrom scipy.optimize import bisect\n\ndef trouver_coupon(t, T, r, lambda_, R, N, dt=1, tol=1e-6):\n    \"\"\"\n    Trouve le coupon c tel que la valeur de l'obligation soit √©gale √† N.\n    \"\"\"\n    def equation(c):\n        return pricing_bond(t, c, T, r, lambda_, R, N, dt) - N\n    \n    c_opt = bisect(equation, 0, 1, xtol=tol)  # Recherche de c dans l'intervalle [0,1]\n    return c_opt\n\nc_opt = trouver_coupon(t=t, T=T, r=r, lambda_=lambda_, R=R, N=N)\nc_opt\n\nprint(f\"Coupon pour avoir une obligation au pair vu √† t={t} : {c_opt:.2%}\")\nB_t = pricing_bond(t=t,c=c_opt,T=T,r=r,lambda_=lambda_,R=R,N=N)\nprint(f\"Prix de l'obligation vu √† t={t} : {B_t}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoupon pour avoir une obligation au pair vu √† t=0 : 2.64%\nPrix de l'obligation vu √† t=0 : 1.000007783902349\n```\n:::\n:::\n\n\n> De plus, lorsque l'intensit√© de d√©faut est tr√®s grande, on retrouve un prix √† peu pr√®s √©gal au taux de recouvrement. En effet, la probabilit√© de d√©faut est tr√®s grande et donc la probabilit√© qu'il y ait un recouvrement est tr√®s √©lev√©e. (voir exemple ci-dessous)\n\n::: {#c9a8a156 .cell execution_count=5}\n``` {.python .cell-code}\nt=0\nlambda_ = 10\nr = 2/100\nT = 10\nc = 2/100\nR = 40/100\nN=1\n\n\nB_t = pricing_bond(t=t,c=c,T=T,r=r,lambda_=lambda_,R=R,N=N)\nprint(f\"Prix de l'obligation vu √† t={t} : {B_t:.4f}\")\nprint(f\"Taux de recouvrement : {R:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrix de l'obligation vu √† t=0 : 0.3992\nTaux de recouvrement : 0.4000\n```\n:::\n:::\n\n\n## II. Evolution du prix de l'obligation en fonction du temps\n\nDurant la vie de l'obligation, son prix √©volue en fonction des paiements de coupons. √Ä chaque distribution de coupon, une chute du prix de l'obligation est observ√©e. Cette baisse s'explique par le fait que, juste avant le versement, le prix de l'obligation int√®gre la valeur du coupon √† percevoir. Une fois le coupon pay√© aux d√©tenteurs, cette valeur dispara√Æt, entra√Ænant m√©caniquement une diminution du prix de l'obligation, jusqu'√† atteindre le nominal de l'obligation ainsi que le dernier coupon.\n\nToutefois, apr√®s cette chute li√©e au d√©tachement du coupon, la valeur de l'obligation remonte progressivement √† mesure que l'√©ch√©ance du prochain coupon approche. Ce ph√©nom√®ne cr√©e une √©volution en dents de scie, o√π chaque baisse correspond √† un paiement de coupon et chaque remont√©e traduit l‚Äôaccumulation de la valeur du prochain paiement attendu.\n\nBien que ce ph√©nom√®ne soit logique et attendu, il peut √™tre per√ßu n√©gativement car la forme en dents de scie pourrait donner l‚Äôimpression d‚Äôune d√©gradation de la qualit√© de l'obligation. C‚Äôest pourquoi on distingue deux types de prix :\n\n- Le dirty price (prix sale) : il correspond au prix de l'obligation tel qu'affich√© sur le march√©, int√©grant les variations dues aux paiements de coupons.\n- Le clean price (prix net ou pied de coupon) : il correspond au prix de l'obligation \"nettoy√©\" des coupons accumul√©s. Ce prix est obtenu en soustrayant les int√©r√™ts courus au dirty price.\nAinsi, le clean price permet d'√©valuer plus pr√©cis√©ment la valeur intrins√®que de l'obligation sans √™tre pollu√© par les variations dues aux paiements p√©riodiques de coupons. C'est cette valeur qui est g√©n√©ralement utilis√©e pour comparer les obligations entre elles.\n\n\nPour illustrer cette √©volution, nous avons trac√© l'√©volution du prix de l'obligation en fonction du temps. Nous avons fix√© les param√®tres suivants :\n- $N = 1$ : le nominal de l'obligation\n- $r = 0.02$ : le taux d'int√©r√™t sans risque\n- $\\lambda = 0.01$ : l'intensit√© de d√©faut\n- $T = 10$ : l'√©ch√©ance de l'obligation\n- $c = 0.03$ : le coupon annuel\n- $R = 0.4$ : le taux de recouvrement\n- $n = 10$ : le nombre de coupons\n- $t = 0$ : l'instant pr√©sent\n\n::: {#524763a6 .cell execution_count=6}\n``` {.python .cell-code}\ndef myFloor(x):\n    if x==0:\n        return 0\n    if x==np.floor(x):\n        return x-1\n    return np.floor(x)\n\ndef clean_price(t,c,T,r,lambda_,R,N,dt=1):\n    \"\"\"\n    Fonction qui calcule le prix d'une obligation propre.\n    \"\"\"\n    B_t = pricing_bond(t,c,T,r,lambda_,R,N,dt)\n    cc = c * (t - myFloor(t))\n\n    return B_t - cc\n```\n:::\n\n\n::: {#1a5cddfd .cell execution_count=7}\n``` {.python .cell-code}\nt=0\nlambda_ = 1/100\nr = 2/100\nT = 10\nc = 3/100\nR = 40/100\nN=1\n\n\ndirty_prices = []\nclean_prices = []\ngrid_values_c = np.arange(0,T+0.001,0.001)\nfor t in grid_values_c:\n    dirty_prices.append(pricing_bond(t,c,T,r,lambda_,R,N))\n    clean_prices.append(clean_price(t,c,T,r,lambda_,R,N))\n\n\nimport matplotlib.pyplot as plt\nplt.plot(grid_values_c,dirty_prices, label=\"Dirty prices\")\nplt.plot(grid_values_c,clean_prices, label=\"Clean prices\")\nplt.title(\"Dirty prices vs Clean prices\")\nplt.xlabel(\"t\")\nplt.grid()\nplt.legend()\nplt.ylabel(\"Prix de l'obligation\")\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nText(0, 0.5, \"Prix de l'obligation\")\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-7-output-2.png){}\n:::\n:::\n\n\n### a. Cas extr√™mes  \n\nNous avons analys√© l'√©volution du prix de l'obligation dans deux cas extr√™mes afin d'observer l'impact du coupon sur la dynamique des prix. Toutes choses √©gales par ailleurs, nous avons modifi√© le coupon de l'obligation tout en conservant les autres param√®tres constants. Les deux sc√©narios √©tudi√©s sont les suivants :  \n- $ c = 0.01 $ : le coupon est inf√©rieur au taux d'int√©r√™t sans risque.  \n- $ c = 0.05 $ : le coupon est sup√©rieur au taux d'int√©r√™t sans risque.  \n\n#### Cas 1 : $ c = 0.01 $  \n\nLorsque $ c = 1\\% $ et que ce coupon est inf√©rieur au taux d'int√©r√™t sans risque $ r $, la valeur de l'obligation √©volue de mani√®re sp√©cifique :  \n\n- Au d√©part, l'obligation est escompt√©e car le coupon est faible, et les investisseurs anticipent un rendement global inf√©rieur au taux du march√©.  \n- √Ä mesure que l‚Äô√©ch√©ance approche, l'incertitude sur le paiement du coupon dispara√Æt progressivement. Les investisseurs deviennent de plus en plus certains que le paiement aura bien lieu.  \n- √Ä la veille du paiement, l'obligation converge vers un prix proche de $ N + c $ pour le dirty price (car elle inclut le coupon accumul√©) et $ N $ pour le clean price (qui exclut le coupon accumul√©).  \n\nCela signifie que l‚Äôobligation s‚Äôappr√©cie au fil du temps en raison de la certitude croissante du paiement des flux futurs. En d‚Äôautres termes, plus l‚Äô√©ch√©ance se rapproche, plus l'investisseur est assur√© de recevoir ses paiements, ce qui entra√Æne une augmentation progressive de la valeur de l'obligation.  \n\n::: {#e97b44ba .cell execution_count=8}\n``` {.python .cell-code}\nlambda_ = 1/100\nr = 2/100\nT = 10\nc1 = 1/100\nR = 40/100\nN=1\n\nclean_prices1 = []\ndirty_prices1 = []\nfor t in grid_values_c:\n    B_t_dirty = pricing_bond(t=t,c=c1,T=T,r=r,lambda_=lambda_,R=R,N=N)\n    B_t_clean = clean_price(t=t,c=c1,T=T,r=r,lambda_=lambda_,R=R,N=N)\n    clean_prices1.append(B_t_clean)\n    dirty_prices1.append(B_t_dirty)\n\nplt.plot(grid_values_c,clean_prices1, label=\"Clean prices\")\nplt.plot(grid_values_c,dirty_prices1, label=\"Dirty prices\")\nplt.title(\"Clean prices vs Dirty prices\")\nplt.legend()\nplt.grid()\nplt.xlabel(\"t\")\nplt.ylabel(\"Prix de l'obligation\")\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nText(0, 0.5, \"Prix de l'obligation\")\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-8-output-2.png){}\n:::\n:::\n\n\n#### Cas 2 : $ c = 0.05 $  \n\nLorsque $ c = 5\\% $ et que ce coupon est sup√©rieur au taux d'int√©r√™t sans risque $ r $, la dynamique du prix de l'obligation suit une √©volution inverse :  \n\n- Au d√©part, l'obligation est pris√©e au-dessus du nominal (elle se n√©gocie avec une prime). Cela s'explique par le fait que son coupon g√©n√©reux attire les investisseurs, qui consid√®rent que le rendement offert par l'obligation compense largement le risque de cr√©dit et est plus attractif que les opportunit√©s de placement √† taux sans risque.  \n- √Ä mesure que l‚Äô√©ch√©ance approche, la valeur de l'obligation se depr√©cie progressivement. En effet, √† chaque p√©riode, l'investisseur re√ßoit un coupon √©lev√©, mais √† l'√©ch√©ance, il ne r√©cup√®re que le nominal $ N $, ce qui entra√Æne une correction progressive du prix de march√©.  \n- √Ä la veille du remboursement, l'obligation converge vers $ N + c $ pour le dirty price (qui inclut le dernier coupon √† verser) et vers $ N $ pour le clean price.  \n\nAinsi, cette obligation se d√©pr√©cie progressivement jusqu'√† l'√©ch√©ance, car l'effet attractif du coupon √©lev√© s'amenuise √† mesure que le remboursement du capital nominal devient imminent. En d'autres termes, l'obligation part d'une valeur sup√©rieure √† son nominal mais perd progressivement sa prime √† l'approche de l'√©ch√©ance.  \n\n::: {#51d9ba19 .cell execution_count=9}\n``` {.python .cell-code}\nlambda_ = 1/100\nr = 2/100\nT = 10\nc2 = 5/100\nR = 40/100\nN=1\n\nclean_prices2 = []\ndirty_prices2 = []\nfor t in grid_values_c:\n    B_t_dirty = pricing_bond(t=t,c=c2,T=T,r=r,lambda_=lambda_,R=R,N=N)\n    B_t_clean = clean_price(t=t,c=c2,T=T,r=r,lambda_=lambda_,R=R,N=N)\n    clean_prices2.append(B_t_clean)\n    dirty_prices2.append(B_t_dirty)\n\nplt.plot(grid_values_c,clean_prices2, label=\"Clean prices\")\nplt.plot(grid_values_c,dirty_prices2, label=\"Dirty prices\")\nplt.title(\"Clean prices vs Dirty prices\")\nplt.legend()\nplt.grid()\nplt.xlabel(\"t\")\nplt.ylabel(\"Prix de l'obligation\")\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nText(0, 0.5, \"Prix de l'obligation\")\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-9-output-2.png){}\n:::\n:::\n\n\n## III. √âvolution du prix en fonction du taux d'int√©r√™t  \n\nLe prix d'une obligation est une fonction d√©croissante du taux d'int√©r√™t. En effet, plus le taux d'int√©r√™t est √©lev√©, plus la valeur actualis√©e des flux futurs (coupons et remboursement du nominal) est faible, ce qui r√©duit m√©caniquement le prix de l'obligation.  \n\nDans cette analyse, il est inutile de distinguer le dirty price et le clean price, car la diff√©rence entre les deux ne d√©pend pas du taux d'int√©r√™t. De plus, en consid√©rant $t = 0 $, il n'y a pas encore d‚Äôint√©r√™ts courus ($c = 0 $), donc les deux prix co√Øncident.  \n\n### Obligation au pair  \n\nAutour de $c - \\lambda = 2\\% $, le prix de l'obligation est √©gal au nominal. Cela s'explique par le fait que le taux de coupon est exactement √©gal au taux de march√©. L'obligation est alors dite \"au pair\", car les investisseurs n'ont ni prime ni d√©cote √† appliquer sur son prix.  \n\n### Explication de la relation n√©gative entre prix et taux  \n\nLa relation n√©gative entre le prix d'une obligation et le taux d'int√©r√™t s‚Äôexplique par l'effet de substitution avec les nouvelles √©missions obligataires.  \n\n- Lorsque les taux d'int√©r√™t augmentent, de nouvelles obligations sont √©mises avec des coupons plus attractifs.  \n- En cons√©quence, les obligations existantes, qui offrent un coupon fixe plus faible, deviennent moins int√©ressantes pour les investisseurs. Leur prix diminue afin d'ajuster leur rendement effectif au nouveau niveau des taux du march√©.  \n- Inversement, si les taux d'int√©r√™t baissent, les obligations existantes deviennent plus attractives puisqu'elles offrent un coupon plus √©lev√© que les nouvelles √©missions, ce qui entra√Æne une hausse de leur prix sur le march√© secondaire.  \n\nAinsi, la sensibilit√© d'une obligation aux variations de taux d'int√©r√™t, appel√©e \"duration\", est un √©l√©ment cl√© dans l'√©valuation du risque de taux et la gestion de portefeuille obligataire.  \n\n::: {#b2856fd9 .cell execution_count=10}\n``` {.python .cell-code}\nt=0\nlambda_ = 1/100\nT = 10\nc =3/100\nR = 40/100\nN=1\n\ndirty_prices = []\ngrid_values_r = np.arange(0,1,0.001) \nfor r in grid_values_r:\n    B_t_dirty = pricing_bond(t=t,c=c,T=T,r=r,lambda_=lambda_,R=R,N=N)\n    dirty_prices.append(B_t_dirty)\n\nplt.plot(grid_values_r,dirty_prices, label=\"Dirty prices\")\nplt.title(\"Prix de l'obligation en fonction du taux d'int√©r√™t\")\nplt.legend()\nplt.grid()\nplt.xlabel(\"r\")\nplt.ylabel(\"Prix de l'obligation\")\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nText(0, 0.5, \"Prix de l'obligation\")\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-10-output-2.png){}\n:::\n:::\n\n\n## IV. Sensibilit√© du prix de l'obligation au taux d'int√©r√™t / Duration  \n\nLa duration est une mesure de la sensibilit√© du prix d'une obligation aux variations du taux d'int√©r√™t. Elle permet d'√©valuer le risque de taux, c'est-√†-dire l'impact d'une variation des taux sur la valeur de l'obligation.  \n\n> Dans le cas de l'√©volution du prix en fonction du taux d'int√©r√™t, la duration sera donc la pente de la courbe repr√©sentant cette relation.\n\nMath√©matiquement, la duration est d√©finie comme la d√©riv√©e du prix de l'obligation par rapport au taux d'int√©r√™t :  \n\n$$\n\\delta = - \\frac{d B_t}{d r} \\times \\frac{1}{B_t}\n$$\n\nEn utilisant une approximation en diff√©rences finies, on exprime cette d√©riv√©e de la mani√®re suivante :  \n\n$$\n\\frac{d B_t}{d r}  \\approx \\frac{B_t(r+\\Delta r) - B_t(r)}{\\Delta r}\n$$\n\nCette sensibilit√© permet de mesurer la variation du prix de l'obligation en r√©ponse √† une fluctuation du taux d'int√©r√™t, offrant ainsi une √©valuation directe du risque de taux auquel est expos√© l'investisseur. De ce fait, si les taux d'int√©r√™t bouge de $\\Delta r$ = 1%, alors les prix bougeront de -sensibilit√© * $\\Delta r$ .\n\nNous allons impl√©menter ce calcul en Python, en prenant $\\Delta r = 1$ bp (soit $0.0001$ en notation d√©cimale).  \n\n::: {#d5067357 .cell execution_count=11}\n``` {.python .cell-code}\ndef sensivity_to_rate(t,c,T,r,lambda_,R,N,dt=1,dr= 0.01/100):\n    \"\"\"\n    Fonction qui calcule la sensibilit√© d'une obligation √† un taux d'int√©r√™t.\n    \"\"\"\n    B_t = pricing_bond(t,c,T,r,lambda_,R,N,dt)\n    B_t_plus = pricing_bond(t,c,T,r+dr,lambda_,R,N,dt)\n    sensivity = -((B_t_plus - B_t)/dr) * (1/B_t)\n    return sensivity\n```\n:::\n\n\nSi les taux d'int√©r√™t bouge de $\\Delta r$ = 1%, alors les prix bougeront de -sensibilit√© * $\\Delta r$ = -8,64 * 1%.\nLa duration va √™tre souvent proche de la maturit√©.\n\n::: {#dc8bcb98 .cell execution_count=12}\n``` {.python .cell-code}\nt=0\nlambda_ = 1/100\nT = 10\nc =3/100\nR = 40/100\nr = 2/100\nN=1\n\nsensivity_to_rate(t,c,T,r,lambda_,R,N)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nnp.float64(8.643982489102903)\n```\n:::\n:::\n\n\nD'un point de vue graphique, il existe une certaine identit√© entre la maturit√© et la duration, car cette derni√®re peut √™tre interpr√©t√©e comme le barycentre des flux futurs de l'obligation. Plus ces flux sont concentr√©s dans le temps, plus leur pond√©ration affecte la sensibilit√© du prix aux variations des taux d'int√©r√™t.  \n\n#### Lien entre duration et maturit√©  \n\n- La duration est une approximation de la dur√©e d'exposition au risque, ajust√©e en fonction des flux de paiements.  \n- Elle est souvent proche de la maturit√© moyenne de l'obligation, bien que l√©g√®rement inf√©rieure (environ 80% de la maturit√© totale, en fonction des conditions de march√© et du niveau des coupons).  \n\nAinsi, plus l'√©ch√©ance de l'obligation se rapproche, plus la duration tend √† augmenter, car les flux futurs deviennent plus proches dans le temps, rendant l'obligation plus sensible aux variations des taux d'int√©r√™t.\n\n\n>Lorsque la maturit√© de l'obligation approche, sa sensibilit√© au taux d'int√©r√™t tend √† augmenter. En effet, la duration peut √™tre interpr√©t√©e comme une mesure du temps moyen pond√©r√© pendant lequel l‚Äôinvestisseur est expos√© au risque de taux.  \n\n::: {#b7988449 .cell execution_count=13}\n``` {.python .cell-code}\nt=0\nlambda_ = 1/100\nr = 2/100\nc =3/100\nR = 40/100\nN=1\n\ndirty_prices = []\ngrid_values_T = np.arange(1,20,1)\nfor T in grid_values_T:\n    B_t_dirty = sensivity_to_rate(t,c,T,r,lambda_,R,N)\n    dirty_prices.append(B_t_dirty)\n\nplt.plot(grid_values_T,dirty_prices, label=\"Dirty prices\")\nplt.title(\"Sensibilit√© en fonction de la maturit√©\")\nplt.legend()\nplt.grid()\nplt.xlabel(\"T\")\nplt.ylabel(\"Sensibilit√©\")\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nText(0, 0.5, 'Sensibilit√©')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-13-output-2.png){}\n:::\n:::\n\n\n#### Cas particulier : absence de coupon, de taux d'int√©r√™t et de risque de d√©faut  \n\nLorsque le coupon, le taux d'int√©r√™t et l'intensit√© de d√©faut sont nuls, la duration est exactement √©gale √† la maturit√© de l‚Äôobligation. Puisque la duration peut √™tre interpr√©t√©e comme le barycentre des flux futurs de l'obligation, lorsque le coupon et l'intensit√© de d√©faut sont nuls, tous les flux sont concentr√©s √† l'√©ch√©ance, ce qui √©quivaut √† la maturit√© de l'obligation.\n\n::: {#ab32936a .cell execution_count=14}\n``` {.python .cell-code}\nt=0\nc = lambda_ = 10e-6\nR = 40/100\nN=1\n\n\ndirty_prices = []\nfor T in grid_values_T:\n    B_t_dirty = sensivity_to_rate(t,c,T,r,lambda_,R,N)\n    dirty_prices.append(B_t_dirty)\n\nplt.plot(grid_values_T,dirty_prices, label=\"Dirty prices\")\nplt.title(\"Sensibilit√© au taux en fonction de la maturit√©\")\nplt.legend()\nplt.grid()\nplt.xlabel(\"T\")\nplt.ylabel(\"Sensibilit√©\")\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nText(0, 0.5, 'Sensibilit√©')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-14-output-2.png){}\n:::\n:::\n\n\n>Dans le risque de taux, le principale indicateur est la duration.\n\n## V. Mod√®lisation de la VaR\n\n### V.1. Approche par la sensibilit√©\n\nSelon le mod√®le de Hull et White, le taux d'int√©r√™t est mod√©lis√© par :\n\n$$\ndr = \\theta ( \\mu - r) dt + \\sigma dW\n$$\n\no√π $\\theta$ est le coefficient de vitesse de r√©version, $\\mu$ est le taux d'int√©r√™t moyen, $\\sigma$ est la volatilit√© du taux d'int√©r√™t et $dW$ est un mouvement brownien.\nCe mod√®le a la sp√©cifit√© d'√™tre normale. De ce fait, $\\Delta r \\sim N(0, \\sigma^2 \\Delta t)$.\nEn faisant l'approximation de la variation du prix, il est possible d'approcher une VaR par la sensibilit√© :\n\n$$\n\\begin{aligned}\nDuration &= - \\frac{d B_t}{d r} \\times \\frac{1}{B_t} \\\\\n\\frac{d B_t}{B_t} &\\approx - Duration \\times  \\Delta r \\\\\n\\end{aligned}\n$$\n\n::: {#960811ec .cell execution_count=15}\n``` {.python .cell-code}\n# Objectif : √©crire une fonction qui calcule la VaR avec l'approche par duration\nfrom scipy.stats import norm\n\ndef sensitive_VaR(mu,sigma,t,c,T,r,lambda_,R,N,h,dt=1,alpha=0.99) :\n    \"\"\"\n    Calcul de la VaR gaussienne\n    data : les rendements logarithmiques\n    alpha : le niveau de confiance\n    \"\"\"\n    Duration = sensivity_to_rate(t,c,T,r,lambda_,R,N,dt)\n\n    return -(mu + Duration * sigma * np.sqrt(h) * norm.ppf(1 - alpha))\n\n#--------------------------------------\n# Param√®tres du mod√®le de taux\n#---------------------------------------\n\nmu = 0\nh = 1/12\nsigma = 0.01\n\n#--------------------------------------\n# Param√®tres de la valorisation du bond\n#---------------------------------------\n\nt=0\nlambda_ = 1/100\nr = 2/100\nc =3/100\nR = 40/100\nN=1\nT=10\n\nVaR = sensitive_VaR(mu,sigma,t,c,T,r,lambda_,R,N,h=h,dt=1,alpha=0.99)\nprint(f\"VaR estim√© par l'approche par la sensibilit√© : {VaR:.4%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVaR estim√© par l'approche par la sensibilit√© : 5.8049%\n```\n:::\n:::\n\n\nPour cette estimation, nous avions suppos√© que la volatilit√© $\\sigma = 1\\%$. Cependant, cette hypoth√®se pourrait s'√©carter de la r√©alit√©. Pour ce faire, nous allons extraire les donn√©es de taux d'int√©r√™t et calculer la volatilit√© empirique. L'ESTR est un taux un jour collat√©ralis√©,c'est donc quasiment sans risque. Nous allons donc utiliser ce taux pour calculer la volatilit√© empirique.\nPour cela, nous allons utiliser l'historique des taux d'int√©r√™t de l'ESTR sur une p√©riode de 5 ans, i.e. 10/03/2025 - 12/03/2020, disponible sur ce [lien](estr.xlsx).\n\nPour ce faire, nous utilisons la formule suivante :\n\n$$\n\\sigma = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} (r_i - \\bar{r})^2}\n$$\n\nNous constatons que la volatilit√© empirique sur les 5 ans est de 25.45%. Cette valeur est tr√®s √©lev√©e, ce qui signifie que les taux d'int√©r√™t ont connu des variations importantes sur cette p√©riode. Cela peut √™tre du √† la trop grande p√©riode utilis√©e pour la calibration de la volatilit√©. \nPour ce faire, nous avons restreint la p√©riode √† 1 an, i.e. 10/03/2025 - 10/03/2024. La volatilit√© empirique sur cette p√©riode est de 1.04%. Cette valeur est plus coh√©rente avec les taux d'int√©r√™t sans risque.\n\n::: {#3a2f494f .cell execution_count=16}\n``` {.python .cell-code}\nimport pandas as pd\nestr_df = pd.read_excel(\"estr.xlsx\", skiprows=6)\n#date as date\nestr_df[\"Date\"] = pd.to_datetime(estr_df[\"Date\"], format=\"%Y-%m-%d\")\nestr_df = estr_df.set_index(\"Date\")\nestr_df = estr_df.sort_index()\n\nestr_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>PX_LAST</th>\n      <th>CHG_PCT_1D</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2020-03-12</th>\n      <td>-0.540</td>\n      <td>0.5525</td>\n    </tr>\n    <tr>\n      <th>2020-03-13</th>\n      <td>-0.541</td>\n      <td>-0.1852</td>\n    </tr>\n    <tr>\n      <th>2020-03-16</th>\n      <td>-0.536</td>\n      <td>0.9242</td>\n    </tr>\n    <tr>\n      <th>2020-03-17</th>\n      <td>-0.531</td>\n      <td>0.9328</td>\n    </tr>\n    <tr>\n      <th>2020-03-18</th>\n      <td>-0.529</td>\n      <td>0.3766</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#4815ea94 .cell execution_count=17}\n``` {.python .cell-code}\nvol_est = np.std(estr_df[\"PX_LAST\"].pct_change())\nprint(f\"Volatilit√© estim√©e sur 5 ans: {vol_est:.4f}\")\n\n# volatilit√© sur 1 an\nvol_est= np.std(estr_df.loc[\"2024-03-10\":\"2025-03-10\", \"PX_LAST\"].pct_change())\nprint(f\"Volatilit√© estim√©e sur 1 an : {vol_est:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVolatilit√© estim√©e sur 5 ans: 0.2545\nVolatilit√© estim√©e sur 1 an : 0.0104\n```\n:::\n:::\n\n\n### V.2. Approche avec un repricing\n\nCette approche consiste √† revaloriser, sous l'hypoth√®se de normalit√© des taux, l'obligation √† l'instant $t$ pour un taux $r + \\Delta r$ et de calculer la perte maximale possible. De ce fait, elle est plus pr√©cise que l'approche par la sensibilit√©.\n\nPuisque dans le cas d'une obligation, ce dont on veut se pr√©munir c'est de la hausse des taux (puisqu'elle fait baisser le taux d'int√©r√™t). De ce fait, la VaR est donn√©e par :\n\n$$\n\\text{VaR} =  - \\frac{B_t(r + \\Delta r) - B_t }{B_t},\n$$\n\no√π $\\Delta r$ est la variation des taux d'int√©r√™t.\n\nPar d√©finition, la VaR estim√©e sera plus basse que l'autre approche en raison de la convexit√© de l'√©volution du prix de l'obligation en fonction des taux d'int√©r√™t. La Var par l'approche de la sensibilit√©, quant √† elle, suppose une lin√©arit√© de l'√©volution du prix de l'obligation en fonction des taux d'int√©r√™t.\n\n::: {#5186a174 .cell execution_count=18}\n``` {.python .cell-code}\ndef repricing_VaR(mu,sigma,t,c,T,r,lambda_,R,N,h,dt=1,alpha=0.99) :\n    \"\"\"\n    Calcul de la VaR gaussienne\n    data : les rendements logarithmiques\n    alpha : le niveau de confiance\n    \"\"\"\n    delta_r = mu + sigma * np.sqrt(h) * norm.ppf(alpha)\n    P_t = pricing_bond(t,c,T,r,lambda_,R,N,dt)\n    P_t_shocked = pricing_bond(t,c,T,r+delta_r,lambda_,R,N,dt)\n\n    VAR = -( (P_t_shocked - P_t)/P_t)\n\n    return VAR, delta_r\n\n\n#--------------------------------------\n# Param√®tres du mod√®le de taux\n#---------------------------------------\nmu = 0\nh = 1/12\nsigma = 0.01\n\n#--------------------------------------\n# Param√®tres de la valorisation du bond\n#---------------------------------------\nt=0\nlambda_ = 1/100\nr = 2/100\nc =3/100\nR = 40/100\nN=1\nT=10\n\nVaR, delta_r = repricing_VaR(mu,sigma,t,c,T,r,lambda_,R,N,h=h,dt=1,alpha=0.99)\n\nprint(f\"VaR estim√© par l'approche par le r√©ajustement : {VaR:.4%}\")\nprint(f\"Choc de taux : {delta_r:.2%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVaR estim√© par l'approche par le r√©ajustement : 5.6272%\nChoc de taux : 0.67%\n```\n:::\n:::\n\n\n## VI. Focus risque de cr√©dit & contrepartie\n\n### VI.1. Comment estimer l'intensit√© de d√©faut ?\n\nPr√©cedemment, nous avons valoriser l'obligation de la mani√®re suivante :\n\n$$\n\\begin{aligned}\nB_t &= C_t + N_t + R_t \\\\\n&= N \\left[ \\sum_{i=1}^{n}  c \\times e^{-(r + \\lambda) \\times (T_i\n-t)} \\mathbb{1}_{T_i \\geq t} + e^{-(r+\\lambda)(T-t)} \\mathbb{1}_{T \\geq t} +  \\lambda R \\times \\frac{1 - e^{-(r+\\lambda)(T-t)}}{r+\\lambda} \\mathbb{1}_{T \\geq t} \\right]\n\\end{aligned}\n$$\n\net nous avons signfi√© la condition dans laquelle l'obligation √©mise vaut 100\\% du nominal, i.e. au pair, est $c \\approx r + \\lambda$. Cependant, ce n'est pas exact.\n\nSoit un coupon pay√© en continu, la valorisation de l'obligation est donn√©e par :\n\n$$\n\\begin{aligned}\nB_t &= N \\left[ \\int_{t}^{T} c e^{-(r + \\lambda) \\times (u-t)} du + e^{-(r+\\lambda)(T-t)} +  \\lambda R \\times \\frac{1 - e^{-(r+\\lambda)(T-t)}}{r+\\lambda} \\right]\\\\\n&= N \\left[ \\frac{c}{r + \\lambda} \\left(1 - e^{-(r + \\lambda)(T-t)} \\right) + e^{-(r+\\lambda)(T-t)} +  \\lambda R \\times \\frac{1 - e^{-(r+\\lambda)(T-t)}}{r+\\lambda} \\right]\\\\\nB_t = N &\\Leftrightarrow c = r + \\lambda (1 - R) \\\\\n& c - r = \\lambda (1 - R) \n\\end{aligned}\n$$\n\nDe ce fait, en extrayant $c$, la condition dans laquelle l'obligation √©mise vaut 100\\% du nominal, i.e. au pair, est $c = r + \\lambda (1 - R) $.\n\n> üí° $s = c-r$ est la prime de cr√©dit ou encore le spread de cr√©dit. C'est la prime que l'investisseur demande pour le risque de cr√©dit. Si $c > r$, l'obligation est √©mise √† un prix sup√©rieur √† 100\\% du nominal. Si $c < r$, l'obligation est √©mise √† un prix inf√©rieur √† 100\\% du nominal. Ce spread permet de faire la relation entre la PD exprim√© par $\\lambda$ et la LGD exprim√© par $1 -R$. Cette information est plus facile √† avoir que l'intensit√© de d√©faut car le spread est cot√© sur le march√© √† travers les CDS. Par d√©finition, on en d√©duit facilement que plus cettre prime est √©lev√©, plus l'emetteur est risqu√©.\n\nTake away : Les notions de duration et de spread sont tr√®s importants dans la mod√©lisation du risque de taux\n\n#### cas de l'argentine, pays risqu√©\n\n::: {#7c009721 .cell execution_count=19}\n``` {.python .cell-code}\ns = 1031/10000 \nR = 0.4\nlambda_ = s / (1 - R)\nt=0\n\nprint(f\"Spread de cr√©dit : {s:.2%}\")\nprint(f\"Recouvrement : {R:.2%}\")\nprint(f\"Intensit√© de d√©faut : {lambda_:.2%}\")\nPS = [np.exp( - lambda_ * (T - t)) for T in range(1, 21)]\n\nplt.plot(range(1,21),PS)\nplt.title(\"Probabilit√© de survie en fonction de la maturit√©\")\nplt.xlabel(\"T\")\nplt.ylabel(\"Probabilit√© de survie\")\nplt.grid()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpread de cr√©dit : 10.31%\nRecouvrement : 40.00%\nIntensit√© de d√©faut : 17.18%\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-19-output-2.png){}\n:::\n:::\n\n\n#### cas de la France\n\n::: {#12849fe4 .cell execution_count=20}\n``` {.python .cell-code}\n# Cas de la France\ns = 32.4/10000 \nR = 0.4\nlambda_ = s / (1 - R)\nt=0\n\nprint(f\"Spread de cr√©dit : {s:.2%}\")\nprint(f\"Recouvrement : {R:.2%}\")\nprint(f\"Intensit√© de d√©faut : {lambda_:.2%}\")\nPS = [np.exp( - lambda_ * (T - t)) for T in range(1, 21)]\n\nplt.plot(range(1,21),PS)\nplt.title(\"Probabilit√© de survie en fonction de la maturit√©\")\nplt.xlabel(\"T\")\nplt.ylabel(\"Probabilit√© de survie\")\nplt.grid()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpread de cr√©dit : 0.32%\nRecouvrement : 40.00%\nIntensit√© de d√©faut : 0.54%\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-20-output-2.png){}\n:::\n:::\n\n\nEn comparant les deux pays, l'Argentine et la France. On sait que l'argentine est un pays plus risqu√© que la France. Cela se voit √©galement au niveau des spreads de cr√©dit.\nEn effet, le spread de l'Argentine est plus √©lev√© que celui de la France. Cela signifie que les investisseurs demandent une prime de risque plus √©lev√©e pour investir dans des obligations argentines que dans des obligations fran√ßaises. De plus, en regardant la probabilit√© de survie des deux pays, on constate que la probabilit√© de survie de l'Argentine est plus faible que celle de la France. Cela signifie que les investisseurs consid√®rent que l'Argentine est plus susceptible de faire d√©faut que la France.\n\n### VI.2 Sensibilit√© cr√©dit\n\n::: {#354032ee .cell execution_count=21}\n``` {.python .cell-code}\ndef sensivity_to_credit(t,c,T,r,lambda_,R,N,dt=1,dlambda_= 0.01/100):\n    \"\"\"\n    Fonction qui calcule la sensibilit√© d'une obligation √† un taux d'int√©r√™t.\n    \"\"\"\n    B_t = pricing_bond(t,c,T,r,lambda_,R,N,dt)\n    B_t_plus = pricing_bond(t,c,T,r,lambda_ + dlambda_,R,N,dt)\n    \n    sensivity = -((B_t_plus - B_t)/dlambda_) * (1/B_t) * (1/ (1-R))\n\n    return sensivity\n```\n:::\n\n\n::: {#7cd7ddf0 .cell execution_count=22}\n``` {.python .cell-code}\nt=0\nlambda_ = 1/100\nT = 10\nc =3/100\nR = 40/100\nr = 2/100\nN=1\n\nsensivity_to_credit(t,c,T,r,lambda_,R,N,dlambda_=0.01/100)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nnp.float64(8.821190868023761)\n```\n:::\n:::\n\n\n::: {#4142e5f4 .cell execution_count=23}\n``` {.python .cell-code}\nt=0\nlambda_ = 1/100\nr = 2/100\nc =3/100\nR = 40/100\nN=1\n\ndirty_prices = []\ngrid_values_T = np.arange(1,20,1)\nfor T in grid_values_T:\n    B_t_dirty = sensivity_to_credit(t,c,T,r,lambda_,R,N)\n    dirty_prices.append(B_t_dirty)\n\nplt.plot(grid_values_T,dirty_prices, label=\"Dirty prices\")\nplt.title(\"Sensibilit√© cr√©dit en fonction de la maturit√©\")\nplt.legend()\nplt.grid()\nplt.xlabel(\"T\")\nplt.ylabel(\"Sensibilit√©\")\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\nText(0, 0.5, 'Sensibilit√©')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-23-output-2.png){}\n:::\n:::\n\n\nSoit le mod√®le normale pour le taux :\n\n$$\ndr_t = \\theta (\\mu - r_t) dt + \\sigma_r dW_t\n$$\n\net un mod√®le log normale pour le spread de cr√©dit, puisqu'il ne peut √™tre n√©gatif :\n$$\n\\frac{ds_t}{s_t} = \\sigma_s dZ_t\n$$  \n\nCes deux mod√®les sont li√©s par $dW_t dZ_t = \\rho dt$. On peut exprimer cette relation par $Z_t = \\rho W_t + \\sqrt{1 - \\rho^2} V_t$, o√π $V_t$ est un mouvement brownien standard ind√©pendant de $W_t$. Cette corr√©lation est positive. \n> üí° si les taux d'int√©r√™t montent, le risque de cr√©dit augmente puisque les entreprises ont plus de mal √† rembourser leur dette. De ce fait, le spread de cr√©dit augmente.\n\nSupposons qu'on cherche √† calculer une VaR d'horizon $h$. Pour cela, il faudra faire des simulations de Monte Carlo pour les deux mod√®les. \n\n$$\n\\begin{aligned}\nr_{t+h} &= r_t + \\theta (\\mu - r_t) h + \\sigma_r \\sqrt{h} W_t \\\\\ns_{t+h} &= s_t \\exp(\\sigma_s \\sqrt{h} Z_t) \\\\\nou \\quad s_{t+h} &= s_t (1 + \\sigma_s \\sqrt{h} Z_t) \\quad (\\text{par DL})\n\\end{aligned}\n$$\n\nPosons les param√®tres suivants :\n- $\\theta = 0.1$ : le coefficient de vitesse de r√©version\n- $\\mu = 0.02$ : le taux d'int√©r√™t moyen\n- $\\sigma_r = 0.01$ : la volatilit√© du taux d'int√©r√™t\n- $\\sigma_s = 0.4$ : la volatilit√© du spread de cr√©dit\n- $\\rho = 0.4$ : la corr√©lation entre les deux mouvements browniens\n- $r = 0.02$ : le taux d'int√©r√™t initial\n- $h = 1/12$ : l'horizon de calcul de la VaR\n- $c = 3\\%$ : le coupon annuel\n- $R = 40\\%$ : le taux de recouvrement\n- $N = 1$ : le nominal de l'obligation\n- $T = 10$ : l'√©ch√©ance de l'obligation\n\n::: {#c8eef062 .cell execution_count=24}\n``` {.python .cell-code}\nimport numpy as np\n\ndef MC_VaR(c,T,r,lambda_,R,N,h,sigma_r, sigma_s, rho, alpha=0.99, N_MC=1000,dt=1):\n    # print(\"Parameters\")\n    # print(f\"coupon : {c:.2%}\")\n    # print(f\"maturity : {T} years\")\n    # print(f\"risk free rate : {r:.2%}\")\n    # print(f\"credit spread : {lambda_:.2%}\")\n    # print(f\"recovery rate : {R:.2%}\")\n    # print(f\"nominal : {N}\")\n\n    prices = []\n    \n    P_0 = pricing_bond(t=0,c=c,T=T,r=r,lambda_=lambda_,R=R,N=N,dt=dt)\n    # print(f\"P0 : {P_0}\")\n\n    s_0 = lambda_ * (1 - R)\n    r_0 = r\n\n    for t in range(N_MC):\n        # Generate correlated Brownian motions\n        W1 = np.random.normal()\n        W2 = rho * W1 + np.sqrt(1 - rho) * np.random.normal()\n\n        # Euler discretization \n        r_h = r_0 + sigma_r * np.sqrt(h) * W1\n        s_h = s_0 * ( 1 + sigma_s * np.sqrt(h) * W2)\n        lambda_h = s_h / (1 - R)\n        # print(\"=\"*30)\n        # print(\"Parameters\")\n        # print(f\"coupon : {c:.2%}\")\n        # print(f\"maturity : {T} years\")\n        # print(f\"risk free rate : {r_h:.2%}\")\n        # print(f\"credit spread : {lambda_h:.2%}\")\n        # print(f\"recovery rate : {R:.2%}\")\n        # print(f\"nominal : {N}\")\n\n        P_h = pricing_bond(t=h,c=c,T=T,r=r_h,lambda_ = lambda_h,R=R,N=N,dt=dt)\n        # print(f\"Price : {P_h}\")\n        variation = (P_h - P_0)/P_0\n        prices.append(variation)\n\n\n    VaR = np.quantile(prices, 1 - alpha)\n\n    return VaR\n\nsigma_r = 0.01\nsigma_s = 0.4\nrho = 0.40\n\nlambda_ = 1/100\nr = 2/100\nc =3/100\nR = 40/100\nN=1\nh = 1/12\nT= 10\n\nVaR_monte_carlo = MC_VaR(c,T,r,lambda_,R,N,h,sigma_r, sigma_s, rho, alpha=0.99, N_MC=1000,dt=1)\nprint(f\"VaR estim√© par Monte Carlo : {VaR_monte_carlo:.4%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVaR estim√© par Monte Carlo : -5.7782%\n```\n:::\n:::\n\n\nLorsque $ \\rho $ (le coefficient de corr√©lation entre les taux d'int√©r√™t et le spread de cr√©dit) est positif, une hausse des taux d'int√©r√™t entra√Æne √©galement une hausse du spread de cr√©dit. Cette dynamique amplifie le risque global, car les pertes dues √† la hausse des taux s‚Äôajoutent aux pertes induites par l'√©largissement du spread de cr√©dit. Ainsi, la Value at Risk (VaR) est plus √©lev√©e, refl√©tant l‚Äôaccumulation des risques li√©s aux deux facteurs.  \n\nEn revanche, lorsque $ \\rho $ est n√©gatif, une hausse des taux d'int√©r√™t tend √† r√©duire le spread de cr√©dit, et inversement. Il se cr√©e alors un effet de compensation : les pertes g√©n√©r√©es par l‚Äô√©volution des taux sont partiellement absorb√©es par les gains r√©sultant de la contraction du spread (ou inversement). C'est le principe de diversification.\nDans ce cas, la VaR est plus faible, car les effets du taux d‚Äôint√©r√™t et du spread de cr√©dit s'annulent en partie, r√©duisant ainsi l'ampleur des pertes potentielles.  \n\n::: {#79530eda .cell execution_count=25}\n``` {.python .cell-code}\n# VaR en fonction de rho\nfrom tqdm import tqdm \n\nrhos = np.linspace(-1,1,100)\nVaRs = [MC_VaR(c,T,r,lambda_,R,N,h,sigma_r, sigma_s, rho, alpha=0.99, N_MC=1000,dt=1) for rho in tqdm(rhos)]\n\nplt.plot(rhos,VaRs)\nplt.title(\"VaR en fonction de la corr√©lation\")\nplt.xlabel(\"rho\")\nplt.ylabel(\"VaR\")\nplt.grid()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r  0%|          | 0/100 [00:00<?, ?it/s]\r 10%|‚ñà         | 10/100 [00:00<00:00, 90.55it/s]\r 20%|‚ñà‚ñà        | 20/100 [00:00<00:00, 90.66it/s]\r 30%|‚ñà‚ñà‚ñà       | 30/100 [00:00<00:00, 91.29it/s]\r 40%|‚ñà‚ñà‚ñà‚ñà      | 40/100 [00:00<00:00, 91.19it/s]\r 50%|‚ñà‚ñà‚ñà‚ñà‚ñà     | 50/100 [00:00<00:00, 91.60it/s]\r 60%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    | 60/100 [00:00<00:00, 91.91it/s]\r 70%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà   | 70/100 [00:00<00:00, 92.03it/s]\r 80%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  | 80/100 [00:00<00:00, 91.73it/s]\r 90%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà | 90/100 [00:00<00:00, 91.77it/s]\r100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 100/100 [00:01<00:00, 92.01it/s]\r100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| 100/100 [00:01<00:00, 91.67it/s]\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bond_valo_files/figure-ipynb/cell-25-output-2.png){}\n:::\n:::\n\n\n#### Estimation de la volatilit√© du spread de cr√©dit\n\nPour la volatilit√© du spread, nous avons suppos√© que $\\sigma_s = 40\\%$. Nous allons maintenant estimer cette volatilit√© √† partir des donn√©es de march√©, en utilisant l'historique des spreads de cr√©dit sur une p√©riode de 5 ans, i.e. 11/03/2025 - 11/03/2020, disponible sur ce [lien](cds.xlsx).\n\nLa volatilit√© du spread est une volatilit√© annualis√©e. De ce fait, la formulation de la volatilit√© empirique, lorsque la fr√©quence est quotidienne, est la suivante :\n\n$$\n\\sigma_s = \\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n} (s_i - \\bar{s})^2} \\times \\sqrt{255}\n$$\n\n::: {#718a0d2d .cell execution_count=26}\n``` {.python .cell-code}\ncds_df = pd.read_excel(\"cds.xlsx\", skiprows=6)\n#date as date\ncds_df[\"Date\"] = pd.to_datetime(cds_df[\"Date\"], format=\"%Y-%m-%d\")\ncds_df = cds_df.set_index(\"Date\")\ncds_df = cds_df.sort_index()\n\ncds_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>PX_LAST</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2020-03-11</th>\n      <td>30.772</td>\n    </tr>\n    <tr>\n      <th>2020-03-12</th>\n      <td>36.977</td>\n    </tr>\n    <tr>\n      <th>2020-03-13</th>\n      <td>37.869</td>\n    </tr>\n    <tr>\n      <th>2020-03-16</th>\n      <td>44.432</td>\n    </tr>\n    <tr>\n      <th>2020-03-17</th>\n      <td>49.923</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#21769994 .cell execution_count=27}\n``` {.python .cell-code}\nvol_est = np.std(cds_df[\"PX_LAST\"].pct_change())\nprint(f\"Volatilit√© estim√©e sur 5 ans: {vol_est*np.sqrt(255):.4f}\")\n\n# volatilit√© sur 1 an\nvol_est= np.std(cds_df.loc[\"2024-03-11\":\"2025-03-11\", \"PX_LAST\"].pct_change())\nprint(f\"Volatilit√© estim√©e sur 1 an : {vol_est*np.sqrt(255):.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVolatilit√© estim√©e sur 5 ans: 0.4512\nVolatilit√© estim√©e sur 1 an : 0.5181\n```\n:::\n:::\n\n\n# Risque de mod√®le et risque climatique\n\nEn dehors du risque de cr√©dit et du risque de march√©, il existe d'autres types de risques qui peuvent affecter les institutions financi√®res et les march√©s. Deux d‚Äôentre eux sont le risque de mod√®le et le risque climatique.\n\n## Risque de mod√®le\n\nLe risque de mod√®le est le risque associ√© √† une mauvaise utilisation d‚Äôun mod√®le dans le processus de prise de d√©cision. Il peut √™tre caus√© par :\n- une incertitude sur les param√®tres,\n- une qualit√© insuffisante des donn√©es,\n- ou une inad√©quation structurelle du mod√®le par rapport √† la r√©alit√© observ√©e.\n\nCe risque peut conduire √† des erreurs de pr√©vision, √† des d√©cisions inappropri√©es ou √† des pertes financi√®res. Il est donc essentiel de bien comprendre les hypoth√®ses et limites des mod√®les employ√©s.\n\nC‚Äôest une activit√© o√π l‚Äôintervention humaine reste indispensable : il est n√©cessaire de proc√©der √† des *sanity checks*, du *backtesting*, et de challenger les mod√®les √† l‚Äôaide de versions plus simples (*d√©g√©n√©r√©es*) ou plus riches, afin d‚Äôen comparer les r√©sultats et de mieux cerner leurs faiblesses.\n\nPour r√©duire le risque de mod√®le, il est courant de mettre en place une fonction ind√©pendante de validation, g√©n√©ralement assur√©e par les √©quipes MRM (Model Risk Management). Ces derni√®res sont charg√©es :\n- d‚Äôauditer les mod√®les,\n- de mener des tests de robustesse,\n- et de recommander des provisions en cas de risque de sur√©valuation des actifs.\n\nLes comp√©tences cl√©s pour cette activit√© incluent :\n- les math√©matiques financi√®res,\n- la connaissance des march√©s financiers et des mod√®les de risque,\n- la programmation et l‚Äôutilisation d‚Äôoutils quantitatifs,\n- ainsi que des aptitudes √† la communication, au travail en √©quipe et au raisonnement critique.\n\n\n## Risque climatique\n\nLe risque climatique d√©signe les impacts potentiels des changements climatiques et des politiques environnementales sur les entreprises et les march√©s financiers. Contrairement aux risques classiques, les trajectoires de r√©f√©rence sont d√©finies par des organismes scientifiques comme le GIEC, ce qui limite l‚Äôappropriation directe des mod√®les par les institutions financi√®res. Il s‚Äôagit donc d‚Äôun domaine o√π le risque de mod√®le est indirect.\n\nLe r√©seau NGFS (Network for Greening the Financial System) a √©t√© mis en place pour aider les r√©gulateurs et les banques centrales √† mieux int√©grer les risques climatiques dans leurs cadres prudentiels.\n\n√Ä l‚Äôheure actuelle, il n‚Äôexiste pas de consensus clair sur la mani√®re d‚Äôint√©grer pleinement le risque climatique dans les mod√®les financiers ; il s‚Äôagit plut√¥t de tentatives progressives d‚Äôadaptation. Le NGFS propose plusieurs sc√©narios climatiques, parmi lesquels :\n\n- Current Policies : continuit√© des politiques actuelles sans nouvel engagement.\n- NDC (Nationally Determined Contributions) : politiques actuelles + engagements annonc√©s par les √âtats.\n- Disorderly Transition (1.5¬∞C) : les engagements sont mis en ≈ìuvre avec retard ou de fa√ßon d√©sorganis√©e.\n- Net Zero / 2¬∞C : sc√©nario optimis√© pour limiter le r√©chauffement √† 2¬∞C ‚Äî le cadre le plus ambitieux et le plus stable.\n\n\nOn distingue g√©n√©ralement deux types de risques climatiques :\n\n### 1. Risque physique\n\nCe risque est li√© aux cons√©quences directes des changements climatiques sur les infrastructures et l‚Äôenvironnement :\n- Risques aigus : √©v√©nements extr√™mes (inondations, s√©cheresses, temp√™tes, etc.).\n- Risques chroniques : √©volutions lentes (√©l√©vation du niveau des mers, hausse des temp√©ratures, etc.).\n\nCes risques peuvent entra√Æner :\n- des pertes mat√©rielles,\n- des interruptions d‚Äôactivit√©,\n- des co√ªts de r√©paration et d‚Äôadaptation.\n\n### 2. Risque de transition\n\nCe risque est associ√© aux mesures prises pour r√©duire les √©missions de gaz √† effet de serre et passer √† une √©conomie bas carbone. Il peut provoquer :\n- des pertes de valeur sur certains actifs,\n- des co√ªts de transition √©lev√©s,\n- des bouleversements sectoriels et technologiques.\n\nIl comprend deux composantes :\n- le risque politique (durcissement r√©glementaire, interdictions, fiscalit√© verte, etc.),\n- et le risque/opportunit√© technologique (√©mergence de nouvelles technologies, changement dans les pr√©f√©rences de consommation, etc.).\n\nOn peut formuler ce risque comme une relation :\n\n$$\n\\text{Risque de transition} = \\text{Risque politique} - \\text{Opportunit√©s technologiques}\n$$\n\nAinsi, une entreprise bien positionn√©e sur les technologies vertes peut compenser tout ou partie du risque politique subi.\n\n- Le risque physique est plus √©lev√© dans les sc√©narios Current Policies, NDC, et Disorderly Transition, car ils impliquent une action climatique insuffisante ou retard√©e.\n- √Ä l‚Äôinverse, le risque de transition est plus important dans les sc√©narios ambitieux comme Net Zero, o√π les ajustements politiques et √©conomiques sont rapides et profonds.\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /Users/cherylkouadio/Documents/Repositories/personal-website/.venv/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.9.6\n---\n",
    "supporting": [
      "bond_valo_files/figure-ipynb"
    ],
    "filters": []
  }
}