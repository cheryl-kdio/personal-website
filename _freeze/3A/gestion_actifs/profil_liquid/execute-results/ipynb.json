{
  "hash": "08d4313d8efaa8579cc23c05e0905434",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Profil d'écoulement/ de liquidation de portefeuille\nauthor : Cheryl Kouadio\njupyter: python3\ndate: \"2025-01-27\"\n---\n\n\n\n\n\n\n\nNous souhaitons calculer le profil d'écoulement/liquidation dans les scénarios suivants :\n\n1. Sous conditions normales avec déformation :\nOn part des volumes normaux des marchés, que l'on déforme pour obtenir les volumes liquidés. Dans ce cas, la liquidation commence par les actifs les plus faciles à liquider, pour finir avec les actifs les moins liquides. Cela entraîne une modification de la composition du portefeuille : les investisseurs qui sortent en premier disposent d’un portefeuille plus liquide, tandis que ceux qui restent se retrouvent désavantagés avec un portefeuille composé d'actifs moins liquides.\n\n2. Sous conditions normales sans déformation :\nL'objectif est de conserver le caractère liquide du portefeuille, afin de ne pas désavantager les investisseurs qui restent.\n\n3. Sous conditions stressées avec déformation :\nDans ce scénario, les marchés s’assèchent, ce qui entraîne une réduction significative des volumes liquidés. La déformation implique que les actifs les plus liquides sont liquidés en priorité, laissant un portefeuille encore plus illiquide pour ceux qui restent.\n\n4. Sous conditions stressées sans déformation :\nDans ce cas, bien que les marchés soient stressés, on cherche à maintenir un équilibre dans le portefeuille pour éviter de pénaliser les investisseurs restants.\n\n\n\nDans l'ordre des étapes, il s'agira dans ce TP de faire :\n\n1. Récupération des volumes quotidiens sur un historique de 3 mois.\n2. Calcul de l'ADV sur 3 mois (ADV 3M), c'est-à-dire la moyenne des volumes sur ces 3 mois.\n3. Génération des quantités associées à chaque actif :\n4. Pour obtenir un portefeuille ni trop liquide, ni trop illiquide, on prendra :\n$1.5 \\times randn() \\times \\text{ADV 3M}$, où randn()randn() génère une variable aléatoire selon une distribution normale.\n5. Calcul du profil de liquidation.\n\n::: {#2f3d171a .cell execution_count=1}\n``` {.python .cell-code}\n# ! pip install yfinance\nfrom datetime import datetime, timedelta\nimport yfinance as yf \nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/cherylkouadio/Library/Python/3.9/lib/python/site-packages/urllib3/__init__.py:35: NotOpenSSLWarning:\n\nurllib3 v2 only supports OpenSSL 1.1.1+, currently the 'ssl' module is compiled with 'LibreSSL 2.8.3'. See: https://github.com/urllib3/urllib3/issues/3020\n\n```\n:::\n:::\n\n\n::: {#42701ef8 .cell execution_count=2}\n``` {.python .cell-code}\ndef get_data(start_date, end_date, index_ticker, tickers, column=\"Close\"):\n    \"\"\"\n    Extraction de données de cours d'actions\n    Args:\n        start_date (str): Date de début au format 'YYYY-MM-DD'.\n        end_date (str): Date de fin au format 'YYYY-MM-DD'.\n\n    Returns:\n        dict: Contient les prix historiques des indices\n    \"\"\"\n    # Extraction des volumes historiques des composants\n    data = yf.download(tickers, start=start_date, end=end_date, auto_adjust =True)[column]\n\n    # Extraction des volumes historiques de l'indice CAC 40\n    index = yf.download(index_ticker, start=start_date, end=end_date, auto_adjust =True)[column]\n\n    return {\n        \"portfolio_data\": data,\n        \"benchmark_data\": index,\n    }\n\nend_date = datetime.now()\nstart_date = end_date - timedelta(days=3*31)\n\nselected_assets = {\n    \"AC.PA\": \"Accor\",\n    \"AI.PA\": \"Air Liquide\",\n    \"AIR.PA\": \"Airbus\",\n    \"MT.AS\": \"ArcelorMittal\",\n    \"CS.PA\": \"AXA\",\n    \"BNP.PA\": \"BNP Paribas\",\n    \"EN.PA\": \"Bouygues\",\n    \"BVI.PA\": \"Bureau Veritas\",\n    \"CAP.PA\": \"Capgemini\",\n    \"CA.PA\": \"Carrefour\",\n    \"ACA.PA\": \"Crédit Agricole\",\n    \"BN.PA\": \"Danone\",\n    \"DSY.PA\": \"Dassault Systèmes\",\n    \"EDEN.PA\": \"Edenred\",\n    \"ENGI.PA\": \"Engie\",\n    \"EL.PA\": \"EssilorLuxottica\",\n    \"ERF.PA\": \"Eurofins Scientific\",\n    \"RMS.PA\": \"Hermès\",\n    \"KER.PA\": \"Kering\",\n    \"LR.PA\": \"Legrand\",\n    \"OR.PA\": \"L'Oréal\",\n    \"MC.PA\": \"LVMH\",\n    \"ML.PA\": \"Michelin\",\n    \"ORA.PA\": \"Orange\",\n    \"RI.PA\": \"Pernod Ricard\",\n    \"PUB.PA\": \"Publicis\",\n    \"RNO.PA\": \"Renault\",\n    \"SAF.PA\": \"Safran\",\n    \"SGO.PA\": \"Saint-Gobain\",\n    \"SAN.PA\": \"Sanofi\",\n    \"SU.PA\": \"Schneider Electric\",\n    \"GLE.PA\": \"Société Générale\",\n    \"STLA\": \"Stellantis\",\n    \"STMPA.PA\": \"STMicroelectronics\",\n    \"TEP.PA\": \"Teleperformance\",\n    \"HO.PA\": \"Thales\",\n    \"TTE.PA\": \"TotalEnergies\",\n    \"UNBLF\": \"Unibail-Rodamco-Westfield\",\n    \"VIE.PA\": \"Veolia\",\n    \"DG.PA\": \"Vinci\",\n}\n\nindex = \"^FCHI\"\n\nassets_ticker  = list(selected_assets.keys())\n\ndata = get_data(start_date,end_date, index, assets_ticker, column=\"Volume\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r[                       0%                       ]\r[**                     5%                       ]  2 of 40 completed\r[**                     5%                       ]  2 of 40 completed\r[**                     5%                       ]  2 of 40 completed\r[******                12%                       ]  5 of 40 completed\r[******                12%                       ]  5 of 40 completed\r[******                12%                       ]  5 of 40 completed\r[**********            20%                       ]  8 of 40 completed\r[***********           22%                       ]  9 of 40 completed\r[***********           22%                       ]  9 of 40 completed\r[*************         28%                       ]  11 of 40 completed\r[*************         28%                       ]  11 of 40 completed\r[***************       32%                       ]  13 of 40 completed\r[*****************     35%                       ]  14 of 40 completed\r[******************    38%                       ]  15 of 40 completed\r[*******************   40%                       ]  16 of 40 completed\r[********************  42%                       ]  17 of 40 completed\r[********************  42%                       ]  17 of 40 completed\r[**********************48%                       ]  19 of 40 completed\r[**********************50%                       ]  20 of 40 completed\r[**********************50%                       ]  20 of 40 completed\r[**********************55%*                      ]  22 of 40 completed\r[**********************57%**                     ]  23 of 40 completed\r[**********************57%**                     ]  23 of 40 completed\r[**********************62%*****                  ]  25 of 40 completed\r[**********************65%******                 ]  26 of 40 completed\r[**********************65%******                 ]  26 of 40 completed\r[**********************70%*********              ]  28 of 40 completed\r[**********************70%*********              ]  28 of 40 completed\r[**********************75%***********            ]  30 of 40 completed\r[**********************75%***********            ]  30 of 40 completed\r[**********************80%*************          ]  32 of 40 completed\r[**********************82%**************         ]  33 of 40 completed\r[**********************82%**************         ]  33 of 40 completed\r[**********************88%*****************      ]  35 of 40 completed\r[**********************90%******************     ]  36 of 40 completed\r[**********************92%*******************    ]  37 of 40 completed\r[**********************95%*********************  ]  38 of 40 completed\r[**********************95%*********************  ]  38 of 40 completed\r[*********************100%***********************]  40 of 40 completed\n\r[*********************100%***********************]  1 of 1 completed\n```\n:::\n:::\n\n\n::: {#b5816532 .cell execution_count=3}\n``` {.python .cell-code}\nportfolio_data = data[\"portfolio_data\"]\nportfolio_data.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th>Ticker</th>\n      <th>AC.PA</th>\n      <th>ACA.PA</th>\n      <th>AI.PA</th>\n      <th>AIR.PA</th>\n      <th>BN.PA</th>\n      <th>BNP.PA</th>\n      <th>BVI.PA</th>\n      <th>CA.PA</th>\n      <th>CAP.PA</th>\n      <th>CS.PA</th>\n      <th>...</th>\n      <th>SAF.PA</th>\n      <th>SAN.PA</th>\n      <th>SGO.PA</th>\n      <th>STLA</th>\n      <th>STMPA.PA</th>\n      <th>SU.PA</th>\n      <th>TEP.PA</th>\n      <th>TTE.PA</th>\n      <th>UNBLF</th>\n      <th>VIE.PA</th>\n    </tr>\n    <tr>\n      <th>Date</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2024-12-09</th>\n      <td>443660.0</td>\n      <td>7274406.0</td>\n      <td>627374.0</td>\n      <td>1091176.0</td>\n      <td>1084594.0</td>\n      <td>3643529.0</td>\n      <td>568210.0</td>\n      <td>1879261.0</td>\n      <td>584078.0</td>\n      <td>3658094.0</td>\n      <td>...</td>\n      <td>751497.0</td>\n      <td>1250170.0</td>\n      <td>1123733.0</td>\n      <td>10853300.0</td>\n      <td>2766842.0</td>\n      <td>775183.0</td>\n      <td>190172.0</td>\n      <td>4923269.0</td>\n      <td>0.0</td>\n      <td>1553302.0</td>\n    </tr>\n    <tr>\n      <th>2024-12-10</th>\n      <td>390915.0</td>\n      <td>4390055.0</td>\n      <td>750778.0</td>\n      <td>1411830.0</td>\n      <td>937150.0</td>\n      <td>3017820.0</td>\n      <td>798625.0</td>\n      <td>1753947.0</td>\n      <td>538337.0</td>\n      <td>4791301.0</td>\n      <td>...</td>\n      <td>756782.0</td>\n      <td>1455141.0</td>\n      <td>1010553.0</td>\n      <td>12271800.0</td>\n      <td>2754581.0</td>\n      <td>929142.0</td>\n      <td>207821.0</td>\n      <td>5329581.0</td>\n      <td>300.0</td>\n      <td>1567864.0</td>\n    </tr>\n    <tr>\n      <th>2024-12-11</th>\n      <td>482166.0</td>\n      <td>5463916.0</td>\n      <td>640048.0</td>\n      <td>931725.0</td>\n      <td>1057111.0</td>\n      <td>1806949.0</td>\n      <td>1473254.0</td>\n      <td>1751080.0</td>\n      <td>477627.0</td>\n      <td>3225022.0</td>\n      <td>...</td>\n      <td>598249.0</td>\n      <td>1246198.0</td>\n      <td>706606.0</td>\n      <td>8752900.0</td>\n      <td>1938949.0</td>\n      <td>702050.0</td>\n      <td>187732.0</td>\n      <td>5966852.0</td>\n      <td>100.0</td>\n      <td>1259880.0</td>\n    </tr>\n    <tr>\n      <th>2024-12-12</th>\n      <td>710558.0</td>\n      <td>4035606.0</td>\n      <td>563489.0</td>\n      <td>1077016.0</td>\n      <td>908350.0</td>\n      <td>3064965.0</td>\n      <td>774731.0</td>\n      <td>1811254.0</td>\n      <td>605225.0</td>\n      <td>2852315.0</td>\n      <td>...</td>\n      <td>515921.0</td>\n      <td>1556573.0</td>\n      <td>664396.0</td>\n      <td>5588900.0</td>\n      <td>1650890.0</td>\n      <td>688202.0</td>\n      <td>170759.0</td>\n      <td>4771486.0</td>\n      <td>100.0</td>\n      <td>1784921.0</td>\n    </tr>\n    <tr>\n      <th>2024-12-13</th>\n      <td>572346.0</td>\n      <td>3069457.0</td>\n      <td>526947.0</td>\n      <td>1388272.0</td>\n      <td>1033859.0</td>\n      <td>2159456.0</td>\n      <td>587186.0</td>\n      <td>2683047.0</td>\n      <td>624709.0</td>\n      <td>3877128.0</td>\n      <td>...</td>\n      <td>464727.0</td>\n      <td>2193760.0</td>\n      <td>689639.0</td>\n      <td>9559800.0</td>\n      <td>1506707.0</td>\n      <td>620722.0</td>\n      <td>173369.0</td>\n      <td>4275545.0</td>\n      <td>100.0</td>\n      <td>1171242.0</td>\n    </tr>\n  </tbody>\n</table>\n<p>5 rows × 40 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {#86df37ff .cell execution_count=4}\n``` {.python .cell-code}\nportfolio_data.index\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nDatetimeIndex(['2024-12-09', '2024-12-10', '2024-12-11', '2024-12-12',\n               '2024-12-13', '2024-12-16', '2024-12-17', '2024-12-18',\n               '2024-12-19', '2024-12-20', '2024-12-23', '2024-12-24',\n               '2024-12-26', '2024-12-27', '2024-12-30', '2024-12-31',\n               '2025-01-02', '2025-01-03', '2025-01-06', '2025-01-07',\n               '2025-01-08', '2025-01-09', '2025-01-10', '2025-01-13',\n               '2025-01-14', '2025-01-15', '2025-01-16', '2025-01-17',\n               '2025-01-20', '2025-01-21', '2025-01-22', '2025-01-23',\n               '2025-01-24', '2025-01-27', '2025-01-28', '2025-01-29',\n               '2025-01-30', '2025-01-31', '2025-02-03', '2025-02-04',\n               '2025-02-05', '2025-02-06', '2025-02-07', '2025-02-10',\n               '2025-02-11', '2025-02-12', '2025-02-13', '2025-02-14',\n               '2025-02-17', '2025-02-18', '2025-02-19', '2025-02-20',\n               '2025-02-21', '2025-02-24', '2025-02-25', '2025-02-26',\n               '2025-02-27', '2025-02-28', '2025-03-03', '2025-03-04',\n               '2025-03-05', '2025-03-06', '2025-03-07', '2025-03-10'],\n              dtype='datetime64[ns]', name='Date', freq=None)\n```\n:::\n:::\n\n\n::: {#673a5e4b .cell execution_count=5}\n``` {.python .cell-code}\n# Calcul des ADV 3Mois\n\nadv_3m = {portfolio_data[ticker].mean() for ticker in assets_ticker}\nadv_3m\n\nADV = pd.DataFrame(adv_3m, index = assets_ticker, columns = [\"ADV\"])\nADV.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ADV</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>AC.PA</th>\n      <td>2.757892e+06</td>\n    </tr>\n    <tr>\n      <th>AI.PA</th>\n      <td>2.888069e+06</td>\n    </tr>\n    <tr>\n      <th>AIR.PA</th>\n      <td>1.041545e+06</td>\n    </tr>\n    <tr>\n      <th>MT.AS</th>\n      <td>5.821968e+06</td>\n    </tr>\n    <tr>\n      <th>CS.PA</th>\n      <td>8.395716e+05</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#502d104a .cell execution_count=6}\n``` {.python .cell-code}\n# Génération des quantités\nnp.random.seed(123)\nADV[\"Quantity\"] =  round(1.5 * np.random.rand(len(ADV[\"ADV\"])) * ADV[\"ADV\"])\nADV.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ADV</th>\n      <th>Quantity</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>AC.PA</th>\n      <td>2.757892e+06</td>\n      <td>2881180.0</td>\n    </tr>\n    <tr>\n      <th>AI.PA</th>\n      <td>2.888069e+06</td>\n      <td>1239585.0</td>\n    </tr>\n    <tr>\n      <th>AIR.PA</th>\n      <td>1.041545e+06</td>\n      <td>354414.0</td>\n    </tr>\n    <tr>\n      <th>MT.AS</th>\n      <td>5.821968e+06</td>\n      <td>4814605.0</td>\n    </tr>\n    <tr>\n      <th>CS.PA</th>\n      <td>8.395716e+05</td>\n      <td>906069.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nOn fait l'hypothèse que la profondeur de marché est de 20%. Celà signifie que l'on peut vendre 20% de la quantité sans impacter le prix de façon considérable. Au delà, le prix est impacté. Cette profondeur est ce qui est observé en pratique dans les carnets d'ordre à tel point que l'AMF le recommande.\n\n::: {#d8563250 .cell execution_count=7}\n``` {.python .cell-code}\nmarket_depth = 20/100\nADV[\"Quantity in 1day\"] = round(ADV[\"Quantity\"] * market_depth)\nADV.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ADV</th>\n      <th>Quantity</th>\n      <th>Quantity in 1day</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>AC.PA</th>\n      <td>2.757892e+06</td>\n      <td>2881180.0</td>\n      <td>576236.0</td>\n    </tr>\n    <tr>\n      <th>AI.PA</th>\n      <td>2.888069e+06</td>\n      <td>1239585.0</td>\n      <td>247917.0</td>\n    </tr>\n    <tr>\n      <th>AIR.PA</th>\n      <td>1.041545e+06</td>\n      <td>354414.0</td>\n      <td>70883.0</td>\n    </tr>\n    <tr>\n      <th>MT.AS</th>\n      <td>5.821968e+06</td>\n      <td>4814605.0</td>\n      <td>962921.0</td>\n    </tr>\n    <tr>\n      <th>CS.PA</th>\n      <td>8.395716e+05</td>\n      <td>906069.0</td>\n      <td>181214.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#a0dad46b .cell execution_count=8}\n``` {.python .cell-code}\n# Calcul du nombre de jours de liquidation\nADV[\"Days of liquidation\"] = ADV[\"Quantity\"]/ADV[\"Quantity in 1day\"]\n\n# floor to 1 and round\nADV[\"Days of liquidation\"] = ADV[\"Days of liquidation\"].apply(lambda x: max(1, round(x)))\nADV.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ADV</th>\n      <th>Quantity</th>\n      <th>Quantity in 1day</th>\n      <th>Days of liquidation</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>AC.PA</th>\n      <td>2.757892e+06</td>\n      <td>2881180.0</td>\n      <td>576236.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>AI.PA</th>\n      <td>2.888069e+06</td>\n      <td>1239585.0</td>\n      <td>247917.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>AIR.PA</th>\n      <td>1.041545e+06</td>\n      <td>354414.0</td>\n      <td>70883.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>MT.AS</th>\n      <td>5.821968e+06</td>\n      <td>4814605.0</td>\n      <td>962921.0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>CS.PA</th>\n      <td>8.395716e+05</td>\n      <td>906069.0</td>\n      <td>181214.0</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#4059f425 .cell execution_count=9}\n``` {.python .cell-code}\nprint(f\"Temps de liquidation du portefeuille : {ADV['Days of liquidation'].max()} jours\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemps de liquidation du portefeuille : 5 jours\n```\n:::\n:::\n\n\n## Présence de déformation\n### Sous conditions normales avec déformation (waterfall liquidation)\n\nOn peut être également interessé par la quantité de liquidation sur plusieurs jours. Pour celà, on fait l'hypothèse qu'on liquide les prochains jours aux prix observés aujourd'hui.\nCe que je peux véritablement liquider en 1 jour est donc la quantité que je peux vendre sans impacter le prix, i.e. min(quantité liquidable en 1 jour, quantité restant dans le portefeuille).\n\nOn peut calculer la valeur du portefeuille initiale et sur les jours de liquidation désirée. On l'exprime généraleent en pourcentage des encours totaux. On peut également calculer le cumul du pourcentage liquidé sur les jours de liquidation désirée. Cela nous permet d'obtenir le profil d'écoulement.\n\n::: {#311db239 .cell execution_count=10}\n``` {.python .cell-code}\n# Initialisation d'une colonne pour suivre les quantités liquidées\nADV[\"Quantity liquidated\"] = 0  # Initialement, rien n'est liquidé\n\n# Création d'une liste pour suivre la liquidation jour par jour\n# Au jour 0, on a liquidé 0. La colonne 0 sert de quantité initiale\nquantity_liquidated_per_day = [ADV[\"Quantity\"]]\n\nfor nb_day in range(1, 8):  # Pour chaque jour\n    # Calculer la quantité liquide au jour i\n    liquidated_today = np.minimum(ADV[\"Quantity in 1day\"], ADV[\"Quantity\"] - ADV[\"Quantity liquidated\"])\n    \n    # Mettre à jour les quantités liquidées dans le DataFrame\n    ADV[\"Quantity liquidated\"] += liquidated_today\n    \n    # Stocker les quantités liquidées ce jour dans une liste\n    quantity_liquidated_per_day.append(liquidated_today)\n\n# Conversion des résultats jour par jour en DataFrame pour plus de clarté\nliquidation_df = pd.DataFrame(quantity_liquidated_per_day).T\nliquidation_df.columns = [f\"{i}\" for i in range(len(quantity_liquidated_per_day))]\n\nliquidation_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n      <th>7</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>AC.PA</th>\n      <td>2881180.0</td>\n      <td>576236.0</td>\n      <td>576236.0</td>\n      <td>576236.0</td>\n      <td>576236.0</td>\n      <td>576236.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>AI.PA</th>\n      <td>1239585.0</td>\n      <td>247917.0</td>\n      <td>247917.0</td>\n      <td>247917.0</td>\n      <td>247917.0</td>\n      <td>247917.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>AIR.PA</th>\n      <td>354414.0</td>\n      <td>70883.0</td>\n      <td>70883.0</td>\n      <td>70883.0</td>\n      <td>70883.0</td>\n      <td>70882.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>MT.AS</th>\n      <td>4814605.0</td>\n      <td>962921.0</td>\n      <td>962921.0</td>\n      <td>962921.0</td>\n      <td>962921.0</td>\n      <td>962921.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>CS.PA</th>\n      <td>906069.0</td>\n      <td>181214.0</td>\n      <td>181214.0</td>\n      <td>181214.0</td>\n      <td>181214.0</td>\n      <td>181213.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#2cd42004 .cell execution_count=11}\n``` {.python .cell-code}\nend_date = datetime.now()\nstart_date = end_date - timedelta(days=1)\nprice_data = get_data(start_date, end_date, index, assets_ticker, column=\"Close\")\n\nprice_data[\"portfolio_data\"].head()\nprice_dict = price_data[\"portfolio_data\"].iloc[-1].to_dict()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r[                       0%                       ]\r[                       0%                       ]\r[****                   8%                       ]  3 of 40 completed\r[****                   8%                       ]  3 of 40 completed\r[****                   8%                       ]  3 of 40 completed\r[****                   8%                       ]  3 of 40 completed\r[*********             18%                       ]  7 of 40 completed\r[**********            20%                       ]  8 of 40 completed\r[***********           22%                       ]  9 of 40 completed\r[************          25%                       ]  10 of 40 completed\r[************          25%                       ]  10 of 40 completed\r[**************        30%                       ]  12 of 40 completed\r[**************        30%                       ]  12 of 40 completed\r[*****************     35%                       ]  14 of 40 completed\r[*****************     35%                       ]  14 of 40 completed\r[*******************   40%                       ]  16 of 40 completed\r[********************  42%                       ]  17 of 40 completed\r[**********************45%                       ]  18 of 40 completed\r[**********************45%                       ]  18 of 40 completed\r[**********************45%                       ]  18 of 40 completed\r[**********************45%                       ]  18 of 40 completed\r[**********************55%*                      ]  22 of 40 completed\r[**********************57%**                     ]  23 of 40 completed\r[**********************60%****                   ]  24 of 40 completed\r[**********************60%****                   ]  24 of 40 completed\r[**********************65%******                 ]  26 of 40 completed\r[**********************65%******                 ]  26 of 40 completed\r[**********************70%*********              ]  28 of 40 completed\r[**********************70%*********              ]  28 of 40 completed\r[**********************70%*********              ]  28 of 40 completed\r[**********************70%*********              ]  28 of 40 completed\r[**********************80%*************          ]  32 of 40 completed\r[**********************82%**************         ]  33 of 40 completed\r[**********************82%**************         ]  33 of 40 completed\r[**********************88%*****************      ]  35 of 40 completed\r[**********************88%*****************      ]  35 of 40 completed\r[**********************92%*******************    ]  37 of 40 completed\r[**********************95%*********************  ]  38 of 40 completed\r[**********************95%*********************  ]  38 of 40 completed\r[*********************100%***********************]  40 of 40 completed\n\n1 Failed download:\n['UNBLF']: YFPricesMissingError('possibly delisted; no price data found  (1d 2025-03-09 22:56:13.838275 -> 2025-03-10 22:56:13.838275)')\n\r[*********************100%***********************]  1 of 1 completed\n```\n:::\n:::\n\n\n::: {#da1220bc .cell execution_count=12}\n``` {.python .cell-code}\n# Valeur liquide des actions par jour de liquidation\nmarket_value =[\n    price_dict[ticker] * liquidation_df.loc[ticker]\n    for ticker in selected_assets\n]\n\nmarket_value = pd.DataFrame(market_value, index=selected_assets, columns=liquidation_df.columns)\nmarket_value.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n      <th>7</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>AC.PA</th>\n      <td>1.323326e+08</td>\n      <td>2.646652e+07</td>\n      <td>2.646652e+07</td>\n      <td>2.646652e+07</td>\n      <td>2.646652e+07</td>\n      <td>2.646652e+07</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>AI.PA</th>\n      <td>2.271663e+08</td>\n      <td>4.543327e+07</td>\n      <td>4.543327e+07</td>\n      <td>4.543327e+07</td>\n      <td>4.543327e+07</td>\n      <td>4.543327e+07</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>AIR.PA</th>\n      <td>5.781201e+07</td>\n      <td>1.156243e+07</td>\n      <td>1.156243e+07</td>\n      <td>1.156243e+07</td>\n      <td>1.156243e+07</td>\n      <td>1.156227e+07</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>MT.AS</th>\n      <td>1.397680e+08</td>\n      <td>2.795360e+07</td>\n      <td>2.795360e+07</td>\n      <td>2.795360e+07</td>\n      <td>2.795360e+07</td>\n      <td>2.795360e+07</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>CS.PA</th>\n      <td>3.490178e+07</td>\n      <td>6.980363e+06</td>\n      <td>6.980363e+06</td>\n      <td>6.980363e+06</td>\n      <td>6.980363e+06</td>\n      <td>6.980325e+06</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#4c9f1bbd .cell execution_count=13}\n``` {.python .cell-code}\n# Calcul de la valeur de marché initiale et totale\nmarket_value_0 = market_value.iloc[:, 0]\ntotal_market_value_0 = market_value_0.sum()\n\n# Calcul de la valeur de marché cumulée (à partir de la colonne 1)\ncumsum_market_value = market_value.iloc[:, 1:].cumsum(axis=1)\ncumsum_total_market_value = market_value.iloc[:, 1:].sum(axis=0).cumsum()\ncumsum_market_value = pd.concat([pd.DataFrame(0, index=market_value.index, columns=[0]), cumsum_market_value], axis=1)\ncumsum_total_market_value = pd.concat([pd.Series(0, index=[0]), cumsum_total_market_value])\n\nweights = {}\nfor ticker in assets_ticker :\n    weights[ticker] = (market_value_0.loc[ticker] - cumsum_market_value.loc[ticker]) / (total_market_value_0 - cumsum_total_market_value)\n\nweights = pd.DataFrame(weights).T\nweights.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n      <th>7</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>AC.PA</th>\n      <td>0.022018</td>\n      <td>0.022018</td>\n      <td>0.022018</td>\n      <td>0.022018</td>\n      <td>0.022017</td>\n      <td>0.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>AI.PA</th>\n      <td>0.037796</td>\n      <td>0.037796</td>\n      <td>0.037796</td>\n      <td>0.037796</td>\n      <td>0.037796</td>\n      <td>0.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>AIR.PA</th>\n      <td>0.009619</td>\n      <td>0.009619</td>\n      <td>0.009619</td>\n      <td>0.009619</td>\n      <td>0.009619</td>\n      <td>0.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>MT.AS</th>\n      <td>0.023255</td>\n      <td>0.023255</td>\n      <td>0.023255</td>\n      <td>0.023255</td>\n      <td>0.023255</td>\n      <td>0.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>CS.PA</th>\n      <td>0.005807</td>\n      <td>0.005807</td>\n      <td>0.005807</td>\n      <td>0.005807</td>\n      <td>0.005807</td>\n      <td>0.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#def19e5d .cell execution_count=14}\n``` {.python .cell-code}\n# Initialiser le graphique\nplt.figure(figsize=(12, 6))\n\n# Barplot empilé\nbottom = None\nfor asset in weights.index:\n    plt.bar(\n        pd.to_numeric(weights.columns),  # Les jours\n        weights.loc[asset],  # Poids de l'actif pour chaque jour\n        bottom=bottom,  # Position de départ pour empiler les barres\n        label=selected_assets[asset]  # Légende pour chaque actif\n    )\n    bottom = weights.loc[asset] if bottom is None else bottom + weights.loc[asset]\n\nplt.xlabel(\"Days of Liquidation\")\nplt.ylabel(\"Portfolio Weights\")\nplt.title(\"Déformation du portefeuille\")\nplt.xticks(rotation=45)\nplt.legend(title=\"Assets\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", fontsize=8, ncol=2)\nplt.tight_layout()\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](profil_liquid_files/figure-ipynb/cell-15-output-1.png){}\n:::\n:::\n\n\nPour un fond de droit français reglementé, on a pas le droit d'investir plus de 5% du portefeuille dans une société.\nExceptionnellement, pour certains titre, on a le droit d'investir jusqu'à 10% du portefeuille, à condition que les titres qui sont exposées à plus de 5% du portefeuille ne dépassent pas 40% du portefeuille. C'est la règle des 5/10/40. C'est un ratio réglementaire pour les OPC. Toutes les pertes réalisées en raison du défaut de ce ratio doivent être supportées par la société de gestion. Ces depassements doivent être déclarés à l'AMF. Dans notre cas, ce ratio n'est pas respecté, l'équilibre du portefeuille est chamboulé.\n\n::: {#2a7c9de8 .cell execution_count=15}\n``` {.python .cell-code}\n# Valeur liquide du portefeuille\nmarket_value_df = pd.DataFrame()\n\nmarket_value_df[\"market_value\"] = market_value.sum(axis=0)\n\n# Calculer la valeur liquide relative par rapport au jour 0\nmarket_value_df[\"relative value\"] = market_value_df[\"market_value\"] / market_value_df[\"market_value\"].iloc[0]\n\n# Calculer la valeur cumulée liquide relative du portefeuille\nmarket_value_df[\"cumulative value\"] = market_value_df[\"relative value\"].cumsum() - 1\n\n# Afficher le DataFrame résultant\nprint(market_value_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   market_value  relative value  cumulative value\n0  6.010327e+09        1.000000          0.000000\n1  1.202064e+09        0.200000          0.200000\n2  1.202064e+09        0.200000          0.400000\n3  1.202064e+09        0.200000          0.600000\n4  1.202064e+09        0.200000          0.799999\n5  1.202062e+09        0.200000          0.999999\n6  6.753130e+03        0.000001          1.000000\n7  0.000000e+00        0.000000          1.000000\n```\n:::\n:::\n\n\n::: {#5b8bdf59 .cell execution_count=16}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nmarket_value_df = market_value_df.iloc[1:]\n\nplt.figure(figsize=(12, 6))\nbars = plt.bar(market_value_df.index, market_value_df[\"cumulative value\"] * 100, color=\"skyblue\")\n\nfor bar in bars:\n    height = bar.get_height()\n    plt.text(\n        bar.get_x() + bar.get_width() / 2,  # Center text\n        height,  # Position slightly above the bar\n        f'{height:.2f}',  # Format with 2 decimal places\n        ha='center',  # Center horizontally\n        va='bottom',  # Position text at the bottom\n        fontsize=10, color=\"black\"\n    )\n\n# Set labels and title\nplt.xlabel(\"Days\")\nplt.ylabel(\"Cumulative Value (%)\")\nplt.title(\"Profil de liquidation du portefeuille\")\nplt.xticks(rotation=45)\n\n# Show the plot\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](profil_liquid_files/figure-ipynb/cell-17-output-1.png){}\n:::\n:::\n\n\nPour voir ce qui arrive au profil d'écoulement lorsque les quantités varient, on va utiliser un facteur de modulation de la quantité. Cela permet de déterminer quelle est la taille cible du portefeuille qui permet d'avoir la liquidité pour un certain niveau en nombre de jours qu'on se fixe. Cet exercice est fait une seule fois à l'initialisation du portefeuille.\n\n**La liquidité d'un portefeuille dépend de la liquidité intrinsèque des titres et la quantité de titres.**\n\n::: {#2ef9feb7 .cell execution_count=17}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef liquidation_profile(ADV, price_dict, selected_assets, fact_modulation=0.30,nb_liquidation=8, plot_graphs=True):\n    \"\"\"\n    Calcule le profil de liquidation et visualise les graphiques des poids et des valeurs cumulées.\n    \n    Parameters:\n        ADV (pd.DataFrame): DataFrame contenant les informations sur les actifs (Quantity, Quantity in 1day, etc.).\n        price_dict (dict): Dictionnaire avec les prix des actifs (clé = actif, valeur = prix).\n        selected_assets (list): Liste des actifs sélectionnés.\n        fact_modulation (float): Facteur de modulation pour ajuster les quantités.\n        plot_graphs (bool): Indique si les graphiques doivent être affichés.\n    \n    Returns:\n        pd.DataFrame: DataFrame contenant les valeurs cumulées et relatives.\n    \"\"\"\n    # Initialisation des quantités liquidées\n    ADV = ADV.copy()\n    ADV[\"Quantity liquidated\"] = 0\n    quantity_liquidated_per_day = [ADV[\"Quantity\"] * fact_modulation]\n    \n    # Calcul des quantités liquidées par jour\n    for _ in range(1, nb_liquidation+1):\n        liquidated_today = np.minimum(\n            ADV[\"Quantity in 1day\"], \n            ADV[\"Quantity\"] * fact_modulation - ADV[\"Quantity liquidated\"]\n        )\n        ADV[\"Quantity liquidated\"] += liquidated_today\n        quantity_liquidated_per_day.append(liquidated_today)\n    \n    # Conversion des résultats en DataFrame\n    liquidation_df = pd.DataFrame(quantity_liquidated_per_day).T\n    liquidation_df.columns = [f\"{i}\" for i in range(len(quantity_liquidated_per_day))]\n    \n    # Calcul de la valeur liquide par actif et par jour\n    market_value = [\n        price_dict[ticker] * liquidation_df.loc[ticker]\n        for ticker in selected_assets\n    ]\n    market_value = pd.DataFrame(market_value, index=selected_assets, columns=liquidation_df.columns)\n    \n    # Calcul des poids par jour\n    # Calcul de la valeur de marché initiale et totale\n    market_value_0 = market_value.iloc[:, 0]\n    total_market_value_0 = market_value_0.sum()\n\n    # Calcul de la valeur de marché cumulée (à partir de la colonne 1)\n    cumsum_market_value = market_value.iloc[:, 1:].cumsum(axis=1)\n    cumsum_total_market_value = market_value.iloc[:, 1:].sum(axis=0).cumsum()\n    cumsum_market_value = pd.concat([pd.DataFrame(0, index=market_value.index, columns=[0]), cumsum_market_value], axis=1)\n    cumsum_total_market_value = pd.concat([pd.Series(0, index=[0]), cumsum_total_market_value])\n\n    weights = {}\n    for ticker in selected_assets :\n        weights[ticker] = (market_value_0.loc[ticker] - cumsum_market_value.loc[ticker]) / (total_market_value_0 - cumsum_total_market_value)\n\n    weights = pd.DataFrame(weights).T\n    \n    # Visualisation des poids (barplot empilé)\n    if plot_graphs:\n        # Initialiser le graphique\n        plt.figure(figsize=(12, 6))\n\n        # Barplot empilé\n        bottom = None\n        for asset in weights.index:\n            plt.bar(\n                pd.to_numeric(weights.columns),  # Les jours\n                weights.loc[asset],  # Poids de l'actif pour chaque jour\n                bottom=bottom,  # Position de départ pour empiler les barres\n                label=selected_assets[asset]  # Légende pour chaque actif\n            )\n            bottom = weights.loc[asset] if bottom is None else bottom + weights.loc[asset]\n\n        plt.xlabel(\"Days of Liquidation\")\n        plt.ylabel(\"Portfolio Weights\")\n        plt.title(\"Déformation du portefeuille\")\n        plt.xticks(rotation=45)\n        plt.legend(title=\"Assets\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", fontsize=8, ncol=2)\n        plt.tight_layout()\n\n        plt.show()\n\n    \n    # Création du DataFrame des valeurs de marché\n    market_value_df = pd.DataFrame()\n    market_value_df[\"market_value\"] = market_value.sum(axis=0)\n    \n    # Calcul des valeurs relatives et cumulées\n    market_value_df[\"relative value\"] = market_value_df[\"market_value\"] / market_value_df[\"market_value\"].iloc[0]\n    market_value_df[\"cumulative value\"] = market_value_df[\"relative value\"].cumsum() - 1\n    market_value_df = market_value_df.iloc[1:]  # Retirer le jour 0 pour l'analyse cumulée\n    \n    # Visualisation de la valeur cumulative (barplot)\n    if plot_graphs:\n        plt.figure(figsize=(8, 4))\n        plt.bar(market_value_df.index, market_value_df[\"cumulative value\"] * 100, color=\"skyblue\")\n        plt.xlabel(\"Days\")\n        plt.ylabel(\"Cumulative Value (%)\")\n        plt.title(\"Profil de liquidation du portefeuille\")\n        plt.xticks(rotation=45)\n        plt.show()\n    return market_value_df, market_value, weights\n```\n:::\n\n\n::: {#7dc5d4a6 .cell execution_count=18}\n``` {.python .cell-code}\nfact_modulation=0.5\nnb_liquidation=6\n\nnew_market_value_df, new_market_value, new_weights = liquidation_profile(ADV, price_dict, selected_assets, fact_modulation, nb_liquidation, plot_graphs=True)\n```\n\n::: {.cell-output .cell-output-display}\n![](profil_liquid_files/figure-ipynb/cell-19-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](profil_liquid_files/figure-ipynb/cell-19-output-2.png){}\n:::\n:::\n\n\n::: {#9ec7be85 .cell execution_count=19}\n``` {.python .cell-code}\nnew_market_value.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>AC.PA</th>\n      <td>6.616630e+07</td>\n      <td>2.646652e+07</td>\n      <td>2.646652e+07</td>\n      <td>1.323326e+07</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>AI.PA</th>\n      <td>1.135832e+08</td>\n      <td>4.543327e+07</td>\n      <td>4.543327e+07</td>\n      <td>2.271663e+07</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>AIR.PA</th>\n      <td>2.890600e+07</td>\n      <td>1.156243e+07</td>\n      <td>1.156243e+07</td>\n      <td>5.781136e+06</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>MT.AS</th>\n      <td>6.988399e+07</td>\n      <td>2.795360e+07</td>\n      <td>2.795360e+07</td>\n      <td>1.397680e+07</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>CS.PA</th>\n      <td>1.745089e+07</td>\n      <td>6.980363e+06</td>\n      <td>6.980363e+06</td>\n      <td>3.490162e+06</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Sous conditions stressées avec déformation\n\nPour avoir des conditions stressées, on joue sur la quantité liquidable en un jour et de fait sur la profondeur de marché.\nPour des conditions stressées à la baisse, on divise la profondeur de marché par 2. Pour des conditions stressées à la hausse, on multiplie la profondeur de marché par 2. \n\n::: {#37cd70a3 .cell execution_count=20}\n``` {.python .cell-code}\n# Calcul des ADV 3Mois\n\nadv_3m = {portfolio_data[ticker].mean() for ticker in assets_ticker}\n\nADV_stressed = pd.DataFrame(adv_3m, index = assets_ticker, columns = [\"ADV\"])\n\n# Génération des quantités\nnp.random.seed(42)\nADV_stressed[\"Quantity\"] =  round(1.5 * np.random.uniform(0, 1, size=len(ADV)) * ADV[\"ADV\"])\n\n# Quantité journalière\nmarket_depth = (20/100)/2  # On stresse la liquidité\nADV_stressed[\"Quantity in 1day\"] = round(ADV_stressed[\"Quantity\"] * market_depth)\n\n# Calcul du nombre de jours de liquidation\nADV_stressed[\"Days of liquidation\"] = ADV_stressed[\"Quantity\"]/ADV_stressed[\"Quantity in 1day\"]\n\n# floor to 1 and round\nADV_stressed[\"Days of liquidation\"] = ADV_stressed[\"Days of liquidation\"].apply(lambda x: max(1, round(x)))\n\nprint(f\"Temps de liquidation du portefeuille : {ADV_stressed['Days of liquidation'].max()} jours\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTemps de liquidation du portefeuille : 10 jours\n```\n:::\n:::\n\n\n::: {#4f6f52d2 .cell execution_count=21}\n``` {.python .cell-code}\nfact_modulation=1\nnb_liquidation=12\n\nstressed_market_value_df, stressed_market_value, stressed_weights = liquidation_profile(ADV_stressed, price_dict, selected_assets, fact_modulation, nb_liquidation, plot_graphs=True)\n```\n\n::: {.cell-output .cell-output-display}\n![](profil_liquid_files/figure-ipynb/cell-22-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](profil_liquid_files/figure-ipynb/cell-22-output-2.png){}\n:::\n:::\n\n\n## Absence de déformation du portefeuille (pro forma)\n\nL'objectif est de conserver la distribution du portefeuille à mesure qu'il se liquide. Tout d'abord, on estime la quantité liquidable à un jour de chacun des titres comme fait précédemment. Celà permet d'avoir le pourcentage liquidable en un jour.\n\nSi on veut que le portefeuille se liquide à la même vitesse, il faut aller à la vitesse du titre le plus lent. On peut calculer le pourcentage liquidable en un jour pour chaque titre. On prendra le minimum de ces pourcentages pour déterminer le pourcentage liquidable en un jour du portefeuille.\n\nLe portefeuille prend ainsi plus de temps à se liquider et fatalement, le portefeuille finit par se déformer.\n\n::: {#90924674 .cell execution_count=22}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef liquidation_profile_pro_forma(ADV, price_dict, selected_assets, fact_modulation=0.30,nb_liquidation=8, plot_graphs=True):\n    \"\"\"\n    Calcule le profil de liquidation et visualise les graphiques des poids et des valeurs cumulées.\n    \n    Parameters:\n        ADV (pd.DataFrame): DataFrame contenant les informations sur les actifs (Quantity, Quantity in 1day, etc.).\n        price_dict (dict): Dictionnaire avec les prix des actifs (clé = actif, valeur = prix).\n        selected_assets (list): Liste des actifs sélectionnés.\n        fact_modulation (float): Facteur de modulation pour ajuster les quantités.\n        plot_graphs (bool): Indique si les graphiques doivent être affichés.\n    \n    Returns:\n        pd.DataFrame: DataFrame contenant les valeurs cumulées et relatives.\n    \"\"\"\n    # Initialisation des quantités liquidées\n    ADV = ADV.copy()\n    ADV[\"Quantity liquidated\"] = 0\n    quantity_liquidated_per_day = [ADV[\"Quantity\"] * fact_modulation]\n    \n    # Calcul des quantités liquidées par jour\n    for _ in range(1, nb_liquidation+1):        \n        liquidated_today = np.minimum(\n            ADV[\"Quantity in 1day\"], \n            ADV[\"Quantity\"] * fact_modulation - ADV[\"Quantity liquidated\"]\n        )\n        min_liquidated_today = (liquidated_today/ADV[\"Quantity in 1day\"]).min() # On liquide à la vitesse de l'actif le moins liquide\n        ADV[\"Quantity liquidated\"] += min_liquidated_today*liquidated_today\n        quantity_liquidated_per_day.append(liquidated_today)\n    \n    # Conversion des résultats en DataFrame\n    liquidation_df = pd.DataFrame(quantity_liquidated_per_day).T\n    liquidation_df.columns = [f\"{i}\" for i in range(len(quantity_liquidated_per_day))]\n    \n    # Calcul de la valeur liquide par actif et par jour\n    market_value = [\n        price_dict[ticker] * liquidation_df.loc[ticker]\n        for ticker in selected_assets\n    ]\n    market_value = pd.DataFrame(market_value, index=selected_assets, columns=liquidation_df.columns)\n    \n    # Calcul des poids par jour\n    # Calcul de la valeur de marché initiale et totale\n    market_value_0 = market_value.iloc[:, 0]\n    total_market_value_0 = market_value_0.sum()\n\n    # Calcul de la valeur de marché cumulée (à partir de la colonne 1)\n    cumsum_market_value = market_value.iloc[:, 1:].cumsum(axis=1)\n    cumsum_total_market_value = market_value.iloc[:, 1:].sum(axis=0).cumsum()\n    cumsum_market_value = pd.concat([pd.DataFrame(0, index=market_value.index, columns=[0]), cumsum_market_value], axis=1)\n    cumsum_total_market_value = pd.concat([pd.Series(0, index=[0]), cumsum_total_market_value])\n\n    weights = {}\n    for ticker in selected_assets :\n        weights[ticker] = (market_value_0.loc[ticker] - cumsum_market_value.loc[ticker]) / (total_market_value_0 - cumsum_total_market_value)\n\n    weights = pd.DataFrame(weights).T\n    \n    # Visualisation des poids (barplot empilé)\n    if plot_graphs:\n        # Initialiser le graphique\n        plt.figure(figsize=(12, 6))\n\n        # Barplot empilé\n        bottom = None\n        for asset in weights.index:\n            plt.bar(\n                pd.to_numeric(weights.columns),  # Les jours\n                weights.loc[asset],  # Poids de l'actif pour chaque jour\n                bottom=bottom,  # Position de départ pour empiler les barres\n                label=selected_assets[asset]  # Légende pour chaque actif\n            )\n            bottom = weights.loc[asset] if bottom is None else bottom + weights.loc[asset]\n\n        plt.xlabel(\"Days of Liquidation\")\n        plt.ylabel(\"Portfolio Weights\")\n        plt.title(\"Déformation du portefeuille\")\n        plt.xticks(rotation=45)\n        plt.legend(title=\"Assets\", bbox_to_anchor=(1.02, 1), loc=\"upper left\", fontsize=8, ncol=2)\n        plt.tight_layout()\n\n        plt.show()\n\n    \n    # Création du DataFrame des valeurs de marché\n    market_value_df = pd.DataFrame()\n    market_value_df[\"market_value\"] = market_value.sum(axis=0)\n    \n    # Calcul des valeurs relatives et cumulées\n    market_value_df[\"relative value\"] = market_value_df[\"market_value\"] / market_value_df[\"market_value\"].iloc[0]\n    market_value_df[\"cumulative value\"] = market_value_df[\"relative value\"].cumsum() - 1\n    market_value_df = market_value_df.iloc[1:]  # Retirer le jour 0 pour l'analyse cumulée\n    \n    # Visualisation de la valeur cumulative (barplot)\n    if plot_graphs:\n        plt.figure(figsize=(8, 4))\n        plt.bar(market_value_df.index, market_value_df[\"cumulative value\"] * 100, color=\"skyblue\")\n        plt.xlabel(\"Days\")\n        plt.ylabel(\"Cumulative Value (%)\")\n        plt.title(\"Profil de liquidation du portefeuille\")\n        plt.xticks(rotation=45)\n        plt.show()\n    return market_value_df, market_value, weights\n```\n:::\n\n\n::: {#2104ebaa .cell execution_count=23}\n``` {.python .cell-code}\nfact_modulation=1\nnb_liquidation=10\n\nstressed_market_value_df, stressed_market_value, stressed_weights = liquidation_profile_pro_forma(ADV_stressed, price_dict, selected_assets, fact_modulation, nb_liquidation, plot_graphs=True)\n```\n\n::: {.cell-output .cell-output-display}\n![](profil_liquid_files/figure-ipynb/cell-24-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](profil_liquid_files/figure-ipynb/cell-24-output-2.png){}\n:::\n:::\n\n\nPour gérer la liquidité d'un portefeuille et donc préserver la qualité du portefeuille, on peut suspendre les souscriptions et les rachats par des mécanismes émis par la loi. Les régulateurs des SGP annoncent que les investisseurs annoncent que les indivdus ne peuvent plus souscrire ou faire un rachat.\n\n**Mécanismes de gestion de la liquidité**:\n\n1. **Les Gates** consistent à plafonner les rachats. Si les rachats totaux sont supérieures à 5% de l'actif net, la SGP a *le droit et non l'obligatoire* ne pas honorer les rachats de plus de 5%. Elle limite donc les rachats en un jour à 5% et ventiler le reste sur les jours suivants en fonction des conditions du marché. Cela permet de ne pas impacter le prix de façon considérable. C'est une mesure de protection des investisseurs restants. Les gates restent quand même un signal négatif pour les investisseurs restants. Ils permettent toutefois de mettre de l'ordre dans le portefeuille. L'AMF le fait figurer dans le prospectus, sauf si la SGP arrive à justifier qu'elle n'a pas besoin de le faire. *Il n'en demeure pas moins que l'activation des gates est optionnelle*\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /Users/cherylkouadio/Library/Python/3.9/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.9.6\n---\n",
    "supporting": [
      "profil_liquid_files/figure-ipynb"
    ],
    "filters": []
  }
}