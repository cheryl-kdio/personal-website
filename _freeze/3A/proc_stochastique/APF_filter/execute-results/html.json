{
  "hash": "64c2576bdaf8994042c26b0fffd8c739",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"APF filter\"\nauthor: \n  - Cheryl Kouadio\n  - Safa Bouzayene\n  - Mariyam Ouyassin\ndate: \"2025-02-26\"\nnumber-sections: true\n---\n\n\n\n\n# Méthodes : étude de simulation sur la performance du filtre APF\n\n## Modèle utilisé\n\nLe filtre particulaire APF (Auxiliary Particle Filter) est un filtre particulaire qui utilise des particules auxiliaires pour estimer la densité de probabilité de l'état caché. Il est utilisé pour estimer l'état caché d'un système dynamique non linéaire. Dans cet article, nous allons étudier la performance du filtre APF en utilisant un exemple simple.\n\nComme tout filtre particulaire, il est necessaire de spécifier la distribution a priori de l'état, i.e. $p(x_0)$, la distribution de transition, i.e. $p(v_t|v_{t-1})$ et la vraisemblance, i.e. $p(y_t|v_t)$.\n\nDans le modèle de Heston spécifié en (1), on considère que : \n$$\np(v_t|v_{t-1})=2c\\chi^2(2cx_k; 2q + 2; 2ce^{-\\kappa \\Delta} x_{k−1}),\n$$\n\n$$p(v_1) = \\Gamma(v_1; a,b)$$ où $a = \\frac{2 \\kappa \\theta}{\\sigma^2}$ et $b = \\frac{2 \\kappa}{\\sigma^2}$,\n\net $p(y_t)|v_t) = N(0,h)$.\n\n$$\n\\begin{cases}\ndS_t = S_t \\left( rds + \\sqrt{v_t} dW_t^1 \\right) \\\\\ndv_t = \\kappa (\\theta - v_t) ds + \\sigma \\sqrt{v_t} dW_t^2 \\\\\ndW_t^1 dW_t^2 = \\rho ds\n\\end{cases}\n\\quad (1)\n$$\n\nPour tester la pertinence de l'APF, nous allons utiliser les paramètres suivants $\\Phi = (\\theta = 0.03, \\kappa = 4, \\sigma = 0.4, \\kappa = -0.87, \\rho = 0.5)$.\nPour passer en temps discret et assurer la positivité de la volatilité, nous utilisosn le schema d'euler (à $|v_t|$) suivant :\n\n$$\n\\begin{cases}\ny_t = C(t, \\theta, v_t, S_t, K, \\tau) + \\varepsilon_t, \\\\[10pt]\nv_t = \\left| v_{t-1} + \\kappa \\Delta (\\theta - v_{t-1}) + \\sigma \\sqrt{v_{t-1}\\Delta} (\\rho w_t^1 + \\sqrt{1-\\rho^2}w_t^2) \\right|, \\\\[10pt]\nS_t = S_{t-1} \\left(1 + \\mu \\Delta + \\sqrt{\\Delta v_t} w_t^1 \\right), \\\\[10pt]\n\\end{cases}\n$$\n\noù $\\varepsilon_t \\sim N(0,h=0.01)$, et $w_t^1, w_t^2$ sont des variables aléatoires gaussiennes et indépendantes.\n\n:::{callout-tip}\nNous avons utilisé un schéma d'euler modifié pour garantir la positivité de la volatilité. En effet, la volatilité doit être positive dans le modèle de Heston, et le schéma d'euler standard peut produire des valeurs négatives. En prenant la valeur absolue de la volatilité à chaque étape, nous nous assurons que les valeurs restent positives. Il aurait été également possible d'utiliser le schéma d'euler à $ln(v_t)$ (via le lemme de ito) pour garantir la positivité de la volatilité.\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list=ls())\n\n################ Simulation de la trajectoire de St et vt ################ \nHeston_sim <- function(N, kappa, theta, sigma, rho, v0, mu, tau, S0){\n  # N: Number of time steps\n  dt <- tau / N  # Time step\n\n  # Store stock prices and volatilities\n  S <- numeric(N+1)\n  v <- numeric(N+1)\n  \n  S[1] <- S0\n  v[1] <- v0\n  \n  for (t in 1:N){\n    # Generate correlated Brownian motions\n    W1 <- rnorm(1)\n    W2 <- rho * W1 + sqrt(1 - rho^2) * rnorm(1)\n    \n    # Euler discretization of variance process (ensure non-negativity)\n    v[t+1] <- abs(v[t] + kappa * (theta - v[t]) * dt + sigma * sqrt(v[t] * dt) * W2)\n    \n    # Euler discretization of the stock price process \n    S[t+1] <- S[t] * (1+ mu*dt + sqrt(v[t+1] * dt) * W1)\n  }\n  \n  return(list(v_t = v, S_t=S))\n}\n```\n:::\n\n\n\n\nAvec les étapes 1 et 2, nous obtenons les trajectoires de volatilité instantanée et de prix d'action suivantes :\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(123)\nN <- 300\ntheta <- 0.03\nkappa <- 4\nsigma <- 0.4\nrho <- 0.5\nv0 <- 0.03\nmu <- 0.1\ntau<-1\nS0 <- 100\n\nres <- Heston_sim(N=N, kappa=kappa, theta=theta, sigma=sigma, rho=rho, v0=v0, mu=mu, tau=tau, S0=S0)\n\npar(mfrow=c(1,2))\nplot(res$v_t, type=\"l\", main=\"Processus de volatilité simulé\", xlab = \"Time step\", ylab = \"Volatilité\") \nplot(res$S_t, type=\"l\", main=\"Processus de prix du sous-jacent simulé\", xlab = \"Time step\", ylab = \"Prix\") \n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/heston-sim-plots-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n\n\n\n### Procédure de simulation\n\nLa procédure de simulation est la suivante :\n\n1.  Tout d'abord, une trajectoire de 300 pas de temps de la variance instantanée sera simulée pour un pas de 1 jour, en commençant par $v_0$ = 0,03.\n\n2.  Conditionnellement à cette trajectoire, une trajectoire correspondante du prix de l'action sera alors générée.\n\n3.  Nous calculons, à l'aide du modèle de Heston, les prix d'options bruités pour trois types d'options différents : une option à la monnaie (ATM), une option dans la monnaie (ITM) et une option mixte (50 % ITM / 50 % OTM).\n\nNous avons choisi trois types d’options afin d’observer comment le filtre APF se comporte dans différentes conditions de marché :\n\n- Option à la monnaie (ATM) :  \n  - Prix d'exercice : `K = 1 × S_t`\n  - Temps avant l’échéance : `τ = 0.5`\nLes options ATM sont souvent utilisées pour l'estimation de la volatilité implicite, car elles sont les plus liquides et présentent un delta proche de 0.5, ce qui les rend sensibles aux variations du sous-jacent.\n\n- Option dans la monnaie (ITM) :  \n  - Prix d'exercice : `K = 0.95 × S_t`\n  - Temps avant l’échéance : `τ = 0.5`\nLes options ITM ont une valeur intrinsèque élevée et une volatilité implicite plus stable. Elles sont moins sensibles aux fluctuations immédiates du marché mais permettent d’évaluer l’impact du filtre APF dans des conditions de faible variance du prix d’option.\n\n- Option mixte (50 % ITM / 50 % OTM) :  \n  - Prix d'exercice : `K = 117`\n  - Temps avant l’échéance : `τ = 0.5`\nCette approche permet de tester le filtre APF dans un scénario réaliste de portefeuille d'options où des positions ITM et OTM sont combinées. L’objectif est d’analyser si le filtre reste stable lorsque l’on mélange des options avec des sensibilités différentes aux mouvements du sous-jacent et aux variations de volatilité.\n\n**Pourquoi tester différentes configurations d’options ?**\n\nL'objectif de cette analyse est de vérifier comment le filtre APF se comporte en présence de conditions de marché variées :\n\n- Options ATM : impact fort de la volatilité, mais moins sujettes au risque de gamma.\n- Options ITM : faible sensibilité à la volatilité implicite, mais risque de couverture plus limité.\n- Options mixtes : évaluation de la robustesse du filtre lorsque plusieurs types d’options coexistent dans un même portefeuille.\n\nCes tests permettent de comparer la précision du filtre en fonction de la position de l'option par rapport au prix du sous-jacent.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n################ Simulation du prix des options ATM ################ \nsource(\"data/Heston_Call_Function.R\")\nset.seed(123)\n\nv_t <- res$v_t \nS_t <- res$S_t\nh <- 0.01\n\n# Prix d'option K=1*S, tau = 0.5 => A la monnaie\nr <- 5/100\ntau <- 0.5\nK <- 1\nATM <- numeric(N+1)\n\nfor(i in c(0:N+1)){\nATM[i] <- HestonCallClosedForm(lambda = kappa, vbar = theta, eta = sigma, rho = rho, v0 = v_t[i], r = r, tau = tau, S0 = S_t[i], K = K * S_t[i])\n}\n\nres$ATM <- ATM + rnorm(1,mean=0,sd=sqrt(h))\n\n################ Simulation du prix des options ITM ################ \n# Prix d'option K=0.95*S, tau = 0.5 => Hors de la monnaie\nr <- 5/100\ntau <- 0.5\nK <- 0.95\n\nITM <- numeric(N+1)\n\nfor(i in c(0:N+1)){\nITM[i] <- HestonCallClosedForm(lambda = kappa, vbar = theta, eta = sigma, rho = rho, v0 = v_t[i], r = r, tau = tau, S0 = S_t[i], K = K * S_t[i])\n}\nres$ITM <- ITM + rnorm(1,mean=0,sd=sqrt(h))\n\n################ Simulation du prix des options mixte ################ \nsummary(S_t)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  99.49  104.36  117.23  119.24  128.88  156.89 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Prix d'option K=117, tau = 0.5  => moitié ITM et moitié OTM\nr <- 5/100\ntau <- 0.5\nK <- 117\n\nMIXTE <- numeric(N+1)\n\nfor(i in c(0:N+1)){\nMIXTE[i] <- HestonCallClosedForm(lambda = kappa, vbar = theta, eta = sigma, rho = rho, v0 = v_t[i], r = r, tau = tau, S0 = S_t[i], K = K)\n}\nres$MIXTE <- MIXTE + rnorm(1,mean=0,sd=sqrt(h))\n```\n:::\n\n\n\n\n#### Prix d'options simulés\n\nEn simulant le prix de ces options, nous constatons sans surprise que les options mixte ont un prix plus élevé plus on se rapproche de la maturité. Cependant, les options ITM et ATM ont des prix plus stables, avec une légère augmentation pour les options ITM.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- length(res$ITM)  \ndt <- tau / N\ntime_axis <- seq(0, tau, length.out = N)  # Axe des temps, de 0 à tau\n\nplot(time_axis,res$ITM, type=\"l\", main = \"Evolution du prix des options \", ylim = c(0,50), col = \"red\", ylab = \"Prix\", xlab = \"Temps\")\nlines(time_axis,res$ATM, type = \"l\",col=\"blue\")\nlines(time_axis,res$MIXTE, type='l', col= \"darkgreen\")\n# legend\nlegend(\"topleft\", legend=c(\"ITM\", \"ATM\", \"Mixte\"), col=c(\"red\", \"blue\",'darkgreen'), lty=1:1, cex=0.8, title=\"Types d'option\")\n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\n#### Filtres utilisés \n\nL'objectif est de comparer les résultats de l'APF sur du filtre particulaire bootstrap en termes d'erreurs d'ajustement, mesurées par les erreurs quadratiques moyennes (RMSE) de l'ajustement de la variance et de l'ajustement des prix des options, dans différents cas de données.\n\n**Filtre bootstrap :**\n\nLe filtre boostrap fonctionne de la manière suivante :\n\n![Bootstrap filter](data/bootstrap_filter.png){fig-align=\"center\"}\n\nDans le cadre du modèle de heston, nous avons implémenté le filtre bootstrap de la manière suivante :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBootstrapParticleFilter <- function(y, S, v, K, tau = 0.5, M = 200, theta = 0.03, kappa = 4, sigma = 0.4, rho = 0.5, r = 0.05, dt = 1, h = 0.01) {\n  \n  # Paramètres supplémentaires\n  sigma_epsilon <- sqrt(h)\n\n  # Paramètres de la loi stationnaire de v\n  alpha1 <- (2 * kappa * theta) / (sigma^2)\n  alpha2 <- (sigma^2) / (2 * kappa)\n\n  # Initialisation\n  n <- length(y)\n  v_hat <- numeric(n)\n  v_particle <- matrix(nrow = n, ncol = M)\n  w <- matrix(nrow = n, ncol = M)\n  w_normalized <- matrix(nrow = n, ncol = M)\n\n  # Filtre particulaire bootstrap\n  for (t in 1:n) {\n    if (t == 1) {\n      # Initialisation des particules à t = 0\n      v_particle[t, ] <- rgamma(M, shape = alpha1, rate = 1/alpha2)\n      \n      # Poids initiaux basés sur la densité de la loi stationnaire\n      w[t, ] <- dgamma(v_particle[t, ], shape = alpha1, rate = 1/alpha2)\n      \n      # Normalisation des poids\n      w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n      \n      # Estimation initiale\n      v_hat[t] <- sum(w_normalized[t, ] * v_particle[t, ])\n    } else {\n      # Étape de prédiction (propagation des particules)\n      v_particle[t, ] <- abs(rnorm(M, \n                                    mean = v_particle[t-1, ] + kappa * (theta - v_particle[t-1, ]) * dt, \n                                    sd = sigma * sqrt(v_particle[t-1, ] * dt)))\n      \n      #  Calcul du prix du Call pour chaque particule\n      C <- numeric(M)\n      \n      # Si K est un unique scalaire (strike constant), on le conserve\n      # Si K est un vecteur, on prend K[t] comme strike au temps t\n      if (length(K) == 1) {\n          Kt <- K  # Strike constant\n      } else {\n          Kt <- K[t]  # Strike spécifique au temps t\n      }\n      \n      # Calcul pour chaque particule avec le bon strike\n      for (i in 1:M) {\n          C[i] <- HestonCallClosedForm(lambda = kappa, vbar = theta, eta = sigma, rho = rho, \n                                       v0 = v_particle[t, i], r = r, tau = tau, S0 = S[t], K = Kt)\n      }\n\n      \n      # Mise à jour des poids (vraisemblance observation-conditionnelle)\n      w[t, ] <- dnorm(y[t], mean = C, sd = sqrt(sigma_epsilon))\n      \n      # Normalisation des poids\n      w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n      \n      # Rééchantillonnage\n      index <- sample(1:M, size = M, prob = w_normalized[t, ], replace = TRUE)\n      v_particle[t, ] <- v_particle[t, index]\n      \n      # Poids uniformes après resampling\n      w_normalized[t, ] <- rep(1 / M, M)\n\n      # Estimation de la volatilité instantanée\n      v_hat[t] <- sum(w_normalized[t, ] * v_particle[t, ])\n    }\n  }\n\n  return(v_hat)\n}\n```\n:::\n\n\n\n\n**Filtre APF :**\n\nLe filtre particulaire auxilaire fonctionne de la manière suivante :\n\n![APF](data/APF.png){fig-align=\"center\"}\n\nDans le cadre du modèle de heston, nous avons implémenté le filtre APF de la manière suivante :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAPF_Heston <- function(y, S, v,K, M = 200, theta = 0.03, kappa = 4, sigma = 0.4, \n                       lambda = -0.87, rho = 0.5, r = 0.05, tau = 0.5, dt = 1, h = 0.01) {\n  \n  # Paramètres de la loi stationnaire de v\n  sigma_epsilon <- sqrt(h)\n  alpha1 <- (2 * kappa * theta) / (sigma^2)\n  alpha2 <- (sigma^2) / (2 * kappa)\n\n  # Initialisation des paramètres\n  n <- length(y)\n  \n  # Initialisation des vecteurs/matrices\n  v_hat <- numeric(n)                   \n  v_particle <- matrix(nrow = n, ncol = M)\n  mu <- matrix(nrow = n, ncol = M)        \n  py_mu <- matrix(nrow = n, ncol = M) \n  w <- matrix(nrow = n, ncol = M)\n  w_normalized <- matrix(nrow = n, ncol = M)\n\n  # Filtre particulaire APF\n  for (t in 1:n) {\n    if (t == 1) {\n      \n      v_particle[t, ] <- rgamma(M, shape = alpha1, rate = 1/alpha2)\n      w[t, ] <- rep(1 / M, M)\n      w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n      v_hat[t] <- sum(w_normalized[t, ] * v_particle[t, ])\n      \n    } else {\n      \n      # Si K est un unique scalaire (strike constant), on le conserve\n      # Si K est un vecteur, on prend K[t] comme strike au temps t\n      if (length(K) == 1) {\n          Kt <- K  # Strike constant\n      } else {\n          Kt <- K[t]  # Strike spécifique au temps t\n      }\n      \n      # 1 - Pré-sélection\n      mu[t, ] <- abs(v_particle[t-1, ] + kappa * (theta - v_particle[t-1, ]) * dt)\n      \n      mean_pymu <- numeric(M)\n      for (i in 1:M) {\n        mean_pymu[i] <- HestonCallClosedForm(lambda = kappa, vbar = theta, eta = sigma, rho = rho, \n                                             v0 = mu[t, i], r = r, tau = tau, S0 = S[t], K = Kt)\n      }\n      py_mu[t, ] <- dnorm(y[t], mean = mean_pymu, sd = sigma_epsilon)\n\n      # Poids pour la pré-sélection\n      w[t-1, ] <- py_mu[t, ] * w_normalized[t-1, ]\n      \n      # 2 - Resampling (échantillonnage)\n      index <- sample(1:M, size = M, replace = TRUE, prob = w[t-1, ])\n\n      # Mise à jour des particules\n      v_particle[t-1, ] <- v_particle[t-1, index]\n      \n      # 3 - Propagation (évolution des particules)\n      v_particle[t, ] <- abs(rnorm(M, \n                                   mean = v_particle[t-1, ] + kappa * (theta - v_particle[t-1, ]) * dt, \n                                   sd = sigma * sqrt(v_particle[t-1, ] * dt)))\n\n      # Mise à jour des poids\n      C <- numeric(M)\n      for (i in 1:M) {\n        C[i] <- HestonCallClosedForm(lambda = kappa, vbar = theta, eta = sigma, rho = rho, \n                                     v0 = v_particle[t, i], r = r, tau = tau, S0 = S[t], K = Kt)\n      }\n      likelihood <- dnorm(y[t], mean = C, sd = sigma_epsilon)\n      w[t, ] <- likelihood / (py_mu[t, index] + 1e-12)  # Protection pour éviter la division par zéro\n      \n      w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n      v_hat[t] <- sum(w_normalized[t, ] * v_particle[t, ])\n    }\n  }\n\n  # Retourner les résultats\n  return(v_hat)\n}\n```\n:::\n\n\n\n\n\n**Différence entre le filtre bootstrap et le filtre APF :**\n\nLe filtre bootstrap et le filtre APF sont deux méthodes de filtrage particulaire qui permettent d'estimer l'état caché d'un système dynamique non linéaire. La principale différence entre ces deux méthodes réside dans la manière dont elles mettent à jour les poids des particules, et ainsi comme la distribution d'importance q est construite.\nPar définition, les poids sont définis par :\n$$\nw(x_t) = w(x_{t-1}) \\frac{p(y_t|x_t)p(x_t|x_{t-1})}{q(x_t|x_{t-1},y_t)},\n$$\noù $p(y_t|x_t)$ est la vraisemblance, $p(x_t|x_{t-1})$ est la distribution de transition, et $q(x_t|x_{t-1},y_t)$ est la distribution d'importance.\n\nDans le cadre du filtre bootstrap, la distribution d'importance est définie comme suit : \n$$\nq(x_t|x_{t-1},y_t) = p(x_t|x_{t-1}).\n$$\nDe ce fait, $w(x_t) = w(x_{t-1}) p(y_t|x_t)$.Cela signifie que les poids sont mis à jour en fonction de la distribution de transition et de la vraisemblance. \n\nDans le cadre du filtre APF, la distribution d'importance se rapproche de la distribution optimale, vu dans la littérature comme étant $q(x_t|x_{t-1},y_t) = p(x_t|x_{t-1},y_t)$. De ce fait, les poids sont mis à jour en fonction de la vraisemblance conditionnelle, ce qui permet d'améliorer la précision de l'estimation de l'état caché, et donc de l'estimation de la volatilité dans notre cas.\n\n\n# Résultats\n\n## Option à la monnaie (ATM)\n### Filtre bootstrap\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##################### Définition des paramètres #####################\n# Définition des paramètres phi\ntheta <- 0.03\nkappa <- 4\nsigma <- 0.4\nlambda <- -0.87 # Prime de risque\nrho <- 0.5\n\n# Paramètres de Heston \nh <- 0.01\nr <- 0.05\n\n# Prix de call (y), du sous-jacent (S), et volatilité instantanée (v)\ny <- res$ATM\nS <- res$S_t\nv<- res$v_t\n\n# Initialisation des paramètres\nn <- length(y)  # Nombre d'observations\nM <- 200      # Nombre de particules\ndt <- 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\n# Paramètres de l'option \nK <- 1 * S\ntau<- 0.5\n\n# Exemple d'appel avec tes données \"res\"\net_boot_atm <- system.time({\nboot_atm <- BootstrapParticleFilter(y=y, S=S, v=v, K=K, tau = tau, M = M, theta = theta, kappa = kappa, sigma = sigma,  rho = rho, r = r, dt = dt, h = h)\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(v, type = \"l\", col = \"black\",  main = \"Estimation de la volatilité avec un filtre bootstrap\",xlab = \"Temps\", ylab = \"Volatilité\")\nlines(boot_atm, type = \"l\", col = \"red\")\nlegend(\"topright\", legend = c(\"Vol. obs.\", \"Vol. est.\"), col = c(\"black\", \"red\"), lty = 1)\n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(et_boot_atm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n 11.832   0.597  12.488 \n```\n\n\n:::\n\n```{.r .cell-code}\nrmse_boot_atm <- sqrt(mean((boot_atm - v)^2))\ncat(\"RMSE :\", rmse_boot_atm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRMSE : 0.001402773\n```\n\n\n:::\n:::\n\n\n\n\n\n### Filtre APF\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\net_apf_atm <- system.time({\napf_atm <- APF_Heston(y=y, S=S, v=v, K=K, tau = tau, M = M, theta = theta, kappa = kappa, sigma = sigma,  rho = rho, r = r, dt = dt, h = h)\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(v, type = \"l\", col = \"black\",  main = \"Estimation de la volatilité avec un filtre APF\",xlab = \"Temps\", ylab = \"Volatilité\")\nlines(apf_atm, type = \"l\", col = \"red\")\nlegend(\"topright\", legend = c(\"Vol. obs.\", \"Vol. est.\"), col = c(\"black\", \"red\"), lty = 1)\n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(et_apf_atm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n 23.626   1.113  24.874 \n```\n\n\n:::\n\n```{.r .cell-code}\nrmse_apf_atm <- sqrt(mean((apf_atm - v)^2))\ncat(\"RMSE :\", rmse_apf_atm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRMSE : 0.001889304\n```\n\n\n:::\n:::\n\n\n\n\n## Option à la monnaie (ITM)\n### Filtre bootstrap\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\ny <- res$ITM\nK <- 0.95 * S\n\net_boot_itm <- system.time({\nboot_itm <- BootstrapParticleFilter(y=y, S=S, v=v, K=K, tau = tau, M = M, theta = theta, kappa = kappa, sigma = sigma,  rho = rho, r = r, dt = dt, h = h)\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(v, type = \"l\", col = \"black\",  main = \"Estimation de la volatilité avec un filtre bootstrap\",xlab = \"Temps\", ylab = \"Volatilité\")\nlines(boot_itm, type = \"l\", col = \"red\")\nlegend(\"topright\", legend = c(\"Vol. obs.\", \"Vol. est.\"), col = c(\"black\", \"red\"), lty = 1)\n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(et_boot_itm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n 11.435   0.521  12.012 \n```\n\n\n:::\n\n```{.r .cell-code}\nrmse_boot_itm <- sqrt(mean((boot_itm - v)^2))\ncat(\"RMSE :\", rmse_boot_itm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRMSE : 0.00152023\n```\n\n\n:::\n:::\n\n\n\n\n\n### APF\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\net_apf_itm <- system.time({\napf_itm <- APF_Heston(y=y, S=S, v=v, K=K, tau = tau, M = M, theta = theta, kappa = kappa, sigma = sigma,  rho = rho, r = r, dt = dt, h = h)\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(v, type = \"l\", col = \"black\",  main = \"Estimation de la volatilité avec un filtre APF\",xlab = \"Temps\", ylab = \"Volatilité\")\nlines(apf_itm, type = \"l\", col = \"red\")\nlegend(\"topright\", legend = c(\"Vol. obs.\", \"Vol. est.\"), col = c(\"black\", \"red\"), lty = 1)\n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(et_apf_itm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n 22.633   1.017  23.794 \n```\n\n\n:::\n\n```{.r .cell-code}\nrmse_apf_itm <- sqrt(mean((apf_itm - v)^2))\ncat(\"RMSE :\", rmse_apf_itm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRMSE : 0.001850903\n```\n\n\n:::\n:::\n\n\n\n\n## Options mixtes\n### Filtre bootstrap\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\ny <- res$MIXTE\nK <- 117\n\net_boot_mixte <- system.time({\nboot_mixte <- BootstrapParticleFilter(y=y, S=S, v=v, K=K, tau = tau, M = M, theta = theta, kappa = kappa, sigma = sigma,  rho = rho, r = r, dt = dt, h = h)\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(v, type = \"l\", col = \"black\",  main = \"Estimation de la volatilité avec un filtre bootstrap\",xlab = \"Temps\", ylab = \"Volatilité\")\nlines(boot_mixte, type = \"l\", col = \"red\")\nlegend(\"topright\", legend = c(\"Vol. obs.\", \"Vol. est.\"), col = c(\"black\", \"red\"), lty = 1)\n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(et_boot_mixte)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n 11.923   0.444  12.371 \n```\n\n\n:::\n\n```{.r .cell-code}\nrmse_boot_mixte<- sqrt(mean((boot_mixte - v)^2))\ncat(\"RMSE :\", rmse_boot_mixte)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRMSE : 0.01595637\n```\n\n\n:::\n:::\n\n\n\n\n### APF\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\net_apf_mixte <- system.time({\napf_mixte <- APF_Heston(y=y, S=S, v=v, K=K, tau = tau, M = M, theta = theta, kappa = kappa, sigma = sigma,  rho = rho, r = r, dt = dt, h = h)\n})\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(v, type = \"l\", col = \"black\",  main = \"Estimation de la volatilité avec un filtre APF\",xlab = \"Temps\", ylab = \"Volatilité\")\nlines(apf_mixte, type = \"l\", col = \"red\")\nlegend(\"topright\", legend = c(\"Vol. obs.\", \"Vol. est.\"), col = c(\"black\", \"red\"), lty = 1)\n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(et_apf_mixte)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n 23.635   0.869  24.509 \n```\n\n\n:::\n\n```{.r .cell-code}\nrmse_apf_mixte <- sqrt(mean((apf_mixte - v)^2))\ncat(\"RMSE :\", rmse_apf_mixte)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRMSE : 0.01475175\n```\n\n\n:::\n:::\n\n\n\n\n## Comparaison des performances\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\n# Création du data.frame avec les colonnes demandées\ncomp_perf <- data.frame(\n    Méthode = c(\"APF\", \"APF\", \"APF\", \"BOOT\", \"BOOT\", \"BOOT\"),\n    Type_Option = c(\"ATM\", \"ITM\", \"MIXTE\", \"ATM\", \"ITM\", \"MIXTE\"),\n    RMSE = c(rmse_apf_atm, rmse_apf_itm, rmse_apf_mixte, rmse_boot_atm, rmse_boot_itm, rmse_boot_mixte)\n)\n\n# Conversion : Méthode comme colonne\ncomp_perf_wide <- pivot_wider(\n    comp_perf,\n    names_from = Méthode,   # Ce qui devient les colonnes\n    values_from = RMSE      # Ce qui remplit les cases\n)\n\ncomp_perf_wide <- bind_rows(\n    comp_perf_wide,\n    data.frame(\n        Type_Option = \"Moyenne\",\n        APF = mean(c(rmse_apf_atm, rmse_apf_itm, rmse_apf_mixte), na.rm = TRUE),\n        BOOT = mean(c(rmse_boot_atm, rmse_boot_itm, rmse_boot_mixte), na.rm = TRUE)\n    )\n)\n# Affichage du résultat\ncomp_perf_wide\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Type_Option |       APF|      BOOT|\n|:-----------|---------:|---------:|\n|ATM         | 0.0018893| 0.0014028|\n|ITM         | 0.0018509| 0.0015202|\n|MIXTE       | 0.0147518| 0.0159564|\n|Moyenne     | 0.0061640| 0.0062931|\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Comparaison des temps d'exécution\ncomp_temps <- data.frame(\n    Méthode = c(\"APF\", \"APF\", \"APF\", \"BOOT\", \"BOOT\", \"BOOT\"),\n    Type_Option = c(\"ATM\", \"ITM\", \"MIXTE\", \"ATM\", \"ITM\", \"MIXTE\"),\n    Temps = c(et_apf_atm[3], et_apf_itm[3], et_apf_mixte[3], et_boot_atm[3], et_boot_itm[3], et_boot_mixte[3])\n)\n\n# Conversion : Méthode comme colonne\ncomp_temps_wide <- pivot_wider(\n    comp_temps,\n    names_from = Méthode,   # Ce qui devient les colonnes\n    values_from = Temps      # Ce qui remplit les cases\n)\n\ncomp_temps_wide <- bind_rows(\n    comp_temps_wide,\n    data.frame(\n        Type_Option = \"Moyenne\",\n        APF = mean(c(et_apf_atm[3], et_apf_itm[3], et_apf_mixte[3]), na.rm = TRUE),\n        BOOT = mean(c(et_boot_atm[3], et_boot_itm[3], et_boot_mixte[3]), na.rm = TRUE)\n    )\n)\n# Affichage du résultat\ncomp_temps_wide\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Type_Option |      APF|     BOOT|\n|:-----------|--------:|--------:|\n|ATM         | 24.87400| 12.48800|\n|ITM         | 23.79400| 12.01200|\n|MIXTE       | 24.50900| 12.37100|\n|Moyenne     | 24.39233| 12.29033|\n\n</div>\n:::\n:::\n\n\n\n\nEn comparant les performances de l'APF à celles du filtre bootstrap, nous constatons que les deux filtres ont des performances assez similaires en termes d'erreurs d'ajustement (RMSE) pour les options ATM et ITM. Cependant, l'APF semble être plus efficace pour les options mixtes, avec des erreurs d'ajustement plus faibles que le filtre bootstrap. Cependant, en termes de temps d'exécution, le filtre bootstrap est plus rapide que l'APF pour les trois types d'options. En moyenne, l'APF est plus lent que le filtre bootstrap, mais offre une meilleure précision tout option confondue.\n\nPou connaitre la robustesse de ces estimations, nous avons fait du bootstrap pour estimer la distribution des RMSE, et ainsi obtenir des intervalles de confiance pour ces estimations, de même que des p-valeurs. Le code ayant servi à la simulation est disponible ici.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(ggpubr)\n\n# Charger les résultats du bootstrap\nres_ATM <- readRDS(\"results_sim/res_ATM_min.rds\")\nres_ITM <- readRDS(\"results_sim/res_ITM_min.rds\")\nres_MIXTE <- readRDS(\"results_sim/res_MIXTE_min.rds\")\n\n# Extraire les RMSE\nrmse_bootstrap_atm <- res_ATM$t[, 1]\nrmse_apf_atm_b <- res_ATM$t[, 2]\n\nrmse_bootstrap_itm <- res_ITM$t[, 1]\nrmse_apf_itm_b <- res_ITM$t[, 2]\n\nrmse_bootstrap_mixte <- res_MIXTE$t[, 1]\nrmse_apf_mixte_b <- res_MIXTE$t[, 2]\n\n# Créer un dataframe avec les valeurs RMSE pour les trois scénarios\ndf_rmse_boxplot <- data.frame(\n  Méthode = rep(c(\"Bootstrap Filter\", \"APF-Heston\"), each = c(length(rmse_bootstrap_atm), length(rmse_apf_atm_b), length(rmse_bootstrap_itm), length(rmse_apf_itm_b),length(rmse_bootstrap_mixte), length(rmse_apf_mixte_b))),\n  RMSE = c(rmse_bootstrap_atm, rmse_apf_atm_b,\n           rmse_bootstrap_itm, rmse_apf_itm_b,\n           rmse_bootstrap_mixte, rmse_apf_mixte_b),\n  Scénario = rep(c(\"ATM\", \"ATM\", \"ITM\", \"ITM\", \"MIXTE\", \"MIXTE\"), each = c(length(rmse_bootstrap_atm), length(rmse_apf_atm_b),\nlength(rmse_bootstrap_itm), length(rmse_apf_itm_b),\nlength(rmse_bootstrap_mixte), length(rmse_apf_mixte_b)))\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in rep(c(\"Bootstrap Filter\", \"APF-Heston\"), each =\nc(length(rmse_bootstrap_atm), : first element used of 'each' argument\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in rep(c(\"ATM\", \"ATM\", \"ITM\", \"ITM\", \"MIXTE\", \"MIXTE\"), each =\nc(length(rmse_bootstrap_atm), : first element used of 'each' argument\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calcul des p-valeurs\n\n# kruskall wallis\ntest_atm <- kruskal.test(list(rmse_bootstrap_atm, rmse_apf_atm_b))$p.value\ntest_itm <- kruskal.test(list(rmse_bootstrap_itm, rmse_apf_itm_b))$p.value\ntest_mixte <- kruskal.test(list(rmse_bootstrap_mixte, rmse_apf_mixte_b))$p.value\n\n# test_atm <- t.test(rmse_bootstrap_atm, rmse_apf_atm_b)$p.value\n# test_itm <- t.test(rmse_bootstrap_itm, rmse_apf_itm_b)$p.value\n# test_mixte <- t.test(rmse_bootstrap_mixte, rmse_apf_mixte_b)$p.value\n\n# Création du boxplot avec facet_wrap et ajout des p-valeurs en caption\nggplot(df_rmse_boxplot, aes(x = Méthode, y = RMSE, fill = Méthode)) +\n  geom_boxplot(alpha = 0.6) +\n  facet_wrap(~Scénario, scales = \"free_y\") +\n  labs(title = \"Comparaison des RMSE (Bootstrap vs APF) selon les scénarios\",\n       x = \"Méthode de Filtrage\",\n       y = \"RMSE\",\n       caption = paste(\"p-values t-test: ATM =\", formatC(test_atm, format = \"e\", digits = 2),\n                       \"| ITM =\", formatC(test_itm, format = \"e\", digits = 2),\n                       \"| MIXTE =\", formatC(test_mixte, format = \"e\", digits = 2))) +\n  theme_minimal() +\n  theme(legend.position = \"bottom\",\n        strip.text = element_text(size = 12, face = \"bold\"))\n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Concaténer toutes les RMSE\ntotal_rmse_bootstrap <- c(rmse_bootstrap_atm, rmse_bootstrap_itm, rmse_bootstrap_mixte)\ntotal_rmse_apf <- c(rmse_apf_atm_b, rmse_apf_itm_b, rmse_apf_mixte_b)\n\n# Kruskal wallis test\nglobal_pval <- kruskal.test(list(total_rmse_bootstrap, total_rmse_apf))$p.value\n\n# global_pval <- t.test(total_rmse_bootstrap, total_rmse_apf)$p.value\n\n# Boxplot global\nggboxplot(df_rmse_boxplot, x = \"Méthode\", y = \"RMSE\", fill = \"Méthode\",\n          ylab = \"RMSE\", xlab = \"Méthode de Filtrage\",\n          title = \"Comparaison des RMSE (Bootstrap vs APF) pour les trois scénarios\") +\n  labs(caption = paste(\"p-values: Global =\", formatC(global_pval, format = \"e\", digits = 2))) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](APF_filter_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n\n\n**Approche pvalue** :\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmse_diff_atm <- rmse_bootstrap_atm - rmse_apf_atm_b\nrmse_diff_atm_obs <- rmse_boot_atm - rmse_apf_atm\n\nmean(rmse_diff_atm_obs > rmse_diff_atm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.84\n```\n\n\n:::\n\n```{.r .cell-code}\nrmse_diff_itm <- rmse_bootstrap_itm - rmse_apf_itm_b\nrmse_diff_itm_obs <- rmse_boot_itm - rmse_apf_itm\n\nmean(rmse_diff_itm_obs > rmse_diff_itm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.38\n```\n\n\n:::\n\n```{.r .cell-code}\nrmse_diff_mixte <- rmse_bootstrap_mixte - rmse_apf_mixte_b\nrmse_diff_mixte_obs <- rmse_boot_mixte - rmse_apf_mixte\n\nmean(rmse_diff_mixte_obs > rmse_diff_mixte)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::{callout-tip}\n**Conclusion :** L'APF est une méthode plus précise que le filtre bootstrap pour estimer la volatilité instantanée dans le cadre d'un modèle de Heston où le prix est bruité $h=0.01$, mais elle est également plus lente en termes de temps d'exécution. Le choix entre ces deux méthodes dépendra donc des besoins spécifiques de l'analyse, en fonction de la précision et de la vitesse d'exécution requises.\n\nPour tester la robustesse de ces estimations, il aurait fallu faire du bootstrap afin d'estimer la distribution des RMSE, et ainsi obtenir des intervalles de confiance pour ces estimations.\n\nIl aurait été interessant de tester les filtres dans d'autres cas de figures.\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}