{
  "hash": "bfcb6759779e2d44f6a23ab8a8dd0c36",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Calibration du modèle Black-Scholes'\njupyter: python3\ndate: \"2025-01-06\"\n---\n\n\n\n\n\n\n\n# Calibration du modèle Black-Scholes\nLe modèle de Black-Scholes est un modèle mathématique qui permet de déterminer le prix d'une option à partir de plusieurs paramètres. Il est basé sur l'hypothèse que le prix de l'actif sous-jacent suit un mouvement brownien géométrique :\n\n$$\ndS_t = \\mu S_t dt + \\sigma S_t dW_t \n$$\n\nAvec $S_t$ le prix de l'actif, $\\mu$ le taux de rendement moyen, $\\sigma$ la volatilité et $W_t$ un mouvement brownien.\n\nDe ce fait, le prix d'une option européenne peut être calculé par la formule de Black-Scholes :\n\n$$\nC(S_t, K, T, r, \\sigma) = S_t N(d_1) - K e^{-rT} N(d_2)\n$$\n\nAvec $C$ le prix de l'option, $S_t$ le prix de l'actif sous-jacent, $K$ le prix d'exercice de l'option, $T$ la maturité de l'option, $r$ le taux d'intérêt sans risque, $\\sigma$ la volatilité de l'actif, $N$ la fonction de répartition de la loi normale centrée réduite, et :\n\n$$\nd_1 = \\frac{1}{\\sigma \\sqrt{T}} \\left( \\ln \\left( \\frac{S_t}{K} \\right) + \\left( r + \\frac{\\sigma^2}{2} \\right) T \\right)\n$$\n\n$$\nd_2 = d_1 - \\sigma \\sqrt{T}\n$$\n\n\n## 1. Calcul d'un call\n\n::: {#daa28f3d .cell execution_count=1}\n``` {.python .cell-code}\n# Calcul d'un call\nfrom scipy.stats import norm\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef FormulaBS(S,K,r,tau,sigma):\n    d1 = (np.log(S/K) + (r + 0.5 *sigma**2)*tau ) / (sigma * np.sqrt(tau))\n    d2 = d1 - sigma * np.sqrt(tau)\n    call = S*norm.cdf(d1) - K* np.exp( - tau * r) * norm.cdf(d2)\n    return call\n```\n:::\n\n\nLorsqu'on a pas accès à une formule analytique pour le prix d'une option, on peut utiliser la méthode de Monte-Carlo pour estimer ce prix. Pour cela, on simule un grand nombre de trajectoires du prix de l'actif sous-jacent, et on calcule la valeur de l'option à chaque date de maturité. On fait ensuite la moyenne de ces valeurs pour obtenir une estimation du prix de l'option.\n\nLe prix de l'actif sous-jacent suit un mouvement brownien géométrique, et on peut simuler ce mouvement en utilisant la formule d'Ito :\n\n$$\nS_t = S_0 e^{(\\mu - \\frac{\\sigma^2}{2})t + \\sigma W_t}\n$$\n\n::: {#6e1e1843 .cell execution_count=2}\n``` {.python .cell-code}\ndef FormulaBSMC(K,r,tau,sigma,M, S0) :\n    # Simulation du M mouvement brownien de loi N(0, sigma*sqrt(T))\n    var_brown = sigma * np.sqrt(tau)\n    W_T= np.random.normal(0,var_brown,M)\n\n    S_T = S0 * np.exp((r - 0.5 * sigma**2) * tau + W_T)\n    payoff = np.maximum(S_T - K, 0)\n\n    call = np.exp(-r*tau) * np.mean(payoff)\n    return call\n```\n:::\n\n\n::: {#66179c1e .cell execution_count=3}\n``` {.python .cell-code}\n# Calcul du prix d'un call lors t=O, T=6mois, S0= 42, K=40, r=10%, sigma=20%\nS0 = 42\nK = 40\nr = 0.1\ntau = 6\nsigma = 0.2\n\ncall_BS = FormulaBS(S0,K,r,tau,sigma)\nprint(f\"Le prix d'un call est de maturité {tau}mois et de strike {K} est de {call_BS}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLe prix d'un call est de maturité 6mois et de strike 40 est de 20.67722481517296\n```\n:::\n:::\n\n\n::: {#e6e11257 .cell execution_count=4}\n``` {.python .cell-code}\nM_values = [500, 5000, 50000]\nfor M in M_values:\n\tcall_BSMC = FormulaBSMC(K, r, tau, sigma, M, S0)\n\tprint(f\"Le prix d'un call avec M={M}, de maturité {tau}mois et de strike {K} est de {call_BSMC}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLe prix d'un call avec M=500, de maturité 6mois et de strike 40 est de 19.957082172959808\nLe prix d'un call avec M=5000, de maturité 6mois et de strike 40 est de 20.739627483854612\nLe prix d'un call avec M=50000, de maturité 6mois et de strike 40 est de 20.859662044258418\n```\n:::\n:::\n\n\n::: {#fe9fe00d .cell execution_count=5}\n``` {.python .cell-code}\n# Calcul du prix d'un call lors t=O, T=3mois, S0= 42, K=40, r=10%, sigma=20%\ntau = 3\ncall_BS = FormulaBS(S0,K,r,tau,sigma)\n\nprint(f\"Le prix d'un call est de maturité {tau}mois et de strike {K} est de {call_BS}\")\n\nfor M in M_values:\n    call_BSMC = FormulaBSMC(K, r, tau, sigma, M, S0)\n    print(f\"Le prix d'un call avec M={M}, de maturité {tau}mois et de strike {K} est de {call_BSMC}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLe prix d'un call est de maturité 3mois et de strike 40 est de 13.362666146646749\nLe prix d'un call avec M=500, de maturité 3mois et de strike 40 est de 14.213018114964639\nLe prix d'un call avec M=5000, de maturité 3mois et de strike 40 est de 13.083277863083655\nLe prix d'un call avec M=50000, de maturité 3mois et de strike 40 est de 13.357151968070482\n```\n:::\n:::\n\n\nComme nous pouvons le constater, les deux méthodes permettent d'avoir des résultats similaires. De plus, plus le nombre de simulations est grand, plus la précision de l'estimation est grande.\n\n### 1.1. Calcul des greeks\n\nLes greeks sont des indicateurs qui permettent de mesurer la sensibilité du prix d'une option à différents paramètres. Les principaux greeks sont :\n\n- Delta : mesure la sensibilité du prix de l'option par rapport au prix de l'actif sous-jacent\n$$\n\\Delta = \\frac{\\partial C}{\\partial S}\n$$\n- Gamma : mesure la sensibilité du delta par rapport au prix de l'actif sous-jacent\n$$\n\\Gamma = \\frac{\\partial^2 C}{\\partial S^2}\n$$\n- Vega : mesure la sensibilité du prix de l'option par rapport à la volatilité de l'actif\n$$\nVega = \\frac{\\partial C}{\\partial \\sigma}\n$$\n\nIl en existe d'autres, mais ces trois-là sont les plus couramment utilisés.\n\nAvec le modèle de Black-Scholes, on peut calculer ces greeks de manière analytique :\n\n$$\n\\Delta = N(d_1)\n$$\n\n$$\n\\Gamma = \\frac{N(d_1)}{S_t \\sigma \\sqrt{T}}\n$$\n\n$$\nVega = S_t \\sqrt{T} N(d_1)\n$$\n\nCependant, lorsqu'on a pas accès à une formule analytique pour le prix de l'option, on peut utiliser la méthode de Monte-Carlo pour estimer ces greeks. Pour cela, on calcule le prix de l'option pour une petite variation de chaque paramètre, et on fait la différence entre ces deux prix pour obtenir une estimation du greek. On peut également utiliser la méthode des différences finies pour calculer ces greeks.\n\n::: {#3bc15047 .cell execution_count=6}\n``` {.python .cell-code}\ndef FormulaBSGreeks(S,K,r,tau,sigma):\n    d1 = (np.log(S/K) + (r + 0.5 *sigma**2)*tau ) / (sigma * np.sqrt(tau))\n    # d2 = d1 - sigma * np.sqrt(tau)\n\n    delta = norm.cdf(d1)\n    gamma = (1/(S*sigma*np.sqrt(tau))) * norm.pdf(d1)\n    vega = S * np.sqrt(tau) * norm.pdf(d1)\n\n    return delta, gamma, vega\n```\n:::\n\n\n::: {#cfe003ee .cell execution_count=7}\n``` {.python .cell-code}\nS = 100\nK = 110\nr = 0.1\ntau = 0.5\nsigma = 0.2\n\ndelta, gamma, vega = FormulaBSGreeks(S=S,K=K,r=r,tau=tau,sigma=sigma)\nprint(f\"Les greeks d'un call sont de maturité {tau}mois et de strike {K} sont delta={delta}, gamma={gamma}, vega={vega}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLes greeks d'un call sont de maturité 0.5mois et de strike 110 sont delta=0.40141715171302983, gamma=0.027343746144537384, vega=27.343746144537384\n```\n:::\n:::\n\n\n::: {#405d8b6e .cell execution_count=8}\n``` {.python .cell-code}\n# Supposons qu'on a pas la formule des greeks\n# comment calculer les greeks\n# Approche montecarlo \n\ndef FormulaBSGreeksMC(K,r,tau,sigma,M, S0) :\n    d1 = (np.log(S/K) + (r + 0.5 *sigma**2)*tau) / (sigma * np.sqrt(tau))\n    # Simulation du M mouvement brownien de loi N(0, sigma*sqrt(T))\n    var_brown = sigma * np.sqrt(tau)\n    W_T= np.random.normal(0,var_brown,M)\n\n    S_T = S0 * np.exp((r - 0.5 * sigma**2) * tau + W_T)\n\n    delta = np.exp(-r*tau) * np.mean((S_T > K) * S_T / S0)\n    gamma = norm.pdf(d1)/(S0 * sigma * np.sqrt(tau))\n    vega = np.exp(-r*tau) * np.mean((S_T > K) * (S_T/sigma) *(np.log(S_T/S0) - (r + 0.5 * sigma**2)*tau))\n\n    return delta, gamma, vega\n\ndelta, gamma, vega = FormulaBSGreeksMC(K,r,tau,sigma,500, S)\nprint(f\"Les greeks d'un call sont de maturité {tau}mois et de strike {K} sont delta={delta}, gamma={gamma}, vega={vega}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLes greeks d'un call sont de maturité 0.5mois et de strike 110 sont delta=0.4115075330389585, gamma=0.027343746144537384, vega=27.20701198133927\n```\n:::\n:::\n\n\n::: {#8c4e0afd .cell execution_count=9}\n``` {.python .cell-code}\n# Mérhode de différencee finie basé sur la méthode de Taylor\ndef FormulaBSGreeks_FD_num(S, K, r, tau, sigma, delta_S=1e-5):\n    \"\"\"\n    Calcule les Grecs (Delta, Gamma, Vega) pour une option call\n    par différences finies.\n\n    Paramètres:\n    S : float - Prix actuel de l'actif sous-jacent\n    K : float - Prix d'exercice de l'option (strike)\n    r : float - Taux d'intérêt sans risque (annualisé)\n    tau : float - Temps jusqu'à la maturité (en années)\n    sigma : float - Volatilité de l'actif sous-jacent (annualisée)\n    epsilon : float - Petit incrément pour les différences finies\n\n    Retour:\n    tuple - (Delta, Gamma, Vega)\n    \"\"\"\n    # Delta\n    delta = (FormulaBS(S + delta_S, K, r, tau, sigma) - FormulaBS(S - delta_S, K, r, tau, sigma)) / (2 * delta_S)\n\n    # Gamma\n    gamma = (FormulaBS(S + delta_S, K, r, tau, sigma) - 2 * FormulaBS(S, K, r, tau, sigma) + FormulaBS(S - delta_S, K, r, tau, sigma)) / (delta_S**2)\n\n    # Vega\n    vega = (FormulaBS(S, K, r, tau, sigma + delta_S) - FormulaBS(S, K, r, tau, sigma - delta_S)) / (2 * delta_S)\n\n    return delta, gamma, vega\n\ndelta, gamma, vega = FormulaBSGreeks_FD_num(S,K,r,tau,sigma)\nprint(f\"Les greeks d'un call sont de maturité {tau}mois et de strike {K} sont delta={delta}, gamma={gamma}, vega={vega}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLes greeks d'un call sont de maturité 0.5mois et de strike 110 sont delta=0.4014171516075748, gamma=0.027142732506035824, vega=27.34374614092871\n```\n:::\n:::\n\n\n### 1.2 Calibration du modèle BS : calcul de la volatilité implicite\n\nL'intérêt du modèle de Black-Scholes est qu'il permet de calculer la volatilité implicite d'un actif à partir du prix de l'option. En effet, si on connait le prix de l'option, le prix de l'actif sous-jacent, le prix d'exercice de l'option, la maturité de l'option et le taux d'intérêt sans risque, on peut calculer la volatilité implicite en résolvant l'équation de Black-Scholes pour $\\sigma$ :\n\n$$\nC(S_t, K, T, r, \\sigma) = S_t N(d_1) - K e^{-rT} N(d_2)\n$$\n\n::: {#24d643f6 .cell execution_count=10}\n``` {.python .cell-code}\ndef ImpliedVolBS(S,K,r,tau, Call):\n    # optim function\n    def obj_func(sigma):\n        return (Call - FormulaBS(S,K,r,tau,sigma))**2\n    \n    res = minimize(obj_func, 0.2)\n    sigma = res.x[0]\n    return sigma\n\n```\n:::\n\n\n::: {#aa1c464d .cell execution_count=11}\n``` {.python .cell-code}\n# Calcul de la volatilité d'une option d'achat à la monnaie de maturité 3 mois et de strike K=S=4.58 sachant que S0=100; r=5%\n\nS = 100\nK = 100\nr = 0.05\ntau = 3/12\nCall = 4.58\nsigma = ImpliedVolBS(S,K,r,tau, Call)\n\nprint(f\"La volatilité implicite d'un call est de maturité {tau}mois et de strike {K} est de {sigma}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLa volatilité implicite d'un call est de maturité 0.25mois et de strike 100 est de 0.19821832844648876\n```\n:::\n:::\n\n\n::: {#efd533c2 .cell execution_count=12}\n``` {.python .cell-code}\n# Calcul de la volatilité d'une option d'achat à la monnaie de maturité 6 mois et de strike K=S=5.53 sachant que S0=100; r=5%\n\nS = 100\nK = 100\nr = 0.05\ntau = 0.5\nCall = 5.53\nsigma = ImpliedVolBS(S,K,r,tau, Call)\n\nprint(f\"La volatilité implicite d'un call est de maturité {tau}mois et de strike {K} est de {sigma}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLa volatilité implicite d'un call est de maturité 0.5mois et de strike 100 est de 0.15010660990708588\n```\n:::\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /Users/cherylkouadio/Library/Python/3.9/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.9.6\n---\n",
    "supporting": [
      "modele_bs_files/figure-ipynb"
    ],
    "filters": []
  }
}