{
  "hash": "d79c714594ad8c0991413ea2bf4003d5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Calibration avec le modèle d'Heston\"\nformat: html\nauthor: \"Cheryl KOUADIO\"\ndate: \"2025-02-06\"\n---\n\n\n\n\n\nLe but de ce TP est de calculer des prix d’options sous le modèle d’Heston puis de calibrer ce modèle par filtrage. On considère le modèle suivant :\n\n$$\n\\begin{cases}\ndS_s = S_s \\left( rds + \\sqrt{v_s} dW_s^1 \\right) \\\\\ndv_s = \\kappa (\\beta - v_s) ds + \\sigma \\sqrt{v_s} dW_s^2 \\\\\ndW_s^1 dW_s^2 = \\rho ds\n\\end{cases}\n\\quad (1)\n$$\n\noù $W_s^1$ et $W_s^2$ sont deux mouvements browniens et $r$ est le taux sans risque. Pour ce modèle, les rendements sont modélisés par un mouvement brownien géométrique avec une variance stochastique.\n\nLa volatilité non observée $v_t$ est déterminée par un processus stochastique de retour à la moyenne (1) introduit en 1985 par Cox, Ingersoll et Ross pour la modélisation des taux d’intérêt à court terme.\n\nLe paramètre $\\kappa$ est le paramètre de retour à la moyenne positive, $\\beta$ est le paramètre positif à long terme et $\\eta$ la volatilité positive du paramètre de variance. De plus, Heston a introduit une corrélation entre les deux mouvements browniens $W_s^1$ et $W_s^2$, représentée par le paramètre $\\rho$ appartenant à $[-1,1]$.\n\n# Pricing d'un call\n\n## Avec la forme close\n\nSoit un Call de strike K et à échéance $\\tau$ sous le modèle (1) avec les paramètres suivants : $\\kappa$ = 4,$\\beta$ = 0.03,$\\sigma$ = 0.4,r =0.05,$\\rho$=−0.5,$\\tau$ = 1, $S_0$ = K=100,$v_0$ = $\\beta$.\n\nPour calculer le prix d'un Call, on peut utiliser la formule close de Heston (Heston 1993) :\n\n$$\nC(S_0, K, \\tau) = S_0 P_1 - K e^{-r \\tau} P_2\n$$\n\navec :\n\n$$\nP_j(x, \\nu, T, \\ln(K)) = \\frac{1}{2} + \\frac{1}{\\pi} \\int_0^\\infty \\Re \\left( \\frac{e^{-i \\ln(K) u} f_j(x,\\nu,t,u)}{i u} \\right) du\n$$\n\noù :\n\n$$\nx = \\ln(S_t), \\quad f(x,\\nu,t,u) = \\exp(C(t,u) + D(t,u) \\nu + i \\phi x)\n$$\n\net :\n\n$$\nC(T-t = \\tau, \\phi) = r i \\phi t + \\frac{a}{\\sigma^2} \\left( (bj - \\rho \\sigma \\phi i + d)\\tau - 2 \\ln \\left( \\frac{1 - g e^{d \\tau}}{1 - g} \\right) \\right)\n$$\n\n$$\nD(T-t = \\tau, \\phi) = \\left( \\frac{bj - \\rho \\sigma \\phi i + d}{\\sigma^2} \\right) \\left( \\frac{1 - e^{d \\tau}}{1 - g e^{d \\tau}} \\right)\n$$\n\n$$\ng = \\frac{bj - \\rho \\sigma \\phi i + d}{bj - \\rho \\sigma \\phi i - d}\n$$\n\n$$\nd = \\sqrt{(\\rho \\sigma \\phi i - bj)^2 - \\sigma^2 (2 u_j \\phi i - \\phi^2)}\n$$\n\n$$\nu_1 = 1/2, \\quad u_2 = -1/2, a = \\lambda, b = \\kappa \\beta, \\quad t_1 = \\kappa - \\rho \\sigma, \\quad t_2 = \\kappa\n$$\n\nPour ce faire, nous allons utiliser la fonction `Heston_Call_Function.R` qui permet de calculer le prix d'un Call sous le modèle d'Heston avec la formule close.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Paramètres\nkappa <- 4\nbeta <- 0.03\nsigma <- 0.4\nr <- 0.05\nrho <- -0.5\ntau <- 1\nS0<- 100\nK <- 100\nv0 <- beta\n\n# Import Heston_Call_Function.R\nsource(\"data/Heston_Call_Function.R\")\n\n# Calcul du prix du Call\nCall_Heston <- HestonCallClosedForm(lambda = kappa, vbar = beta, eta = sigma, rho = rho, v0 = v0, r = r, tau = tau, S0 = S0, K = K)\ncat(\"Le prix du Call est de \", Call_Heston)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLe prix du Call est de  9.410405\n```\n\n\n:::\n:::\n\n\n\n## Avec la méthode de Monte Carlo (Schéma d'Euler)\n\nLorsqu'on a pas accès à la formule close, on peut utiliser la méthode de Monte Carlo pour calculer le prix d'un Call. Il s'agit de simuler le modèle (1) et de calculer le prix du Call à partir des simulations. Pour simuler le modèle (1), on peut utiliser la discrétisation d'Euler du modèle de Heston (Euler and Milstein Discretization, Fabrice Douglas Rouah) ou utiliser la formule de Ito pour le modèle de Heston.\n\nDans notre cas, nous allons utiliser la discrétisation d'Euler du modèle de Heston pour simuler le modèle (1) comme suit : \n$$\n\\begin{cases}\nS_t = S_{t-1} \\left(1 + r \\Delta + \\sqrt{\\Delta v_t} W_t^1 \\right) \\\\[10pt]\nv_t = \\left| v_{t-1} + \\kappa \\Delta (\\beta - v_{t-1}) + \\sigma \\sqrt{v_{t-1}} \\Delta W_t^2 \\right| \\\\[10pt]\n\\text{Cov}(W_t^1, W_t^2) = \\rho\n\\end{cases}\n$$\n\navec $W_t^1$ et $W_t^2$ des variables aléatoires gaussiennes centrées réduites et corrélées entre elles telles que $\\text{Cov}(W_t^1, W_t^2) = \\rho$. De plus, $\\Delta = \\frac{\\tau}{n}$ est le pas de discrétisation, avec $n$ le nombre de pas de discrétisation.\n\nDans notre cas, on définit $n = 100$ et on simule $M = 1000$ modèle (1) pour calculer le prix d'un Call.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHestonCallMC <- function(M, N, lambda, vbar, eta, rho, v0, r, tau, S0, K){\n  # M: Number of Monte Carlo simulations\n  # N: Number of time steps\n  \n  set.seed(123)\n  dt <- tau / N  # Time step\n\n  # Store final stock prices\n  ST <- numeric(M)\n  \n  for (i in 1:M){\n    S <- numeric(N+1)\n    v <- numeric(N+1)\n    \n    S[1] <- S0\n    v[1] <- v0\n    \n    for (t in 1:N){\n      # Generate correlated Brownian motions\n      W1 <- rnorm(1)\n      W2 <- rho * W1 + sqrt(1 - rho^2) * rnorm(1)\n      \n      # Euler discretization of variance process (ensure non-negativity)\n      v[t+1] <- abs(v[t] + lambda * (vbar - v[t]) * dt + eta * sqrt(v[t] * dt) * W1)\n      \n      # Euler discretization of the stock price process (log-normal form)\n      S[t+1] <- S[t] * exp((r - 0.5 * v[t]) * dt + sqrt(v[t] * dt) * W2)\n    }\n    \n    # Store final stock price\n    ST[i] <- S[N+1]\n  }\n\n  # Compute Call option price using Monte Carlo method\n  Call <- exp(-r * tau) * mean(pmax(ST - K, 0), na.rm=TRUE)\n  \n  return(Call)\n}\n\nM <- 1000\nN <- 100\nCall_Heston <-HestonCallMC(M,N, kappa, beta, sigma, rho, v0, r, tau, S0, K)\ncat(\"Le prix du Call est de \", Call_Heston)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLe prix du Call est de  9.797915\n```\n\n\n:::\n:::\n\n\n\n# Calibration du modèle d'Heston avec les prix d'options\n\nOn souhaite désormais calibrer la volatilité sous le modèle d’Heston à partir de prix d’options. Pour cela, nous considérons la version discrétisée par un schéma d’Euler (modifié) de (1). Plus précisément, soit :\n\n$$\n\\begin{cases}\ny_t = C(t, \\theta, v_t, S_t, K, \\tau) + \\sigma_\\varepsilon \\varepsilon_t \\\\[10pt]\nS_t = S_{t-1} \\left(1 + r \\Delta + \\sqrt{\\Delta v_t} Z_t^1 \\right) \\\\[10pt]\nv_t = \\left| v_{t-1} + \\lambda \\Delta (\\bar{v} - v_{t-1}) + \\eta \\sqrt{v_{t-1}} \\Delta Z_t^2 \\right| \\\\[10pt]\n\\text{Cov}(Z_t^1, Z_t^2) = \\rho\n\\end{cases}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importation des données\nrm(list=ls())\ny <- read.csv(\"data/dataP_B.csv\")\nS <- read.csv(\"data/dataS.csv\")\nv <- read.csv(\"data/dataV.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(y$HestonPB, type=\"l\", col=\"blue\",  main=\"Prix des Calls\")\n```\n\n::: {.cell-output-display}\n![](modele_heston_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(S$Sous_jacent, type=\"l\", col=\"red\",main=\"Prix du sous-jacent\")\n```\n\n::: {.cell-output-display}\n![](modele_heston_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(v$Var, type=\"l\", col=\"green\", main=\"Volatilité obs.\")\n```\n\n::: {.cell-output-display}\n![](modele_heston_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nPrenons $\\theta = (\\kappa = 4, \\sigma = 0.4, \\beta = 0.03, \\rho = -0.5)$, $\\sigma_\\varepsilon = 0.1$, $\\tau=1$ et $K=100$. Pour estimer la volatilité, nous allons utiliser un filtre particulaire bootstrap. Il est défini comme suit :\n\n![Filtre bootstrap particulaire](data/bootstrap_filter.png)\n\nLa loi stationnaire de $v_t$ est une loi gamma de paramètres $\\alpha_1 = \\frac{2 \\kappa \\beta}{\\sigma^2}$ et $\\alpha_2 = \\frac{\\sigma^2}{2 \\kappa}$.\n\nDe plus, la densité de transition de $v_t | v_{t-1}$ est une loi normale de moyenne $v_{t-1} + \\kappa (\\beta - v_{t-1}) \\tau$ et de variance $\\sigma \\sqrt{v_{t-1} \\tau}$. En effet, nous utilisons le schéma d'Euler pour simuler $v_t$.\n\nEn ce qui concerne la loi de $y_t | v_t$, on suppose que $y_t$ suit une loi normale de moyenne $C(t, \\theta, v_t, S_t, K, \\tau)$ et de variance $\\sigma_\\varepsilon^2$.\n\nAinsi, nous initialisons les particules $v_0$ selon la loi stationnaire de $v_t$ et nous utilisons le schéma d'Euler pour simuler $v_t$ et $S_t$. Ensuite, nous calculons les poids des particules en utilisant la vraisemblance de l'observation $y_t$ et nous rééchantillonnons les particules selon leurs poids. Enfin, nous estimons la volatilité $v_t$ à l'instant $t$ en utilisant les particules rééchantillonnées.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definition des variables\ny <- y$HestonPB\nS <- S$Sous_jacent\nv<- v$Var\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\n# Définition des paramètres theta\nkappa <- 4\nsigma <- 0.4\nbeta <- 0.03\nrho <- -0.5\nsigma_epsilon <- 0.1\ntau <- 1\nK <- 100\nr <- 0.05\n\n# Import Heston_Call_Function.R\nsource(\"data/Heston_Call_Function.R\")\n\n\n# Paramètres loi stationnaire de v\nalpha1 <- (2*kappa*beta)/(sigma^2)\nalpha2 <- (sigma^2)/(2*kappa)\n\n# Initialisation des paramètres\nn <- length(y)  # Nombre d'observations\nM <- 1000      # Nombre de particules\n\n# Initialisation des matrices et vecteurs\nv_hat <- numeric(n)                   # Estimation de x\nv_particle <- matrix(nrow = n, ncol = M)  # Particules\nw <- matrix(nrow = n, ncol = M)        # Poids des particules\nw_normalized <- matrix(nrow = n, ncol = M) # Poids normalisés\n\n# Filtre particulaire bootstrap\nfor (t in 1:n) {\n  if (t == 1) {\n    # Initialisation des particules à t = 0\n    v_particle[t, ] <- rgamma(M, shape = alpha1, rate = 1/alpha2)\n    \n    # Poids initiaux (basés sur la distribution de l'état initial)\n    w[t, ] <- dgamma(v_particle[t, ], shape = alpha1, rate = 1/alpha2)\n    \n    # Normalisation des poids\n    w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n    \n    # Estimation initiale\n    v_hat[t] <- sum(w_normalized[t, ] * v_particle[t, ])\n  } else {\n    #  Étape de prédiction (échantillonnage de nouvelles particules)\n    v_particle[t,] <- abs(rnorm(M, mean = v_particle[t-1, ] + kappa * (beta - v_particle[t-1, ]) * tau, sd = sigma * sqrt(v_particle[t-1, ] * tau)))\n    \n    #  Calcul du prix du Call pour chaque particule\n    C <- numeric(M)\n    for (i in 1:M) {\n      C[i] <- HestonCallClosedForm(lambda = kappa, vbar = beta, eta = sigma, rho = rho, v0 = v_particle[t,i], r = r, tau = tau, S0 = S[t], K = K)\n    }\n    \n    #  Mise à jour des poids avec la vraisemblance de l'observation\n    w[t, ] <- dnorm(y[t], mean = C , sd = sqrt(sigma_epsilon))\n    \n    #  Normalisation des poids\n    w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n    \n    #  Rééchantillonnage des particules selon leurs poids\n    index <- sample(1:M, size = M, prob = w_normalized[t, ], replace = TRUE)\n    v_particle[t, ] <- v_particle[t, index]\n    \n    # Réinitialisation des poids après rééchantillonnage (uniforme)\n    w_normalized[t, ] <- 1 / M\n    \n    #  Estimation de x à l'instant t (pondérée)\n    v_hat[t] <- sum(w_normalized[t, ] * v_particle[t, ])\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(v, type = \"l\", col = \"black\",  main = \"Estimation de la volatilité avec un filtre bootstrap\",xlab = \"Temps\", ylab = \"Volatilité\")\nlines(v_hat, type = \"l\", col = \"red\")\n\nlegend(\"topright\", legend = c(\"Vol. obs.\", \"Vol. est.\"), col = c(\"black\", \"red\"), lty = 1)\n```\n\n::: {.cell-output-display}\n![](modele_heston_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}