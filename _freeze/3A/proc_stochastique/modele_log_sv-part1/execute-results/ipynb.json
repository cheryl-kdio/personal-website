{
  "hash": "75c6693acadb00285d7845878990b66b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Calibration du modèle à volatilité stochastique de Taylor : Filtre de Kalman\"\nauthor: Cheryl KOUADIO\njupyter: python3\ndate: \"2025-01-14\"\n---\n\n\n\n\n\n\n\n# Calibration du modèle à volatilité stochastique de Taylor - Filtre de Kalman\n\nLe modèle à volatilité stochastique de Taylor est un modèle de volatilité stochastique qui est utilisé pour modéliser la volatilité des actifs financiers. Le modèle est défini par l'équation suivante :\n\n$$\n\\begin{aligned}\nr_t &= \\exp(x_t/2) \\cdot \\varepsilon_t, \\quad \\varepsilon_t \\sim \\text{N}(0,1) \\\\\nx_t &= \\mu + \\phi \\cdot x_{t-1} + \\sigma_t \\cdot \\eta_t\n\\end{aligned}\n$$\n\noù $r_t$ est le rendement de l'actif financier à l'instant $t$, $x_t$ est la volatilité de l'actif financier à l'instant $t$, $\\mu$ est la moyenne de la volatilité, $\\phi$ est le coefficient d'autorégression, $\\sigma_t$ est l'écart-type de la volatilité à l'instant $t$, $\\eta_t$ est un bruit blanc gaussien, et $\\varepsilon_t$ est un bruit blanc gaussien.\n\nPour extraire la volatilité, nous utilisons le filtre de Kalman sur le logarithme des rendements au carré $y_t = \\log(r_t^2)$, afin de linéariser le modèle. Le modèle linéarisé est défini par l'équation suivante :\n\n$$\ny_t = x_t + \\varepsilon_t\n$$\n\noù $y_t$ est le logarithme des rendements au carré à l'instant $t$, $x_t$ est la volatilité de l'actif financier à l'instant $t$, et $\\varepsilon_t$ est un bruit blanc de loi log-$\\chi^2$.\n\nDe ce fait, nous pouvons utiliser le filtre de Kalman pour estimer la volatilité de l'actif financier en utilisant les rendements observés. En effet, le filtre de Kalman est un algorithme récursif qui permet d'estimer l'état caché d'un système dynamique à partir d'observations bruitées. Il s'applique à des modèles linéaires dont le bruit est gaussien. Dans notre cas, nous avons linéarisé le modèle pour qu'il soit compatible avec le filtre de Kalman. Cependant, le bruit n'est pas gaussien, mais log-$\\chi^2$. L'objectif de ce notebook est d'observer le comportement du filtre de Kalman où le bruit n'est pas gaussien.\n\nNous possédons déjà d'un fichier avec les rendements de l'actif financier et la vraie volatilité simulés avec les paramètres suivants $\\mu = -0.8$, $\\phi = 0.9$, $\\sigma = 0.09$. Nous allons donc utiliser ces données pour estimer la volatilité de l'actif financier en utilisant le filtre de Kalman. Néanmoins, le code est également fourni pour simuler les données si vous souhaitez tester le filtre de Kalman sur d'autres paramètres.\n\n::: {#8e1bac71 .cell execution_count=1}\n``` {.python .cell-code}\n# Simulation d'un modèle à vol stochastique de Taylor\n\n# r_t = exp(x_t/2)*eps_t (eps_t iid N(0,1))\n# x_t = mu + phi * x_{t-1} + sigma_t * eta_t  (eta_t iid N(0,1))\n\nimport numpy as np\nimport pandas as pd\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Paramètres\nn = 252\nmu = -0.8\nphi = 0.9\nsigma_squared = 0.09\n\n# Simulation\n# np.random.seed(0)\n\n# x = np.zeros(n)\n# r = np.zeros(n)\n\n# for t in range(0, n):\n#     if t == 0:\n#         x[t] = np.random.normal(loc= mu/(1-phi), scale=np.sqrt(sigma_squared/(1-phi**2))) # Densité de transition stationnaire de x_t\n#     else:\n#         x[t] = mu + phi * x[t-1] + np.sqrt(sigma_squared) * np.random.normal(loc=0, scale=1)\n#     r[t] = np.exp(x[t]/2) * np.random.normal(loc=0, scale=1)\n\ndata  = pd.read_csv('true_sv_taylor.csv')\nr = data['r']\nx = data['x']\n```\n:::\n\n\n::: {#46482cec .cell execution_count=2}\n``` {.python .cell-code}\n# Affichage des trajectoires\nimport matplotlib.pyplot as plt\n\nplt.plot(r, color=\"black\")\nplt.title(\"Trajectoire des rendements\")\nplt.show()\n\nplt.plot(x, color='red')\nplt.title(\"Trajectoire de log-volatilité\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](modele_log_sv-part1_files/figure-ipynb/cell-3-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-display}\n![](modele_log_sv-part1_files/figure-ipynb/cell-3-output-2.png){}\n:::\n:::\n\n\n::: {#16b74857 .cell execution_count=3}\n``` {.python .cell-code}\n# Construction du modèle log-SV (modèle de Taylor)\n\n# Pour appliquer le filtre de Kalman, il faut que les bruits soient centrés.\nmu_r_squared = -1.27 # car log(eps**2) suit une log chi-deux\ny = np.log(r**2) - mu_r_squared\n```\n:::\n\n\n## Filtre de Kalman avec paramètres connus\n\nLe filtre de Kalman fonctionne en deux étapes : prédiction et mise à jour. La prédiction consiste à prédire l'état caché du système à l'instant $t$ en utilisant les observations jusqu'à l'instant $t-1$. La mise à jour consiste à mettre à jour l'estimation de l'état caché en utilisant l'observation à l'instant $t$. \nPosons :\n\n- $x_{\\text{hat}[t]}$ l'estimation de la volatilité à l'instant $t$, \n- $P[t]$ la matrice de covariance de l'estimation de la volatilité à l'instant $t$, \n- $x_{\\text{hat\\_m}}$ la prédiction de la volatilité à l'instant $t$, \n- $P_m$ la matrice de covariance de la prédiction de la volatilité à l'instant $t$, \n- $y[t]$ l'observation à l'instant $t$,\n- $K$ le gain de Kalman.\n\n\n$$\n\\begin{aligned}\n\\text{Prédiction} & : \\\\\nx_{\\text{hat\\_m}} &= \\mu + \\phi \\cdot x_{\\text{hat}[t-1]} \\\\\nP_m &= \\phi^2 \\cdot P[t-1] + \\sigma^2 \\\\\ny_m &= x_{\\text{hat\\_m}} \\\\\n\n\\text{Mise à jour} & : \\\\\nK &= \\frac{P_m}{P_m + \\pi^2/2} \\\\\nP[t] &= (1 - K) \\cdot P_m \\\\\nx_{\\text{hat}[t]} &= x_{\\text{hat\\_m}} + K \\cdot (y[t] - y_m)\n\\end{aligned}\n$$\n\nPour initialiser le filtre de Kalman, il est conseillé de connaitre la loi stationnaire de la volatilité. En effet, la volatilité suit une loi normale stationnaire de paramètre $\\mu/(1 - \\phi)$ et $\\sigma^2/(1 - \\phi^2)$. Par conséquent, nous pouvons initialiser le filtre de Kalman avec ces paramètres. En ce qui concerne la matrice de covariance de l'état initial, nous pouvons la fixer à une valeur élevée, par exemple $10^2$.\n\nDans notre cas, nous allons tester deux initialisations différentes : une initialisation avec les paramètres stationnaires et une initialisation avec des paramètres aléatoires.\n\n::: {#86709f98 .cell execution_count=4}\n``` {.python .cell-code}\n# Script de filtre de kalman pour estimer la volatilité à chaque instant t en supposant les paramètres connus\n\ndef kalman_filter(y, mu, phi, sigma_squared, n, init_x, init_P):\n    x_hat = np.zeros(n)\n    P = np.zeros(n)\n\n    # Initialisation\n    x_hat[0] = init_x\n    P[0] = init_P # Plus P est grand moins on fait confiance à l'apriori sur la valeur de la volatilité\n\n    for t in range(1, n):\n        # Prédiction\n        x_hat_m = mu + phi * x_hat[t-1] \n        P_m = phi**2 * P[t-1] + sigma_squared\n        y_m = x_hat_m\n\n        # Mise à jour\n        K = P_m / (P_m + (np.pi**2)/2)\n        P[t] = (1 - K) * P_m\n        x_hat[t] = x_hat_m + K * (y[t] - y_m)\n    return x_hat, P, K\n```\n:::\n\n\n::: {#6131bac1 .cell execution_count=5}\n``` {.python .cell-code}\n# Initialisation à 0 et 0.01\ninit_x = 0\ninit_P = 0.01\nx_hat, P, K = kalman_filter(y, mu, phi, sigma_squared, n, init_x, init_P)\nplt.plot(x_hat, color='grey', label='Volatilité estimée')\n```\n\n::: {.cell-output .cell-output-display}\n![](modele_log_sv-part1_files/figure-ipynb/cell-6-output-1.png){}\n:::\n:::\n\n\n::: {#a9812623 .cell execution_count=6}\n``` {.python .cell-code}\n# Initialisation à x_0 et sigma_squared/(1-phi**2)\ninit_x = x[0]\ninit_P = sigma_squared/(1-phi**2)\nx_hat, P, K = kalman_filter(y, mu, phi, sigma_squared, n, init_x, init_P)\nplt.plot(x_hat, color='red', label='Volatilité estimée')\nplt.plot(x, color='grey', label = 'Volatilité réelle')\nplt.legend()\n\n\n# Compute MSE, MAE, and RMSE\nmse = np.mean((x - x_hat)**2)\nmae = np.mean(np.abs(x - x_hat))\nrmse = np.sqrt(mse)\nprint(\"MSE = \", mse)\nprint(\"MAE = \", mae)\nprint(\"RMSE = \", rmse)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMSE =  0.2794557366826766\nMAE =  0.4120099778966342\nRMSE =  0.5286357315606622\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](modele_log_sv-part1_files/figure-ipynb/cell-7-output-2.png){}\n:::\n:::\n\n\n::: {#2beceadf .cell execution_count=7}\n``` {.python .cell-code}\n# Initialisation à mu/(1-phi) et sigma_squared/(1-phi**2)\ninit_x = mu/(1-phi)\ninit_P = sigma_squared/(1-phi**2)\nx_hat, P, K = kalman_filter(y, mu, phi, sigma_squared, n, init_x, init_P)\nplt.plot(x_hat, color='red', label='Volatilité estimée')\nplt.plot(x, color='grey', label = 'Volatilité réelle')\nplt.legend()\n\n# Compute MSE, MAE, RMSE\nmse = np.mean((x - x_hat)**2)\nmae = np.mean(np.abs(x - x_hat))\nrmse = np.sqrt(mse)\nprint(\"MSE = \", mse)\nprint(\"MAE = \", mae)\nprint(\"RMSE = \", rmse)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMSE =  0.27543214871007066\nMAE =  0.4078063371140131\nRMSE =  0.5248162999660649\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](modele_log_sv-part1_files/figure-ipynb/cell-8-output-2.png){}\n:::\n:::\n\n\n## Filtre de Kalman avec paramètres inconnus\n\nDans le cas où les paramètres du modèle sont inconnus, nous pouvons les estimer en utilisant le filtre de Kalman. En effet, nous pouvons utiliser l'algorithme EM pour estimer les paramètres du modèle. L'algorithme EM est un algorithme itératif qui permet d'estimer les paramètres d'un modèle en maximisant la vraisemblance des données observées. Dans notre cas, nous allons utiliser l'algorithme EM pour estimer les paramètres $\\mu$, $\\phi$ et $\\sigma$ du modèle.\n\n::: {#4b870125 .cell execution_count=8}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Define the log-likelihood function for the log-SV model with Kalman filter\ndef log_sv_kalman(params, y):\n    # Extract parameters\n    mu, phi, sigma_eta = params\n\n    # Number of observations\n    n = len(y)\n\n    # Initialize state and variance\n    x_t = mu  # Initial state (log-volatility)\n    P_t = sigma_eta**2 / (1 - phi**2)  # Initial variance (stationarity assumption)\n\n    # Log-likelihood accumulator\n    log_likelihood = 0\n\n    for t in range(n):\n        # Observation equation: y_t ~ x_t + nu_t\n\n        # Prediction step\n        y_t_pred = x_t\n        F_t = P_t + np.pi**2 / 2  # Variance of observation noise\n\n        # Update step\n        v_t = y[t] - y_t_pred  # Prediction error\n        K_t = P_t / F_t  # Kalman gain\n        x_t = x_t + K_t * v_t\n        P_t = (1 - K_t) * P_t + sigma_eta**2  # Update variance\n\n        # Update log-likelihood\n        log_likelihood += -0.5 * (np.log(2 * np.pi) + np.log(F_t) + (v_t**2 / F_t))\n\n        # State evolution\n        x_t = mu + phi * (x_t - mu)  # State equation\n\n    return -log_likelihood  # Negative log-likelihood for minimization\n\n# Initial parameter guesses\ninitial_params = [-0.7, 0.8, np.sqrt(0.05)]\n\n# Constrain phi between -1 and 1 and sigma_eta > 0\nbounds = [(-np.inf, np.inf), (-1, 1), (1e-6, np.inf)]\n\n# Optimize parameters using the log-likelihood function\nresult = minimize(log_sv_kalman, initial_params, args=(y,), bounds=bounds, method='L-BFGS-B')\n\n# Extract estimated parameters\nmu_est, phi_est, sigma_eta_est = result.x\n\n# Print results\nprint(\"Estimated parameters:\")\nprint(f\"mu: {mu_est:.4f}\")\nprint(f\"phi: {phi_est:.4f}\")\nprint(f\"sigma_eta: {sigma_eta_est:.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEstimated parameters:\nmu: -0.8021\nphi: 0.8001\nsigma_eta: 1.2184\n```\n:::\n:::\n\n\n---\njupyter:\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n    path: /Users/cherylkouadio/Library/Python/3.9/share/jupyter/kernels/python3\n  language_info:\n    codemirror_mode:\n      name: ipython\n      version: 3\n    file_extension: .py\n    mimetype: text/x-python\n    name: python\n    nbconvert_exporter: python\n    pygments_lexer: ipython3\n    version: 3.9.6\n---\n",
    "supporting": [
      "modele_log_sv-part1_files/figure-ipynb"
    ],
    "filters": []
  }
}