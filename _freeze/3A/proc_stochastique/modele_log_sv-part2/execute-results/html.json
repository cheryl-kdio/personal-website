{
  "hash": "3c59b0433ae658094be70c5fd326fc8f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Calibration du modèle à volatilité stochastique de Taylor : Filtre particulaire\"\nauthor: \"Cheryl Kouadio\"\ndate: \"2025-01-21\"\n---\n\n\n\n\n\n# Estimation du modèle SV de Taylor par filtrage particulaire (Part 2-a)\n\nLe modèle classique de volatilité stochastique est défini par les équations suivantes :\n\n1. **Processus des rendements** :\n   \n   $$ r_t = \\exp(x_t / 2) \\cdot \\varepsilon_t, \\quad \\varepsilon_t \\sim N(0,1) $$\n\n2. **Processus de la volatilité logarithmique** :\n\n   $$ x_t = \\mu + \\phi x_{t-1} + \\sigma_t \\eta_t, \\quad \\eta_t \\sim N(0,1) $$\n\n- \\( x_t \\) suit un processus autorégressif de premier ordre (**AR(1)**) et suit une distribution normale conditionnelle :\n  $$ p(x_t) \\sim N(\\frac{\\mu}{1-\\phi} , \\frac{\\sigma_t^2}{1-\\phi^2}) $$\n\n  $$ x_t | x_{t-1} \\sim N(\\mu + \\phi x_{t-1}, \\sigma_t^2) $$\n- \\( r_t \\) suit une distribution **normale conditionnelle** :\n  \n  $$ r_t | x_t \\sim N(0, \\exp(x_t)) $$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\n# Simulation d'un modèle à vol stochastique de Taylor\nn <- 252\nmu <- -0.8\nphi <- 0.9\nsigma_squared <- 0.09\n\nx <- numeric(n)  # Log-volatilité\nr <- numeric(n)  # Rendements simulés\n\nfor (t in 1:n) {\n  if (t == 1) {\n    # Densité de transition stationnaire de x_t\n    x[t] <- rnorm(1, mean = mu/(1-phi), sd = sqrt(sigma_squared / (1 - phi^2)))\n  } else {\n    # Évolution de l'état\n    x[t] <- mu + phi *x[t-1] + sqrt(sigma_squared) * rnorm(1, mean = 0, sd = 1)\n  }\n  # Simulation des rendements\n  r[t] <- exp(x[t] / 2) * rnorm(1, mean = 0, sd = 1)\n}\n\n# extraction dans fichier csv\nwrite.csv(data.frame(r, x), \"true_sv_taylor.csv\", row.names = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(x, lwd = 2, type = \"l\", col = \"blue\", ylab = \"Log-volatilité\", xlab = \"Temps\", main = \"Log-volatilité simulé\")\nplot(r, lwd = 2, type = \"l\", col = \"red\", ylab = \"Rendements\", xlab = \"Temps\", main = \"Rendements simulés\")\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\n## Filtre bootstrap avec les rendements\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams <- c(mu,phi,sigma_squared)\nparams\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.80  0.90  0.09\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\n# Define parameters (ensure they are properly initialized)\nmu <- params[1]\nphi <- params[2]\nsigma_squared <- params[3]\n\n# Definition des variables\n# Définition des paramètres\nn <- length(r)  # Nombre d'observations\nM <- 10000      # Nombre de particules\n\n# Initialisation des matrices et vecteurs\nx_hat <- numeric(n)                   # Estimation de x\nx_particle <- matrix(nrow = n, ncol = M)  # Particules\nw <- matrix(nrow = n, ncol = M)        # Poids des particules\nw_normalized <- matrix(nrow = n, ncol = M) # Poids normalisés\n\n# Filtre particulaire bootstrap\nfor (t in 1:n) {\n  if (t == 1) {\n    # Initialisation des particules à t = 0\n    x_particle[t, ] <- rnorm(M, mean = mu/(1-phi), sd = sqrt(sigma_squared / (1 - phi^2)))\n    \n    # Poids initiaux (basés sur la distribution de l'état initial)\n    w[t, ] <- dnorm(x_particle[t, ], mean = mu/(1-phi), sd = sqrt(sigma_squared / (1 - phi^2)))\n    \n    # Normalisation des poids\n    w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n    \n    # Estimation initiale\n    x_hat[t] <- sum(w_normalized[t, ] * x_particle[t, ])\n  } else {\n    #  Étape de prédiction (échantillonnage de nouvelles particules)\n    x_particle[t, ] <- rnorm(M, mean = mu + phi * x_particle[t - 1, ], sd = sqrt(sigma_squared))\n    \n    #  Mise à jour des poids avec la vraisemblance de l'observation\n    w[t, ] <- dnorm(r[t], mean = 0, sd = sqrt(exp(x_particle[t, ])))\n    \n    #  Normalisation des poids\n    w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n    \n    #  Rééchantillonnage des particules selon leurs poids\n    index <- sample(1:M, size = M, prob = w_normalized[t, ], replace = TRUE)\n    x_particle[t, ] <- x_particle[t, index]\n    \n    # Réinitialisation des poids après rééchantillonnage (uniforme)\n    w_normalized[t, ] <- 1 / M\n    \n    #  Estimation de x à l'instant t (pondérée)\n    x_hat[t] <- sum(w_normalized[t, ] * x_particle[t, ])\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute MSE\nmse <- mean((x - x_hat)^2)\ncat(\"MSE:\", mse, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMSE: 0.2403607 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x, type = \"l\", col = \"black\", ylab = \"Log-volatilité\", xlab = \"Temps\", main = \"Modèle Taylor\")\nlines(x_hat,  type = \"l\", col = \"red\", ylab = \"Log-volatilité\", xlab = \"Temps\")\nlegend(\"topright\", legend=c(\"Log-vol obs.\", \"Log-vol est.\"), col=c(\"black\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\nr_est <- exp(x_hat / 2) * rnorm(length(x_hat), mean = 0, sd = 1)\n\n# Plot the estimate and the true state\nplot(r, type=\"l\", xlab=\"time\", ylab=\"log-returns\", bty=\"n\",col=\"#1B9E77\",main = \"Modèle Taylor\")\n\n# Superposition des trajectoires\nlines(r_est, type = \"l\", col = \"red\",  xlab = \"Temps\", ylab = \"Rendements\", bty=\"n\")\n\n# legend\nlegend(\"topright\", legend=c(\"Rendements obs.\", \"Rendements est.\"), col=c(\"#1B9E77\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n## Filtre bootstrap sur le modèle log-sv de taylor\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\ny_hat <- numeric(n)\nw_hat <- numeric(n)\nx_particle <- matrix(nrow = n, ncol = M)\nw <- matrix(nrow = n, ncol = M)\nw_normalized <- matrix(nrow = n, ncol = M)\ny <- log(r**2)\n\n# Densité d'une log chi-deux de df 1\nlog_chi2 <- function(x) {\n  density <- exp( (x/2) - exp(x/2))/sqrt(2*pi)\n  return( density)\n}\n\n\n# Filtre particulaire bootstrap\nfor (t in 1:n) {\n  if (t == 1) {\n    # Initialisation des particules à t = 0\n    x_particle[t, ] <- rnorm(M, mean = mu/(1-phi), sd = sqrt(sigma_squared / (1 - phi^2)))\n    \n    # Poids initiaux (basés sur la distribution de l'état initial)\n    w[t, ] <- dnorm(x_particle[t, ], mean = mu/(1-phi), sd = sqrt(sigma_squared / (1 - phi^2)))\n    \n    # Normalisation des poids\n    w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n    \n    # Estimation initiale\n    x_hat[t] <- sum(w_normalized[t, ] * x_particle[t, ])\n  } else {\n    #  Étape de prédiction (échantillonnage de nouvelles particules)\n    x_particle[t, ] <- rnorm(M, mean = mu + phi * x_particle[t - 1, ], sd = sqrt(sigma_squared))\n    \n    #  Mise à jour des poids avec la vraisemblance de l'observation\n    w[t, ] <- log_chi2(y[t] - x_particle[t,])\n    \n    #  Normalisation des poids\n    w_normalized[t,] <- w[t,] / sum(w[t,])\n    \n    #  Rééchantillonnage des particules selon leurs poids\n    index <- sample(1:M, size = M, prob = w_normalized[t, ], replace = TRUE)\n    x_particle[t, ] <- x_particle[t, index]\n    \n    # Réinitialisation des poids après rééchantillonnage (uniforme)\n    w_normalized[t, ] <- 1 / M\n    \n    #  Estimation de x à l'instant t (pondérée)\n    x_hat[t] <- sum(w_normalized[t, ] * x_particle[t, ])\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute MSE\nmse <- mean((x - x_hat)^2)\ncat(\"MSE:\", mse, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMSE: 0.3450866 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x, type = \"l\", col = \"black\", ylab = \"Log-volatilité\", xlab = \"Temps\", main = \"Modèle log-sv\")\nlines(x_hat,  type = \"l\", col = \"red\", ylab = \"Log-volatilité\", xlab = \"Temps\")\nlegend(\"topright\", legend=c(\"Log-vol obs.\", \"Log-vol est.\"), col=c(\"black\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\nr_est <- exp(x_hat / 2) * rnorm(length(x_hat), mean = 0, sd = 1)\n\n# Plot the estimate and the true state\nplot(r, type=\"l\", xlab=\"time\", ylab=\"log-returns\", col=\"#1B9E77\", main = \"Modèle log-sv\")\n\n# Superposition des trajectoires\nlines(r_est, type = \"l\", col = \"red\",  xlab = \"Temps\", ylab = \"Rendements\")\n\n# legend\nlegend(\"topright\", legend=c(\"Rendements obs.\", \"Rendements est.\"), col=c(\"#1B9E77\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n\n# Estimation du modèle SV de Taylor par filtrage particulaire (Version pmhtutorial - Part 2-b)\n\n\nLe modèle de volatilité stochastique modifié est défini par les équations suivantes :\n\n1. **Processus des rendements** :\n   \n   $$ r_t = \\exp(x_t / 2) \\cdot \\varepsilon_t, \\quad \\varepsilon_t \\sim N(0,1) $$\n\n2. **Processus de la volatilité logarithmique** :\n\n   $$ x_t = \\mu + \\phi \\times (x_{t-1}-\\mu) + \\sigma_t \\eta_t, \\quad \\eta_t \\sim N(0,1) $$\n\n- \\( x_t \\) suit un processus autorégressif de premier ordre (**AR(1)**) et suit une distribution normale conditionnelle :\n  $$ p(x_t) \\sim N(\\mu , \\frac{\\sigma_t^2}{1-\\phi^2}) $$\n  $$ x_t | x_{t-1} \\sim N(\\mu + \\phi \\times (x_{t-1}-\\mu) , \\sigma_t^2) $$\n- \\( r_t \\) suit une distribution **normale conditionnelle** :\n  \n  $$ r_t | x_t \\sim N(0, \\exp(x_t)) $$\n$r_t = exp(x_t/2)* \\varepsilon_t$ $\\varepsilon_t$ ~ N(0,1)\n$x_t = \\mu + \\phi * (x_{t-1} - \\mu) + \\sigma_t * \\eta_t$  (eta_t ~ N(0,1))\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\nn <- 252\nmu <- -0.8\nphi <- 0.9\nsigma_squared <- 0.09\n\n# Simulation d'un modèle à vol stochastique de Taylor (modifié)\nx <- numeric(n)  # Log-volatilité\nr <- numeric(n)  # Rendements simulés\n\nfor (t in 1:n) {\n  if (t == 1) {\n    # Densité de transition stationnaire de x_t\n    x[t] <- rnorm(1, mean = mu, sd = sqrt(sigma_squared / (1 - phi^2)))\n  } else {\n    # Évolution de l'état\n    #    x[t] <- mu + phi * (x[t-1]) + sqrt(sigma_squared) * rnorm(1, mean = 0, sd = 1)\n    #                       ^^^^^^ True model. To be able to use pmhtutorial package, use the following formula\n    x[t] <- mu + phi * (x[t-1] - mu) + sqrt(sigma_squared) * rnorm(1, mean = 0, sd = 1)\n  }\n  # Simulation des rendements\n  r[t] <- exp(x[t] / 2) * rnorm(1, mean = 0, sd = 1)\n}\n\n# extraction dans fichier csv\nwrite.csv(data.frame(r, x), \"mod_log_sv.csv\", row.names = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(1,2))\nplot(x, lwd = 2, type = \"l\", col = \"blue\", ylab = \"Log-volatilité\", xlab = \"Temps\", main = \"Log-volatilité simulé\")\nplot(r, lwd = 2, type = \"l\", col = \"red\", ylab = \"Rendements\", xlab = \"Temps\", main = \"Rendements simulés\")\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n## Filtre bootstrap avec les rendements\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\n# Definition des variables\n# Définition des paramètres\n\nparams <- c(mu,phi,sigma_squared)\n\nn <- length(r)  # Nombre d'observations\nM <- 10000      # Nombre de particules\n\n# Initialisation des matrices et vecteurs\nx_hat <- numeric(n)                   # Estimation de x\nx_particle <- matrix(nrow = n, ncol = M)  # Particules\nw <- matrix(nrow = n, ncol = M)        # Poids des particules\nw_normalized <- matrix(nrow = n, ncol = M) # Poids normalisés\n\n# Filtre particulaire bootstrap\nfor (t in 1:n) {\n  if (t == 1) {\n    # Initialisation des particules à t = 0\n    x_particle[t, ] <- rnorm(M, mean = mu, sd = sqrt(sigma_squared / (1 - phi^2)))\n    \n    # Poids initiaux (basés sur la distribution de l'état initial)\n    w[t, ] <- dnorm(x_particle[t, ], mean = mu, sd = sqrt(sigma_squared / (1 - phi^2)))\n    \n    # Normalisation des poids\n    w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n    \n    # Estimation initiale\n    x_hat[t] <- sum(w_normalized[t, ] * x_particle[t, ])\n  } else {\n    #  Étape de prédiction (échantillonnage de nouvelles particules)\n    x_particle[t,] <- rnorm(M, mean = mu + phi * (x_particle[t - 1, ] - mu), sd = sqrt(sigma_squared))\n    \n    #  Mise à jour des poids avec la vraisemblance de l'observation\n    w[t, ] <- dnorm(r[t], mean = 0, sd = sqrt(exp(x_particle[t, ])))\n    \n    #  Normalisation des poids\n    w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n    \n    #  Rééchantillonnage des particules selon leurs poids\n    index <- sample(1:M, size = M, prob = w_normalized[t, ], replace = TRUE)\n    x_particle[t, ] <- x_particle[t, index]\n    \n    # Réinitialisation des poids après rééchantillonnage (uniforme)\n    w_normalized[t, ] <- 1 / M\n    \n    #  Estimation de x à l'instant t (pondérée)\n    x_hat[t] <- sum(w_normalized[t, ] * x_particle[t, ])\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute MSE\nmse <- mean((x - x_hat)^2)\ncat(\"MSE:\", mse, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMSE: 0.2403607 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x, type = \"l\", col = \"black\", ylab = \"Log-volatilité\", xlab = \"Temps\", main = \"Modèle Taylor\")\nlines(x_hat,  type = \"l\", col = \"red\", ylab = \"Log-volatilité\", xlab = \"Temps\")\nlegend(\"topright\", legend=c(\"Log-vol obs.\", \"Log-vol est.\"), col=c(\"black\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\nr_est <- exp(x_hat / 2) * rnorm(length(x_hat), mean = 0, sd = 1)\n\n# Plot the estimate and the true state\nplot(r, type=\"l\", xlab=\"time\", ylab=\"log-returns\", bty=\"n\",col=\"#1B9E77\",main = \"Modèle Taylor\")\n\n# Superposition des trajectoires\nlines(r_est, type = \"l\", col = \"red\",  xlab = \"Temps\", ylab = \"Rendements\", bty=\"n\")\n\n# legend\nlegend(\"topright\", legend=c(\"Rendements obs.\", \"Rendements est.\"), col=c(\"#1B9E77\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n### Utilisation de library(pmhtutorial)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pmhtutorial)\n\n# particleFilterSVmodel takes sigma as parameters\nparams[3] <- sqrt(params[3])\nx_hat_2<- particleFilterSVmodel(r,params,M)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x, type = \"l\", col = \"black\", ylab = \"Log-volatilité\", xlab = \"Temps\", main = \"log-volatilité\")\nlines(x_hat_2$xHatFiltered, type = \"l\", col = \"red\", ylab = \"Log-volatilité\", xlab = \"Temps\", main = \"Log-volatilité estimé\")\n# legend\nlegend(\"topright\", legend=c(\"Log-vol obs.\", \"Log-vol est.\"), col=c(\"black\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\nr_est <- exp(x_hat_2$xHatFiltered / 2) * rnorm(length(x_hat_2$xHatFiltered), mean = 0, sd = 1)\n\n# Superposition des trajectoires\nplot(r, type=\"l\", xlab=\"time\", ylab=\"log-returns\", bty=\"n\",\n  col=\"#1B9E77\", main=\"True returns\")\n\nlines(r_est, type = \"l\", col = \"red\",  xlab = \"Temps\", ylab = \"Rendements\", \n     main = \"Estimated returns\",bty=\"n\")\n\nlegend(\"topright\", legend=c(\"Rendements obs.\", \"Rendements est.\"), col=c(\"#1B9E77\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n\n## Filtre bootstrap sur le modèle log-sv de taylor\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\nparams <- c(mu,phi,sigma_squared)\n\ny_hat <- numeric(n)\nw_hat <- numeric(n)\nx_particle <- matrix(nrow = n, ncol = M)\nw <- matrix(nrow = n, ncol = M)\nw_normalized <- matrix(nrow = n, ncol = M)\ny <- log(r**2)\n\n# Densité d'une log chi-deux de df 1\nlog_chi2 <- function(x) {\n  density <- exp( (x/2) - exp(x/2))/sqrt(2*pi)\n  return( density)\n}\n\n# Filtre particulaire bootstrap\nfor (t in 1:n) {\n  if (t == 1) {\n    # Initialisation des particules à t = 0\n    x_particle[t, ] <- rnorm(M, mean = mu, sd = sqrt(sigma_squared / (1 - phi^2)))\n    \n    # Poids initiaux (basés sur la distribution de l'état initial)\n    w[t, ] <- dnorm(x_particle[t, ], mean = mu, sd = sqrt(sigma_squared / (1 - phi^2)))\n    \n    # Normalisation des poids\n    w_normalized[t, ] <- w[t, ] / sum(w[t, ])\n    \n    # Estimation initiale\n    x_hat[t] <- sum(w_normalized[t, ] * x_particle[t, ])\n  } else {\n    #  Étape de prédiction (échantillonnage de nouvelles particules)\n    x_particle[t, ] <- rnorm(M, mean = mu + phi * (x_particle[t - 1, ]-mu), sd = sqrt(sigma_squared))\n    \n    #  Mise à jour des poids avec la vraisemblance de l'observation\n    w[t, ] <- log_chi2(y[t] - x_particle[t,])\n    \n    #  Normalisation des poids\n    w_normalized[t,] <- w[t,] / sum(w[t,])\n    \n    #  Rééchantillonnage des particules selon leurs poids\n    index <- sample(1:M, size = M, prob = w_normalized[t, ], replace = TRUE)\n    x_particle[t, ] <- x_particle[t, index]\n    \n    # Réinitialisation des poids après rééchantillonnage (uniforme)\n    w_normalized[t, ] <- 1 / M\n    \n    #  Estimation de x à l'instant t (pondérée)\n    x_hat[t] <- sum(w_normalized[t, ] * x_particle[t, ])\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute MSE\nmse <- mean((x - x_hat)^2)\ncat(\"MSE:\", mse, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMSE: 0.3450866 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x, type = \"l\", col = \"black\", ylab = \"Log-volatilité\", xlab = \"Temps\", main = \"Modèle log-sv\")\nlines(x_hat,  type = \"l\", col = \"red\", ylab = \"Log-volatilité\", xlab = \"Temps\")\nlegend(\"topright\", legend=c(\"Log-vol obs.\", \"Log-vol est.\"), col=c(\"black\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # Pour rendre les simulations reproductibles\n\nr_est <- exp(x_hat / 2) * rnorm(length(x_hat), mean = 0, sd = 1)\n\n# Plot the estimate and the true state\nplot(r, type=\"l\", xlab=\"time\", ylab=\"log-returns\", col=\"#1B9E77\", main = \"Modèle log-sv\")\n\n# Superposition des trajectoires\nlines(r_est, type = \"l\", col = \"red\",  xlab = \"Temps\", ylab = \"Rendements\")\n\n# legend\nlegend(\"topright\", legend=c(\"Rendements obs.\", \"Rendements est.\"), col=c(\"#1B9E77\", \"red\"), lty=1:1, cex=0.8)\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n# Application sur données réelles\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the data from Quandl\nlibrary(quantmod)\n\n# Téléchargement des données de Yahoo Finance\ngetSymbols(\"^IXIC\", src = \"yahoo\", from = \"2012-01-02\", to = \"2014-01-02\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"IXIC\"\n```\n\n\n:::\n\n```{.r .cell-code}\nS_t <- IXIC$IXIC.Close\n\ny <- as.numeric(100 * diff(log(S_t)))\ny <- y[!is.na(y)]\n\n# Estimate the filtered state using a particle filter\ntheta <- c(-0.10, 0.97, 0.15)\npfOutput <- particleFilterSVmodel(y, theta, noParticles=100)\n\nplot(pfOutput$xHatFiltered, type=\"l\", xlab=\"time\",\n  ylab=\"estimate of log-volatility\", bty=\"n\", col=\"#D95F02\", main=\"Particle filter estimate of log-volatility\")\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simulation des rendements estimés à partir de x_hat\nset.seed(123)  # Pour rendre les simulations reproductibles\nr_est <- exp(pfOutput$xHatFiltered / 2) * rnorm(length(pfOutput$xHatFiltered), mean = 0, sd = 1)\n\n# Superposition des trajectoires\nplot(y, type=\"l\", xlab=\"time\", ylab=\"log-returns\", bty=\"n\",\n  col=\"#1B9E77\", main=\"True log-returns\")\n\nlines(r_est, type = \"l\", col = \"red\",  xlab = \"Temps\", ylab = \"Rendements\", \n     main = \"Estimated log-returns\",bty=\"n\")\n```\n\n::: {.cell-output-display}\n![](modele_log_sv-part2_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}