{
  "hash": "7af8055f588b52d4b6e19baeef1a6a86",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Modèles de courbe de taux\ndate: 2025-03-04\nauthor: \n    - Cheryl Kouadio\n    - Mariyam Ouyassin\n---\n\n\n\n\n\n\n## Introduction\n\nQue ce soit pour les banques, les assureurs ou les fonds de pension, la courbe de taux zéro-coupon constitue la brique de base pour la valorisation de nombreux instruments financiers, de la détermination du prix des obligations aux produits dérivés plus complexes tels que les swaps de taux, les caplets, les swaptions ou encore les produits structurés de taux. De ce fait, la construction fiable, cohérente et régulièrement mise à jour d'une courbe de taux zéro-coupon représente un enjeu majeur.\n\nDans ce contexte, ce projet propose une méthodologie complète de reconstitution de la courbe de taux zéro-coupon implicite, élaborée à partir des cotations de marché disponibles sur différents segments : Money Market (marché monétaire), Futures et Swaps. L’approche adoptée repose sur une combinaison de bootstrapping, permettant d’extraire les taux zéro-coupon pour chaque maturité observable, et d’interpolations par spline cubique, afin d’assurer la lissité et la continuité de la courbe sur l’ensemble de l’échéancier, y compris sur les maturités non directement observées.\n\nLa courbe obtenue sert ensuite de référence pour la valorisation de produits dérivés de taux, en particulier les caplets et les swaptions, via le modèle classique de Black, largement utilisé sur les marchés. Toutefois, afin de mieux capturer la dynamique temporelle des taux d’intérêt et de prendre en compte la structure temporelle de la volatilité implicite, la seconde partie du projet repose sur la calibration d’un modèle de Hull-White, un modèle de taux affine avec retour à la moyenne. La calibration est réalisée à partir des cotations de caplets at-the-money (ATM), à l’aide d’une procédure de recherche numérique par dichotomie. \n\nLe projet met également en évidence la sensibilité de la courbe de taux forward et des prix d’options aux paramètres de marché, notamment la volatilité et le paramètre de mean reversion du modèle Hull-White. Cette analyse de sensibilité illustre comment la structure de la courbe de taux et son évolution future sont influencées par les hypothèses de modélisation, ce qui est particulièrement crucial pour les desks de trading, les gestionnaires d’actifs ou les équipes de gestion actif-passif (ALM). \n\nEnfin, le projet se prolonge par une extension appliquée aux produits structurés : la valorisation de caplets à barrière désactivante (knock-out caplets), qui nécessite une approche par simulation Monte-Carlo. Cette extension illustre comment la dynamique du taux court, simulée sous la mesure forward neutre, peut être exploitée pour évaluer des produits de plus en plus complexes, répondant à des besoins spécifiques d’investisseurs ou de gestionnaires de risques. \n\n::: {.callout-important}\nLe rapport de ce projet est disponible [ici](../rapports/Rapport_KOUADIO_OUYASSIN_courbes_de_taux.pdf).\n:::\n\n## I. Reconstitution de la courbe de taux\n\n### I.1. Formules de valorisation des taux de marché\n\nLa courbe interbancaire est une courbe de taux qui représente les taux d'intérêt auxquels les banques se prêtent de l'argent entre elles. Elle est utilisée pour déterminer les taux d'intérêt des prêts et des emprunts à court terme. Elle est construite sur le court terme (maturité<6M) à partir des taux du marchés monétaire (Money Market) basés sur les dépots non garantis entre banques. Sur le moyen terme (6m - 3y) elle est construite à partir des contrats futures, i.e. des forwards sur un marché OTC (Over The Counter) et sur le long terme (>3y) elle est construite à partir des contrats de swap euribor (Euro Interbank Offered Rate) 3M ou 6M.\n\nCi dessous, nous disposons de ces données de taux de marché cotés sur le marché interbancaire. Nous allons essayer de reconstituer la courbe de taux zero coupon implicite, qui ne cote pas directement sur le marché. \nLe fichier de données contient trois variables : \n- Type d'instruments (Money Market, Futures, Swap)\n- Maturité (en années)\n- Taux d'intérêt\n\n::: {#0c4645ae .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndata = pd.read_excel('data/Data_tx.xlsx', sheet_name='tx_marche')\ndata.columns = ['type', 'T', 'tx']\ndata\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>type</th>\n      <th>T</th>\n      <th>tx</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>MM</td>\n      <td>0.25</td>\n      <td>0.030698</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>MM</td>\n      <td>0.50</td>\n      <td>0.026191</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>MM</td>\n      <td>0.75</td>\n      <td>0.023958</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>MM</td>\n      <td>1.00</td>\n      <td>0.022979</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>FUT</td>\n      <td>1.25</td>\n      <td>0.978691</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>FUT</td>\n      <td>1.50</td>\n      <td>0.977094</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>FUT</td>\n      <td>1.75</td>\n      <td>0.974981</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>FUT</td>\n      <td>2.00</td>\n      <td>0.972911</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>FUT</td>\n      <td>2.25</td>\n      <td>0.970984</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>FUT</td>\n      <td>2.50</td>\n      <td>0.969711</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>FUT</td>\n      <td>2.75</td>\n      <td>0.968436</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>SWAP</td>\n      <td>3.00</td>\n      <td>0.026112</td>\n    </tr>\n    <tr>\n      <th>12</th>\n      <td>SWAP</td>\n      <td>4.00</td>\n      <td>0.028117</td>\n    </tr>\n    <tr>\n      <th>13</th>\n      <td>SWAP</td>\n      <td>5.00</td>\n      <td>0.029680</td>\n    </tr>\n    <tr>\n      <th>14</th>\n      <td>SWAP</td>\n      <td>6.00</td>\n      <td>0.031107</td>\n    </tr>\n    <tr>\n      <th>15</th>\n      <td>SWAP</td>\n      <td>7.00</td>\n      <td>0.032313</td>\n    </tr>\n    <tr>\n      <th>16</th>\n      <td>SWAP</td>\n      <td>8.00</td>\n      <td>0.033382</td>\n    </tr>\n    <tr>\n      <th>17</th>\n      <td>SWAP</td>\n      <td>9.00</td>\n      <td>0.034385</td>\n    </tr>\n    <tr>\n      <th>18</th>\n      <td>SWAP</td>\n      <td>10.00</td>\n      <td>0.035312</td>\n    </tr>\n    <tr>\n      <th>19</th>\n      <td>SWAP</td>\n      <td>11.00</td>\n      <td>0.036197</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>SWAP</td>\n      <td>12.00</td>\n      <td>0.037003</td>\n    </tr>\n    <tr>\n      <th>21</th>\n      <td>SWAP</td>\n      <td>13.00</td>\n      <td>0.037668</td>\n    </tr>\n    <tr>\n      <th>22</th>\n      <td>SWAP</td>\n      <td>14.00</td>\n      <td>0.038201</td>\n    </tr>\n    <tr>\n      <th>23</th>\n      <td>SWAP</td>\n      <td>15.00</td>\n      <td>0.038624</td>\n    </tr>\n    <tr>\n      <th>24</th>\n      <td>SWAP</td>\n      <td>20.00</td>\n      <td>0.039380</td>\n    </tr>\n    <tr>\n      <th>25</th>\n      <td>SWAP</td>\n      <td>25.00</td>\n      <td>0.038501</td>\n    </tr>\n    <tr>\n      <th>26</th>\n      <td>SWAP</td>\n      <td>30.00</td>\n      <td>0.037668</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nEn l'absence d'oppotunité d'arbitrage, les valorisations des instruments de marché s'expriment en fonction des taux zéro coupon implicites suivantes :\n\n- Sur le segment **Money Market**, on cote en taux monétaires :\n\n    $$\n    L_t(T,T+\\delta) = \\frac{1}{\\delta} \\left( \\frac{B(t,T)}{B(t,T+\\delta)} - 1 \\right),\n    $$\n\n    avec t le temps courant, T la maturité et $\\delta$ la période de capitalisation.\n    Dans notre cas, t=T=0 et $\\delta$ varie en fonction de la maturité.\n\n- Sur le segment **Future**, on côte en 1 - tx forward :\n\n    $$\n    future(T, T+\\delta) = 1 - L_t(T,T+\\delta).\n    $$\n    Dans notre cas, t=0, T= maturité - 3m et $\\delta = 3m$.\n\n\n- Sur le segment **Swap**, on côte en taux swap :\n\n    $$\n    Swap(t, T_0, T_n) = B(t, T_0)−B(t, T_n)−K ×lvl(t),\n    $$\n\n    avec K le taux fixe du swap qui égalise la PV du swap vaut 0 et $lvl(t)=\\sum_{i=1}^{n} \\delta_i B(t, T_i)$ le taux de marché à la maturité $T_n$.\n    Dans notre cas, la date de départ est le spot, i.e. $T_0=0$ et $T_n$ est la maturité du swap, et t=0 (vu d'aujourd'hui).\n\nDe ce fait, le données ne sont pas homogènes en taux du fait de la différente cotations des instruments. Nous allons donc les transformer en taux monétaires pour les homogénéiser.\n\n**Remarques préliminaires** :\n- En zone EURO, les swaps standards côtés sur le marché ont une fréquence de paiement semestrielle pour la patte variable et annuelle pour la patte fixe. Ainsi pour le calcul du level du swap, $\\delta=1$ et on ajoute progressivement les taux de marché.\n- Pour simplifier les calculs, nous supposerons que les dates de départ des taux monétaires et des taux de swap\nsont spot (i.e. T0 = 0 et non 1 ou 2 jours).\n\n**Methode de bootstrapping & stripping** :\n\nPour extraire les taux zéro coupon implicites, nous allons utiliser la méthode de bootstrapping. Cette méthode consiste à calculer les taux zéro coupon implicites à partir des taux de marché. Pour cela, nous allons utiliser les formules des taux monétaires présentées ci-dessus, qui sont vu comme des fonctions de taux zéro coupon implicites.\n\nComme les taux de swap ne sont pas nécessairement disponibles pour toutes les maturités annuelles, il faut interpoler les taux intermédiaires. Cela permettra de simplifier la méthode de bootstrapping. Nous allons utiliser une interpolation par spline cubic afin d'avoir des taux swap par an. Une interpolation par spline permet d'avoir des bonnes propriétés en terme de dérivabilité et de continuité de la courbe de taux.\n\nIl s'agira donc de construire une nouvelle courbe de taux de marché discrète avec des cotations annuelles de taux swap à l’aide d’une méthode d’interpolation par spline, en plus des autres instruments. Par la suite, on supposera que cette nouvelle courbe est la courbe de marché de référence, i.e. la courbe utilisée pour impliciter les taux zéro coupon.\n\nEnfin, nous allons faire du stripping afin de reconstituer une courbe de taux zero coupon implicite plus lisse à l'aide de différentes méthodes d'interpolations (linéaire, spline, etc).\n\n\n### I.2. Construction de la courbe des taux zéro-coupon\n\n::: {#a36e0da8 .cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nfrom scipy.interpolate import interp1d\n\ndef interpolate_and_update_df(data, col_x, col_y, kind='cubic', start=3, end=30, step=1):\n    \"\"\"\n    Interpole les taux SWAP et met à jour le DataFrame avec les nouvelles valeurs interpolées.\n\n    Paramètres :\n    - data : DataFrame d'origine contenant une colonne 'type' avec 'SWAP', 'T' et 'tx'.\n    - kind : Type d'interpolation (par défaut 'cubic', peut être 'linear', 'quadratic', etc.).\n    - start : Valeur minimale de T pour l'interpolation (par défaut 3).\n    - end : Valeur maximale de T pour l'interpolation (par défaut 31).\n    - step : Pas d'incrémentation pour la grille interpolée (par défaut 1).\n\n    Retourne :\n    - new_df : DataFrame mis à jour avec les taux SWAP interpolés.\n    \"\"\"\n\n    data = data.copy()\n    x, y = data[col_x].values, data[col_y].values\n\n    f = interp1d(x, y, kind=kind)\n    xnew = np.arange(start, end+step, step)\n    tx_new = f(xnew)\n    df = pd.DataFrame({col_x: xnew, col_y: tx_new})\n\n    return df\n\ndf_interp = interpolate_and_update_df(data, 'T', 'tx') \ndf_interp['type'] = 'SWAP'\ndf_interp.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>T</th>\n      <th>tx</th>\n      <th>type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>3</td>\n      <td>0.026112</td>\n      <td>SWAP</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>4</td>\n      <td>0.028117</td>\n      <td>SWAP</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>5</td>\n      <td>0.029680</td>\n      <td>SWAP</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>6</td>\n      <td>0.031107</td>\n      <td>SWAP</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>7</td>\n      <td>0.032313</td>\n      <td>SWAP</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#78344364 .cell execution_count=4}\n``` {.python .cell-code}\n# Le rajoiuter dans le df\nnew_df = pd.concat([data[data[\"type\"] != \"SWAP\"], df_interp], ignore_index=True)\nnew_df.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>type</th>\n      <th>T</th>\n      <th>tx</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>MM</td>\n      <td>0.25</td>\n      <td>0.030698</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>MM</td>\n      <td>0.50</td>\n      <td>0.026191</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>MM</td>\n      <td>0.75</td>\n      <td>0.023958</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>MM</td>\n      <td>1.00</td>\n      <td>0.022979</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>FUT</td>\n      <td>1.25</td>\n      <td>0.978691</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#708397fe .cell execution_count=5}\n``` {.python .cell-code}\n# Affichage d'une courbe homogène de taux de marché en fonction de la maturité\nnew_df['tx_h'] = new_df.apply(lambda x: 1 - x['tx'] if x['type'] == 'FUT' else x['tx'], axis=1)\n\nplt.figure(figsize=(8, 5))\nplt.plot(new_df[\"T\"], new_df[\"tx_h\"], marker='o', linestyle='-', color='b')\nplt.xlabel('Maturité')\nplt.ylabel('Taux de marché')\nplt.title('Courbe des taux de marché')\nplt.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-5-output-1.png){width=689 height=449}\n:::\n:::\n\n\n#### Extraction du taux zero coupon sur le segment Money Market\n\nLes taux zéro-coupon continus sont définis par la formule suivante :\n\n$$\nr(t,T) = -\\frac{1}{T-t} \\ln B(t,T),\n$$\n\noù B(t,T) est le facteur d'actualisation ($B(t,T) = exp(-r(t,T) \\times  T)$ ), i.e. le prix d'une obligation zéro-coupon de maturité T à la date t.\n\nIls sont la brique de base pour la valorisation des produits dérivés et des obligations. De ce fait, nous allons essayer de reconstituer la courbe des taux zéro-coupon implicite à partir de la courbe des taux de marché à l'aide de la méthode du bootstrapping. Cette méthode consiste à calculer les taux zéro-coupon implicites à partir des taux de marché en utilisant la formule suivante selon le segment Money Market :\n\n$$\nL_0(0,\\delta) = \\frac{1}{\\delta} \\left( \\frac{1}{B(0,\\delta)} - 1 \\right)\n$$\n\nDe ce fait, le facteur d'actualisation est :\n$$\nB(0,\\delta) = \\frac{1}{1 + \\delta L_0(0,\\delta)}\n$$\n\n::: {#ac700ad2 .cell execution_count=6}\n``` {.python .cell-code}\n# Extraction des facteurs d'actualisation pour les Money Market\nmm = new_df[new_df['type'] == 'MM']\n\nmm.loc[:, 'B'] = 1 / (1 + mm['tx'] * mm['T'])\nmm.loc[:, 'R'] = - np.log(mm['B']) / mm['T']\n\ndf_ZC = mm\n```\n:::\n\n\n#### Extraction du taux zero coupon sur le segment Future\n\nSur le segment Future, on a :\n\n$$\nFuture = 1 - L_0(T,T+\\delta) = 1 - \\frac{1}{\\delta} \\left( \\frac{B(0,T)}{B(0,T+\\delta)} - 1 \\right)\n$$\n\nDe ce fait, le facteur d'actualisation est :\n$$\nB(0,T+\\delta) = \\frac{B(0,T)}{1 + \\delta (1- Future)}\n$$\n\n::: {#b0c2e75e .cell execution_count=7}\n``` {.python .cell-code}\n# Extraction des facteurs d'actualisation pour les Futures\n\nfut = new_df[new_df['type'] == 'FUT']\n\n# concat à mm\ndf_ZC = pd.concat([df_ZC, fut], ignore_index=True)\n\nmm_len = len(mm)\n\nfor i in range(mm_len, len(df_ZC)):\n    df_ZC.loc[i, 'B'] = df_ZC.loc[i-1, 'B'] / (1 + (1 - df_ZC.loc[i, 'tx'])* 0.25)\n    df_ZC.loc[i, 'R'] = - np.log(df_ZC.loc[i, 'B']) / df_ZC.loc[i, 'T']\n```\n:::\n\n\n#### Extraction du taux zero coupon sur le segment swap\n\nPour le segment swap payeur, on a :\n\n$$\nSwap(t, T_0, T_n) = B(t, T_0)−B(t, T_n)−K ×lvl(t) = 0,\n$$\n\navec K le taux fixe du swap qui fait que la PV du swap vaut 0 et $lvl(t)=\\sum_{i=1}^{n} \\delta_i B(t, T_i)$ le taux de marché à la maturité $T_n$. De ce fait, le facteur d'actualisation est :\n$$\nB(0,T_n) = \\frac{1 - K \\sum_{i=1}^{n-1} \\delta_i B(0,T_i)}{1 + K}\n$$\n\n::: {#1e3fdcf6 .cell execution_count=8}\n``` {.python .cell-code}\n# Extraction des facteurs d'actualisation pour les Swaps\nswap = new_df[new_df['type'] == 'SWAP']\nfut_len = len(fut)\n\ndf_ZC = pd.concat([df_ZC, swap], ignore_index=True)\n\nfor i in range(mm_len+fut_len, len(df_ZC)):\n    T_n = df_ZC.loc[i, 'T']  # Récupère la valeur de T actuelle\n    mask = (df_ZC['T'] < T_n) & (df_ZC['T'] % 1 == 0)  # Sélectionne uniquement les T entiers < T_n\n    df_ZC.loc[i, 'B'] = (1 - df_ZC.loc[i, 'tx'] * sum(df_ZC.loc[mask, 'B'].fillna(0)))/(1+df_ZC.loc[i, 'tx'])\n    df_ZC.loc[i, 'R'] = - np.log(df_ZC.loc[i, 'B']) / T_n\n```\n:::\n\n\n::: {#c719afa8 .cell execution_count=9}\n``` {.python .cell-code}\nplt.figure(figsize=(8, 5))\nplt.plot(df_ZC['T'], df_ZC['R'], label='Courbe de taux zéro coupon', marker='o')\nplt.plot(new_df[\"T\"], new_df[\"tx_h\"], label='Taux de marché', marker='o')\nplt.xlabel('T')\nplt.ylabel('R')\nplt.legend()\nplt.title('Courbe de taux zéro coupon discrétisée')\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nText(0.5, 1.0, 'Courbe de taux zéro coupon discrétisée')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-9-output-2.png){width=689 height=450}\n:::\n:::\n\n\nComme on peut le constater, le mode d’interpolation a un impact significatif sur le calcul des taux de marché car il affecte la forme de la courbe des taux et donc la valorisation des instruments financiers.\n\n### I.3. Construction de la courbe des taux forward\n\nA partir de la courbe des taux zéro-coupon issue de la méthode de bootstrapping, nous souhaitons tracer la courbe des taux forwards de tenor 3M en fonction de la maturité à l’aide des méthodes d’interpolation linéaire et par spline, avec une discrétisation de 0.1 an.\n\nPour tracer la courbe taux forward, on utilisera la formule suivante pour calculer les taux forward :\n\n$$\nL_0(T,T+\\delta) = \\frac{1}{\\delta} (\\frac{B(0,T)}{B(0,T+\\delta)} - 1)\n$$\navec $\\delta = 0.25$.\n\nPour le segment swap, il s'agira d'interpoler les taux zéro-coupon implicites pour avoir des tx forwards 3M. # changer la discretisatio à 1an ce qui est différent du ténor.\n\n::: {#d886d6d8 .cell execution_count=10}\n``` {.python .cell-code}\ndf_ZC = pd.concat([pd.DataFrame({\"T\": [0], \"B\": [1], \"R\": [0]}), df_ZC], ignore_index=True)\n```\n:::\n\n\n::: {#7ec78c17 .cell execution_count=11}\n``` {.python .cell-code}\nnew_df_ZC= interpolate_and_update_df(df_ZC, 'T', 'R', kind='linear', start=0, end=30, step=0.1)\n\ntau = 0.25  # 3 mois = 0.25 an\n\ndef compute_forward_rates(R, T_range, tau):\n    \"\"\" Calcule les taux forward pour chaque maturité \"\"\"\n    fwd_rates = []\n    T_values = []\n    for i in range(len(T_range)-1):\n        T = T_range[i]\n        T_tau = T + tau\n        if T_tau >= max(T_range):\n            break  # Éviter d'extrapoler au-delà des données disponibles\n        B_T = np.exp(-R[i] * T)\n        R_T_tau = np.interp(T_tau, T_range, R) \n        B_T_tau = np.exp(-R_T_tau * T_tau)\n\n        # Formule du taux forward instantané\n        fwd_rate = (B_T / B_T_tau - 1) / tau\n        fwd_rates.append(fwd_rate)\n        T_values.append(T)\n\n    return pd.DataFrame({\"T\": T_values, \"tx_fwd\": fwd_rates})\n\nfwd_rates = compute_forward_rates(new_df_ZC['R'], new_df_ZC['T'], tau)\n\nplt.figure(figsize=(8, 5))\nplt.plot(fwd_rates[\"T\"],fwd_rates[\"tx_fwd\"], label='Taux forward')\nplt.xlabel('T')\nplt.ylabel('Taux forward')\nplt.legend()\nplt.title('Courbe des taux forward avec interpolation linéaire')\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\nText(0.5, 1.0, 'Courbe des taux forward avec interpolation linéaire')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-11-output-2.png){width=680 height=450}\n:::\n:::\n\n\n::: {#31e0037d .cell execution_count=12}\n``` {.python .cell-code}\nnew_df_ZC= interpolate_and_update_df(df_ZC, 'T', 'R', kind='cubic', start=0, end=30, step=0.1)\n\ntau = 0.25  # 3 mois = 0.25 an\nfwd_rates = compute_forward_rates(new_df_ZC['R'], new_df_ZC['T'], tau)\n\nplt.figure(figsize=(8, 5))\nplt.plot(fwd_rates[\"T\"],fwd_rates[\"tx_fwd\"], label='Taux forward')\nplt.xlabel('T')\nplt.ylabel('Taux forward')\nplt.legend()\nplt.title('Courbe des taux forward avec interpolation par spline')\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nText(0.5, 1.0, 'Courbe des taux forward avec interpolation par spline')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-12-output-2.png){width=680 height=449}\n:::\n:::\n\n\nLorsqu'on utilise une interpolation linéaire, on obtient une courbe plus discontinue. La courbe a une structure en marches d’escalier. Il y a des sauts brusques lorsque l'on passe d'un intervalle à un autre. En effet, par nature, l'interpolation linéaire qui ne prend pas en compte les points intermédiaires.\nEn interpolant avec une fonction spline, on obtient une courbe plus lisse et continue.Elle est plus cohérente avec l'évolution naturelle des taux d'intérêt. En effet, la fonction spline est une fonction polynomiale qui passe par tous les points de la courbe. Elle est plus flexible et permet de mieux capturer les variations des taux d'intérêt.\n\nNous sommes intéressés à ce qui pourrait se passer lorsque nous shiftons le taux de swap 5Y de 10 points de base. Cela permet de déterminer la sensibilité de la courbe des taux forward aux variations des taux de swap et donc donner des indications sur comment hedger ce risque.\n\nNous allons donc calculer le taux forward 3M pour les deux courbes de taux forward et comparer les résultats. \n\n::: {#0f561488 .cell execution_count=13}\n``` {.python .cell-code}\nchoc = 10/10000\nnew_df[\"tx_s\"] = new_df.apply(lambda x: x['tx_h']+choc if x['T'] == 5 else x['tx_h'], axis=1)\n\n# plot\nplt.figure(figsize=(8, 5))\nplt.plot(new_df[\"T\"], new_df[\"tx_s\"], label='Taux de marché shiftés', color=\"r\")\nplt.plot(new_df[\"T\"], new_df[\"tx_h\"], label='Taux de marché', color=\"b\")\nplt.xlabel('Maturité')\nplt.ylabel('Taux de marché')\nplt.title('Courbe des taux de marché')\nplt.legend()\nplt.grid()\nplt.show()\n\nnew_df[\"tx_s\"] = new_df.apply(lambda x: x['tx']+choc if x['T'] == 5 else x['tx'], axis=1)\n```\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-13-output-1.png){width=689 height=449}\n:::\n:::\n\n\n::: {#6f837689 .cell execution_count=14}\n``` {.python .cell-code}\n# Extraction des facteurs d'actualisation pour les Money Market\nimport numpy as np\nimport pandas as pd\n\ndef compute_discount_factors(new_df, col_T=\"T\", col_tx=\"tx\"):\n    \"\"\"\n    Calcule les facteurs d'actualisation (B) et les taux zéro-coupon (R) \n    à partir des taux du marché pour les instruments MM, FUT et SWAP.\n\n    Paramètres :\n    - new_df : DataFrame contenant les taux du marché avec les colonnes spécifiées.\n    - col_T : Nom de la colonne contenant les maturités (ex: \"T\").\n    - col_tx : Nom de la colonne contenant les taux du marché (ex: \"tx\").\n\n    Retourne :\n    - df_ZC : DataFrame contenant les facteurs d'actualisation et les taux zéro-coupon.\n    \"\"\"\n\n    # --- Extraction des données du marché monétaire (MM) ---\n    mm = new_df[new_df['type'] == 'MM'].copy()\n    mm.loc[:, 'B'] = 1 / (1 + mm[col_tx] * mm[col_T])\n    mm.loc[:, 'R'] = - np.log(mm['B']) / mm[col_T]\n\n    df_ZC = mm.copy()\n\n    # --- Extraction des données Futures (FUT) ---\n    fut = new_df[new_df['type'] == 'FUT'].copy()\n    df_ZC = pd.concat([df_ZC, fut], ignore_index=True)\n\n    mm_len = len(mm)\n\n    # --- Calcul des facteurs d'actualisation pour les Futures ---\n    for i in range(mm_len, len(df_ZC)):\n        df_ZC.loc[i, 'B'] = df_ZC.loc[i-1, 'B'] / (1 + (1 - df_ZC.loc[i, col_tx]) * 0.25)\n        df_ZC.loc[i, 'R'] = - np.log(df_ZC.loc[i, 'B']) / df_ZC.loc[i, col_T]\n\n    # --- Extraction des données Swaps (SWAP) ---\n    swap = new_df[new_df['type'] == 'SWAP'].copy()\n    fut_len = len(fut)\n    df_ZC = pd.concat([df_ZC, swap], ignore_index=True)\n\n    # --- Calcul des facteurs d'actualisation pour les Swaps ---\n    for i in range(mm_len + fut_len, len(df_ZC)):\n        T_n = df_ZC.loc[i, col_T]  # Maturité actuelle\n        mask = (df_ZC[col_T] < T_n) & (df_ZC[col_T] % 1 == 0)  # Sélection des T entiers < T_n\n\n        sum_B = sum(df_ZC.loc[mask, 'B'].fillna(0))\n        df_ZC.loc[i, 'B'] = (1 - df_ZC.loc[i, col_tx] * sum_B) / (1 + df_ZC.loc[i, col_tx])\n        df_ZC.loc[i, 'R'] = - np.log(df_ZC.loc[i, 'B']) / T_n\n\n    return df_ZC\n\n\ndf_ZC_s = compute_discount_factors(new_df, col_T=\"T\", col_tx=\"tx_s\")\ndf_ZC_s=pd.concat([pd.DataFrame({\"T\": [0], \"B\": [1], \"R\": [0]}), df_ZC_s], ignore_index=True)\n\nplt.figure(figsize=(8, 5))\nplt.plot(df_ZC_s.loc[1:,'T'], df_ZC_s.loc[1:,'R'], label='Courbe de taux zéro coupon shifté', marker='o')\nplt.plot(df_ZC.loc[1:,\"T\"], df_ZC.loc[1:,\"R\"], label='Courbe de taux zéro coupon non shifté', marker='o')\nplt.xlabel('T')\nplt.ylabel('R')\nplt.legend()\nplt.title('Courbe de taux zéro coupon discrétisée')\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nText(0.5, 1.0, 'Courbe de taux zéro coupon discrétisée')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-14-output-2.png){width=689 height=450}\n:::\n:::\n\n\n::: {#1e8a5e30 .cell execution_count=15}\n``` {.python .cell-code}\nnew_df_ZC= interpolate_and_update_df(df_ZC_s, 'T', 'R', kind='linear', start=0, end=30, step=0.1)\n\ntau = 0.25  # 3 mois = 0.25 an\nfwd_rates = compute_forward_rates(new_df_ZC['R'], new_df_ZC['T'], tau)\n\nplt.figure(figsize=(8, 5))\nplt.plot(fwd_rates[\"T\"],fwd_rates[\"tx_fwd\"], label='Taux forward')\nplt.xlabel('T')\nplt.ylabel('Taux forward')\nplt.legend()\nplt.title('Courbe des taux forward avec interpolation par spline')\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nText(0.5, 1.0, 'Courbe des taux forward avec interpolation par spline')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-15-output-2.png){width=680 height=449}\n:::\n:::\n\n\n::: {#08a3bafa .cell execution_count=16}\n``` {.python .cell-code}\nnew_df_ZC= interpolate_and_update_df(df_ZC_s, 'T', 'R', kind='cubic', start=0, end=30, step=0.1)\n\ntau = 0.25  # 3 mois = 0.25 an\nfwd_rates = compute_forward_rates(new_df_ZC['R'], new_df_ZC['T'], tau)\n\nplt.figure(figsize=(8, 5))\nplt.plot(fwd_rates[\"T\"],fwd_rates[\"tx_fwd\"], label='Taux forward')\nplt.xlabel('T')\nplt.ylabel('Taux forward')\nplt.legend()\nplt.title('Courbe des taux forward avec interpolation par spline')\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nText(0.5, 1.0, 'Courbe des taux forward avec interpolation par spline')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-16-output-2.png){width=680 height=449}\n:::\n:::\n\n\nEn shiftant le taux de swap 5Y, la courbe de forward baisse brusquement pour T=5Y. Il y a une déformation locale de la courbe des taux forward. Cela signifie que la courbe des taux forward est sensible aux variations des taux de swap. En effet, les taux swap sont des instruments financiers qui permettent de se couvrir contre les variations des taux d’intérêt.\n\n## II. Valorisation de swaptions et de caplets\n\n1. Pour coter les caplets/floorlets et swaptions, le modèle de Black est souvent utilisé. Ce modèle est basé sur l'hypothèse que les taux d'intérêt sont log-normalement distribués. Il permet de calculer le prix d'un caplet/floorlet et d'un swaption en fonction des taux d'intérêt et de la volatilité implicite. \n\n2.  L'EDS (Equation Différentielle Stochastique) de Black est donnée par :\n\n$$\ndL(t) = \\sigma L(t) dW(t)\n$$\n\navec $L(t)$ le taux, $\\sigma$ la volatilité du taux et $W(t)$ un mouvement brownien.\nEn utilisant le changement de numéraire, ce taux est une martingale sous la mesure du numeraire (probabilité risque neutre). Cela  permet de calculer le prix d'un caplet/floorlet ou d'une swaption.\n\n\n**Caplets et Floorlets**\n\n3.  Pour un caplet, le prix est donné par la formule suivante :\n\n$$\nCaplet(t,T_{i-1},T_i) = N \\delta_i B(t,T_i) \\left[ L_i(t) \\phi(d) - K \\phi (d - \\sigma_i \\sqrt{T_{i-1}-t} )\\right]\n$$\n\n\navec $d = \\frac{1}{\\sigma \\sqrt{T_{i-1}-t}} \\left( \\ln \\left( \\frac{L_i(t)}{K} \\right) + \\frac{\\sigma^2(T_{i-1}-t)}{2} \\right)$, $L_i(t)$ le taux forward 3M à la date t, $K$ le strike du caplet, $N$ le nominal, $\\delta_i$ la période de capitalisation, $B(t,T_i)$ le facteur d'actualisation à la maturité $T_i$, $\\sigma_i$ la volatilité du taux forward 3M à la maturité $T_i$ et $\\phi$ la fonction de répartition de la loi normale standard.\n\nPour un floorlet, le prix est donné par la formule suivante :\n\n$$\nFloorlet(t,T_{i-1},T_i) = N \\delta_i B(t,T_i) \\left[ K \\phi (d - \\sigma_i \\sqrt(T_{i-1}-t) ) - L_i(t) \\phi(d) \\right]\n$$\n\n**Swaptions**\n\nPour un swaption donneur, le prix est donné par la formule suivante :\n\n$$\n\\text{Swaption}_t = \\left( \\sum_{j=1}^{n} N \\delta B(t, T_j) \\right) \\left[ F_S(t) \\Phi(d) - K \\Phi(d - \\sigma_S \\sqrt{T_0 - t}) \\right]\n$$\n\navec $F_S(t)$ le taux swap à la date t, $K$ le strike du swaption, $N$ le nominal, $\\delta$ la période de capitalisation, $B(t,T_j)$ le facteur d'actualisation à la maturité $T_j$, $\\sigma_S$ la volatilité du taux swap et $\\Phi$ la fonction de répartition de la loi normale standard.\n\nd est donné par la formule suivante :\n\n$$\nd = \\frac{1}{\\sigma_S \\sqrt{T_0 - t}} \\left( \\ln \\left( \\frac{F_S(t)}{K} \\right) + \\frac{\\sigma_S^2(T_0 - t)}{2} \\right)\n$$\n\nPour un swaption receveur, le prix est donné par la formule suivante :\n\n$$\n\\text{Swaption}_t = \\left( \\sum_{j=1}^{n} N \\delta B(t, T_j) \\right) \\left[ K \\Phi(d - \\sigma_S \\sqrt{T_0 - t}) - F_S(t) \\Phi(d) \\right]\n$$\n\n\nIl s'agit, à partir des cotations décrites dans le tableau ci-dessous et de la courbe des taux zéro-coupon construite précédemment, calculer les prix de marché de caplets sur euribor12M, ce qui implique une période de capitalisation annuelle, de maturité T = 5Y, i.e. payé à 6Y, et de strikes K associés au tableau. Nous souhaitons ainsi calculer :\n- Le prix des caplets Caplet(t, 5Y, 6Y) pour les strikes du tableau ci-dessous.\n- Le prix des swaptions Swaption(t, 5Y, 6Y) pour les strikes du tableau ci-dessous.\n\n::: {#adc05a4a .cell execution_count=17}\n``` {.python .cell-code}\nvol_data = pd.read_excel('data/Data_tx.xlsx', sheet_name='vol')\nvol_data\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Strike en bps et en rel. / fwd</th>\n      <th>Vols Caplets</th>\n      <th>Vols Swaptions</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>-100</td>\n      <td>0.311859</td>\n      <td>0.311859</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>-50</td>\n      <td>0.283274</td>\n      <td>0.283274</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>-25</td>\n      <td>0.265921</td>\n      <td>0.265921</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0</td>\n      <td>0.250000</td>\n      <td>0.250000</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>25</td>\n      <td>0.243451</td>\n      <td>0.243451</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>50</td>\n      <td>0.249019</td>\n      <td>0.249019</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>100</td>\n      <td>0.271828</td>\n      <td>0.271828</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#f1836d22 .cell execution_count=18}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.stats import norm\n\ndef price_oplet(N, delta_i, B_t_Ti, L_i_t, K, sigma_i, Ti, t, option_type='caplet'):\n    \"\"\"\n    Calcule la valeur d'un caplet selon le modèle de Black.\n\n    Paramètres :\n    - N : Notional\n    - delta_i : Période du caplet \n    - B_t_Ti : Facteur d'actualisation B(t, Ti)\n    - L_i_t : Taux forward Li(t)\n    - K : Strike du caplet\n    - sigma_i : Volatilité implicite\n    - Ti_1 : Date de début de la période\n    - Ti : Date de fin de la période\n    - t : Temps actuel\n\n    Retourne :\n    - Valeur du caplet\n    \"\"\"\n    Ti_1 = Ti - delta_i\n    d1 = (np.log(L_i_t / K) + 0.5 * sigma_i**2 * (Ti_1 - t)) / (sigma_i * np.sqrt(Ti_1 - t))\n    d2 = sigma_i * np.sqrt(Ti_1 - t) - d1\n    if option_type == 'caplet':\n        price = N * delta_i * B_t_Ti * (L_i_t * norm.cdf(d1) - K * norm.cdf(-d2))\n    elif option_type == 'floorlet':\n        price = N * delta_i * B_t_Ti * (K * norm.cdf(d2) - L_i_t * norm.cdf(-d1))\n    return price\n\nfor i in vol_data.index:\n    # Notional\n    N = 1  \n\n    # Période du caplet\n    delta_i = 1 \n\n    # Maturité du caplet\n    T=5 \n\n    # Facteur d'actualisation B(t, Ti)\n    B_t_Ti = df_ZC.loc[df_ZC['T'] == T+1, 'B'].values[0]\n\n    # Taux forward Li(t)\n    L_i_t = (1/delta_i) * ((df_ZC.loc[df_ZC['T'] == T, 'B'].values[0]/df_ZC.loc[df_ZC['T'] == T+1, 'B'].values[0]) - 1)\n\n    # Strike du caplet\n    K = L_i_t + vol_data.loc[i, 'Strike en bps et en rel. / fwd']/10000\n\n    # Volatilité implicite\n    sigma_i = vol_data.loc[i, \"Vols Caplets\"]  \n\n    # Date de début de la période\n    Ti = T + delta_i\n\n    # Temps actuel\n    t = 0  \n\n    caplet_price = price_oplet(N, delta_i, B_t_Ti, L_i_t, K, sigma_i, Ti, t, option_type='caplet')\n    vol_data.loc[i, 'Caplet Price MKT'] = caplet_price\n\nvol_data\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Strike en bps et en rel. / fwd</th>\n      <th>Vols Caplets</th>\n      <th>Vols Swaptions</th>\n      <th>Caplet Price MKT</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>-100</td>\n      <td>0.311859</td>\n      <td>0.311859</td>\n      <td>0.012511</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>-50</td>\n      <td>0.283274</td>\n      <td>0.283274</td>\n      <td>0.009788</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>-25</td>\n      <td>0.265921</td>\n      <td>0.265921</td>\n      <td>0.008419</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0</td>\n      <td>0.250000</td>\n      <td>0.250000</td>\n      <td>0.007137</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>25</td>\n      <td>0.243451</td>\n      <td>0.243451</td>\n      <td>0.006185</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>50</td>\n      <td>0.249019</td>\n      <td>0.249019</td>\n      <td>0.005661</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>100</td>\n      <td>0.271828</td>\n      <td>0.271828</td>\n      <td>0.005167</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#a1cbec8f .cell execution_count=19}\n``` {.python .cell-code}\n# pricer les swaptions\n```\n:::\n\n\n## III. Modèle de Hull-White\n\n\n#### III.1 Du modèle HJM vers le modèle Hull&amp;White\n\nPour une maturité $T$ fixée, Heath, Jarrow et Morton ont supposé que le taux forward instantané évolue selon la dynamique suivante :\n\n$$\ndf(t, T) = \\alpha(t, T)\\, dt + \\sigma(t, T)\\, dW_t \\quad (1)\n$$\n\nLa dynamique (1) ne se place pas forcément dans un cadre sans opportunité d’arbitrage. Les auteurs ont montré que le processus $\\alpha$ ne pouvait pas être choisi arbitrairement et que, pour qu’il existe une unique mesure martingale équivalente, $\\alpha$ devait être lié à la volatilité du zéro coupon.\n\nSupposons donc l’existence d’une unique mesure martingale équivalente $\\mathbb{Q}$ (mesure risque-neutre) dont le numéraire est l’actif sans risque.\n\nOn suppose que le prix du zéro coupon (payant une unité de devise en date $T$) évolue sous $\\mathbb{Q}$ selon l’EDS :\n\n$$\n\\frac{dB(t, T)}{B(t, T)} = r_t\\, dt + \\Gamma(t, T)\\, dW_t^Q \\quad (2)\n$$\n\nPar définition, on sait que\n$\nB(t, T) = e^{-\\int_t^T f(t,s)\\, ds}$\net que\n$\nf(t, T) = -\\partial_T \\ln\\bigl(B(t, T)\\bigr).\n$\n\n\nEn appliquant le lemme d’Itô, on obtient :\n$\ndf(t, T) = \\Gamma(t, T)\\, \\partial_T \\Gamma(t, T)\\, dt - \\partial_T \\Gamma(t, T)\\, dW_t^Q.\n$\n\nEn posant\n$\n-\\partial_T \\Gamma(t, T) = \\gamma(t, T),\n$\nnous obtenons :\n\n$$\ndf(t, T) = \\gamma(t, T) \\int_t^T \\gamma(t, u)\\, du \\, dt + \\gamma(t, T)\\, dW_t^Q \\quad (3)\n$$\n\nAprès intégration, on retrouve finalement :\n\n$$\nf(t, T) = f(0, T) + \\int_0^t \\gamma(s, T) \\left( \\int_s^T \\gamma(s, u)\\, du \\right) ds + \\int_0^t \\gamma(s, T)\\, dW_s^Q \\quad (4)\n$$\n\n\n#### III.2 Hypothèses du modèle Hull&amp;White\n\nOn suppose que le modèle HJM est gaussien, linéaire et calibrable. Ces hypothèses permettent d’écrire :\n\n$$\n\\gamma(t, T) = \\sigma(t)\\, e^{-\\lambda (T-t)}  \\quad \\text{ et} \\quad \\Gamma(t, T) = \\frac{\\sigma(t)}{\\lambda}\\Bigl(e^{-\\lambda (T-t)} - 1\\Bigr)\n$$\n\noù la fonction de volatilité instantanée $\\sigma(t)$ est constante par morceaux.\n\n\n#### III.3 Construction de la formule zéro-coupon\n\nDans le cadre du modèle Hull&White, la dynamique du taux court instantané $r_t$ s’écrit :\n\n$$\ndr_t = \\left[\\lambda\\bigl(f(0,t) - r_t\\bigr) + \\partial_t f(0,t) + \\int_0^t \\sigma^2(s)\\, e^{-2\\lambda (t-s)} ds \\right] dt + \\sigma(t)\\, dW_t^Q \\quad (5)\n$$\n\nOn introduit alors une nouvelle variable d’état : $ X_t = r_t - f(0,t)$\n\nLa dynamique de $X_t$ devient :\n\n$$\ndX_t = \\left[\\varphi(t) - \\lambda X_t\\right] dt + \\sigma(t)\\, dW_t^Q \\quad (8)\n$$\n\navec\n$\n\\varphi(t) = \\int_0^t \\sigma^2(s)\\, e^{-2\\lambda (t-s)} ds.\n$\n\nLa formule du prix du zéro coupon s’exprime alors comme une fonction déterministe de $X_t$ :\n\n$$\nB(t, T) = \\frac{B(0,T)}{B(0,t)} \\exp\\!\\Biggl\\{ -\\frac{1}{2\\beta^2(t,T)} \\varphi(t) - \\beta(t,T) X_t \\Biggr\\} \\quad (9)\n$$\n\noù\n$\n\\beta(t, T) = \\frac{1 - e^{-\\lambda (T-t)}}{\\lambda}.\n$\n\n1. A quelle catégorie de modèle appartient le modèle Hull&White? Justifier.\n\nLe modèle Hull & White est un modèle à structure à terme aﬃne, i.e. un modèle de taux d’intérêt pour lequel le taux zéro-coupon continu R(t, T ) est une fonction aﬃne du taux court r (t). \n\nIl ressemble à un processus d’Ornstein-Uhlenbeck ou mean reversing process, qui est un processus gaussien définit de la manière suivante :\n\n$$\ndY_t = - \\theta \\left[Y_t - \\mu \\right] dt + \\sigma dW_t,\n$$\n\noù $\\theta, \\mu, \\sigma$ sont des paramètres déterministes et $W_t$ est le processus de Wiener.\n\nDans notre cas, on a $\\theta = \\lambda$, $\\mu = \\frac{\\phi(t)}{\\lambda}$ et $\\sigma = \\sigma(t)$. De ce fait, la moyenne et la variance dépend du temps et le paramètre de vitesse de retour à la moyenne est constant.\n\n2. Déterminer la loi du processus $X_t|X_s$?\n\nSous la probabilité risque neute $\\mathbb{Q}$, le processus $X_t$ s'ecrit :\n\n$$\ndX_t = \\left(\\phi(t)- \\lambda X_t \\right) dt + \\sigma(t) dW_t^Q,\n$$\n\navec $\\phi(t) = \\int_0^t \\sigma^2(s) e^{-2\\lambda(t-s)} ds$.\n\nPosons $K_t = e^{\\lambda t} X_t  = f(X_t, t)\\implies X_t = e^{-\\lambda t} K_t$, par la formule d'Itô, on a :\n\n\\begin{aligned}\ndf(X_t, t) &= e^{\\lambda t} dX_t + de^{\\lambda t} X_t \\\\\n&= e^{\\lambda t} \\left( \\phi(t) - \\lambda X_t \\right) dt + e^{\\lambda t} \\sigma(t) dW_t^Q + e^{\\lambda t} X_t dt \\\\\n&= e^{\\lambda t}\\phi(t) dt + e^{\\lambda t}\\sigma(t)dW_t^Q \\\\\n&\\implies f(X_t, t) = K_t = e^{- \\lambda t}K_s  + \\int_s^t e^{-\\lambda(t-u)}\\phi(u) du + \\int_s^t e^{-\\lambda(t-u)}\\sigma(u)dW_u^Q \\\\\n&\\Leftrightarrow X_t = X_s e^{-\\lambda (t-s)} + \\int_s^t e^{-\\lambda (t-u)} \\phi(u)  du + \\int_s^t e^{-\\lambda (t-u)} \\sigma(u) dW_u^T\n\\end{aligned}\n\nDe ce fait, on en déduit que $X_t|X_s \\sim \\mathcal{N}\\left( X_s e^{-\\lambda (t-s)} + \\int_s^t e^{-\\lambda (t-u)} \\phi(u)  du, \\quad \\int_s^t e^{-2 \\lambda (t-u)} \\sigma(u)^2 d \\right) $.\n\n\n\n#### III.4 Dynamique des taux forwards\n\nOn note ensuite $L_i(t)$ le taux LIBOR forward à la date $t$ qui fixe en $T_i$ et paie en $T_{i+1}$. Sous l’hypothèse d’absence d’opportunité d’arbitrage, ce taux s’exprime à partir de la courbe de taux :\nÎ\n$$\nL_i(t) = \\frac{1}{\\delta_i}\\left(\\frac{B(t, T_i)}{B(t, T_{i+1})} - 1\\right)  = \\frac{1}{\\delta_i}\\left(Z_t- 1\\right) ,\n$$\n\nPour connaitre la dynamique des taux forwards, on applique le lemme d’Itô au processus :\n\n$$\nZ_t = \\frac{B(t, T_i)}{B(t, T_{i+1})}.\n$$\n\n<blockquote>\nRappel du lemme d’Itô : \nConsidérons deux actifs $X$ et $Y$ et posons $Z = \\frac{X}{Y}$ (la valeur de $X$ exprimée en numéraire $Y$). Le lemme d’Itô nous donne l’évolution de $Z$ par :\n\n$$\n\\frac{dZ}{Z} = \\left(\\frac{dX}{X} - \\frac{dY}{Y}\\right) - \\left\\langle \\frac{dX}{X} - \\frac{dY}{Y},\\, \\frac{dY}{Y}\\right\\rangle.\n$$\n</blockquote>\n\n\n\n\nEn appliquant le lemme d’Itô à $Z_t$, on obtient :\n\n\\begin{aligned}\n\\frac{dZ_t}{Z_t} &= \\frac{dB(t, T_i)}{B(t, T_i)} - \\frac{dB(t, T_{i+1})}{B(t, T_{i+1})} \\\\\n&- \\frac{1}{\\cancel{B(t,T_{i+1})^2}} \\cancel{B(t,T_{i+1})^2} \\, \\Gamma(t,T_i,T_{i+1})^2 \\, dt \\\\\n&-  \\frac{-1}{\\cancel{B(t,T_i)B(t,T_{i+1})}} \\cancel{B(t,T_i)B(t,T_{i+1})}\\,\\Gamma(t,T_i)\\Gamma(t,T_{i+1})\\,dt\\\\\n&= \\Gamma(t,T_i,T_{i+1})\\left(\\Gamma(t,T_{i+1}) - \\Gamma(t,T_i)\\right)dt + \\left(\\Gamma(t,T_i) - \\Gamma(t,T_{i+1})\\right)dW_t^Q\\\\\n&\\implies \\frac{dZ_t}{Z_t} = \\mu(t,T_i,T_{i+1})\\,dt + \\sigma(t,T_i,T_{i+1})\\,dW_t^Q\n\\end{aligned}\n\navec\n\n\\begin{cases}\n\\sigma(t,T_i,T_{i+1}) = \\Gamma(t,T_i) - \\Gamma(t,T_{i+1})\\\\\n\\mu(t,T_i,T_{i+1}) = \\Gamma(t,T_i)\\left(\\Gamma(t,T_{i+1}) - \\Gamma(t,T_i) \\right) = - \\Gamma(t,T_i) \\sigma(t,T_i,T_{i+1})\n\\end{cases}\n\nDe ce fait, on a :\n\n\\begin{aligned}\n\\frac{dZ_t}{Z_t} &= - \\Gamma(t,T_i) \\sigma(t,T_i,T_{i+1})\\,dt + \\sigma(t,T_i,T_{i+1})\\,dW_t^Q\\\\\n&= \\sigma(t,T_i,T_{i+1}) \\underbrace{\\left( - \\Gamma(t,T_i)\\,dt + dW_t^Q \\right)}_{d\\tilde{W_t}}\\\\\n&= \\sigma(t,T_i,T_{i+1}) d\\tilde{W_t}\n\\end{aligned}\noù $d\\tilde{W_t}$ est un mouvement brownien selon le théorème de Girsanov.\n\nLa diffusion de $Z_t$ est une loi log-normale, sans drift sous la probabilité risque forward. De ce fait, il suit le modèle de Black pour la valorisation des options.\n\n\nOn peut écrire ainsi la dynamique du taux forward $L_i(t)$ sous la probabilité risque forward :\n\n\\begin{aligned}\ndL_i(t) &= \\frac{Z_t}{\\delta_i} \\sigma(t,T_i,T_{i+1})  d\\tilde{W_t}  \\\\\n&= (L_i(t) + \\frac{1}{\\delta_i}) \\sigma(t,T_i,T_{i+1})  d\\tilde{W_t} \n\\end{aligned}\n\n\n#### III.5 Valorisation des instruments de calibration\n\n1. **Payoff d’un caplet vanille :**  \nLe payoff d’un caplet sur le taux LIBOR $L_i(T_i)$, de maturité $T_i$, avec paiement en $T_{i+1}$ et de strike $K$ est donné par :\n\n$$\n\\text{Payoff} = \\delta_i\\, \\max\\Bigl( L_i(T_i) - K,\\; 0 \\Bigr).\n$$\n\n2. **Formule de valorisation dans le cadre du modèle H&amp;W :**  \nIl peut être démontré que la formule de valorisation de ce caplet s’exprime de la manière suivante :\n\n$$\nC\\Bigl( Z_t,\\, \\tilde{K},\\, T_i,\\, \\sigma_i^*,\\, B(t, T_{i+1}) \\Bigr) \\quad (11)\n$$\n\navec :\n\n- $ Z_t = \\dfrac{B(t, T_i)}{B(t, T_{i+1})} $,\n- $ (\\sigma_i^*)^2 = \\frac{1}{T_i - t} \\int_t^{T_i} \\left( \\Gamma(s, T_i) - \\Gamma(s, T_{i+1}) \\right)^2 ds = \\frac{1}{T_i} \\beta^2(T_i, T_{i+1})\\, \\varphi(T_i) $,\n- $ \\tilde{K} = 1 + \\delta_i K $,\n- $ C(\\cdot) $ désigne le prix d’un Call selon le cadre Black, en fonction du forward, du strike, de la maturité, de la volatilité et du facteur d’actualisation.\n\nEn effet, on peut réécrire le payoff d’un caplet sous la forme d’un Call sur $Z_t$ qui suit un modèle de Black :\n\n\\begin{aligned}\n\\text{Payoff} &= \\delta_i\\, \\max\\Bigl( L_i(T_i) - K,\\; 0 \\Bigr) \\\\\n&= \\delta_i\\, \\max\\Bigl( \\frac{Z_t}{\\delta_i} - 1 - K; 0 \\Bigr) \\\\\n&= \\delta_i\\, \\max\\Bigl( \\frac{Z_t - 1 - \\delta_i K}{\\delta_i}; 0 \\Bigr) \\\\\n&= \\max\\Bigl(Z_t - 1 - \\delta_i K; 0 \\Bigr) \\\\\n\\text{Payoff} &= \\max\\Bigl( Z_t - \\tilde{K},\\; 0 \\Bigr) \\\\\n\\end{aligned}\n\n### III.6. Calibration du modèle\n\nLe modèle de Hull White permet d'avoir une formule fermée pour le prix des caplets. De fait, puisqu'on a calculé les prix de marché de caplets sur euribor12M, ce qui implique une période de capitalisation annuelle, de maturité T = 5Y, nous pouvons desormais calibrer le paramètre de volatilité $\\sigma_i^*$  avec la méthode de dichotomie et aussi extraire de manière analytique la volatilité instantanée $\\sigma(t)$ du modèle Hull&White, qu'on supposera constante, i.e. $\\sigma(t) = \\sigma$.\n\nOn pose également, pour la calibration, $\\lambda = 5\\%$.\n\nPour extraire la volatilité spot, nous utiliserons uniquement le prix de marche ATM.\n\n::: {#8c82239f .cell execution_count=20}\n``` {.python .cell-code}\ncaplet_price_MKT = vol_data.loc[3, 'Caplet Price MKT']\nprint(f\"Le prix de marché caplet sur euribor 12M de maturité T=5Y est de {caplet_price_MKT:.4%}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLe prix de marché caplet sur euribor 12M de maturité T=5Y est de 0.7137%\n```\n:::\n:::\n\n\n::: {#3b9ee3b4 .cell execution_count=21}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.stats import norm\n\ndef price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_i, option_type='caplet', model='HW'):\n    if model == \"HW\" :\n        Z_t = delta_i * L_i_t + 1\n        K = 1 + delta_i * K\n        return price_oplet(N=N, delta_i=delta_i, B_t_Ti=B_t_Ti, L_i_t=Z_t, K=K, sigma_i=sigma_i, Ti=Ti, t=t, option_type=option_type)\n    else:\n        return price_oplet(N=N, delta_i=delta_i, B_t_Ti=B_t_Ti, L_i_t=L_i_t, K=K, sigma_i=sigma_i, Ti=Ti, t=t, option_type=option_type)\n```\n:::\n\n\n::: {#45e22637 .cell execution_count=22}\n``` {.python .cell-code}\ndef Dichotomie(N, delta_i, B_t_Ti, L_i_t, K, Ti, t,caplet_price_MKT,option_type='caplet', model=\"HW\",tol=1e-6, sigma_low=1/10000, sigma_high=1):\n    \"\"\"\n    Extrait la volatilité implicite sigma en utilisant la méthode de dichotomie.\n    \"\"\"\n    fmin = price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_low, option_type=option_type, model=model)\n    fmax = price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_high,option_type=option_type, model=model)\n    price = caplet_price_MKT\n    if fmin>price :\n        return sigma_low\n    elif fmax<price :\n        return sigma_high\n    else:\n        while sigma_high-sigma_low>tol:\n            sigma_mid = (sigma_low + sigma_high) / 2\n            fmin = price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_low, option_type=option_type, model=model)\n            fmid = price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_mid,option_type=option_type, model=model)\n            if ((fmin - price) * (fmid - price) > 0) : # jette la moitié de gauche\n                sigma_low = sigma_mid\n            else: # jette la moitié de droite\n                sigma_high = sigma_mid\n        sigma_mid = (sigma_low + sigma_high) / 2\n        return sigma_mid\n    \n\n# Notional\nN = 1  \n\n# Période du caplet\ndelta_i = 1 \n\n# Maturité du caplet\nTi=6\n\n# Facteur d'actualisation B(t, Ti)\nB_t_Ti = df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0]\n\n# Taux forward Li(t)\nL_i_t = (1/delta_i) * ((df_ZC.loc[df_ZC['T'] == Ti-1, 'B'].values[0]/df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0]) - 1)\n\n# Strike du caplet\nK = L_i_t + vol_data.loc[3, 'Strike en bps et en rel. / fwd']/10000\n\nlambda_ = 5/100\n\nsigma_i = Dichotomie(N, delta_i, B_t_Ti, L_i_t, K, Ti, t,caplet_price_MKT, option_type='caplet',model=\"HW\")\nprint(\"Volatilité implicite (en %) :\", sigma_i*100) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVolatilité implicite (en %) : 0.9271045541763303\n```\n:::\n:::\n\n\n::: {#d9959dd1 .cell execution_count=23}\n``` {.python .cell-code}\nbeta_Ti_Ti_1 =  ((1 - np.exp(- lambda_ * delta_i))/lambda_)**2\nTi_1 = Ti - delta_i\nphi = (1 - np.exp(-2*lambda_*(Ti_1-t)))/(2*lambda_)\nsigma = np.sqrt((sigma_i**2 * Ti_1)/ (beta_Ti_Ti_1 * phi))\n\nprint(\"Volatilité instantanée (en %) :\", sigma*100) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVolatilité instantanée (en %) : 1.071446257025021\n```\n:::\n:::\n\n\n2. Cette volatilité spot nous permet de valoriiser les caplets pour des strikes différents de l'ATM à l'aide de la formule de valorisation fermée du modèle Hull et White.\n\n::: {#4d41d6ea .cell execution_count=24}\n``` {.python .cell-code}\nfor i in vol_data.index:\n    # Notional\n    N = 1  \n\n    # Période du caplet\n    delta_i = 1 \n\n    # Maturité du caplet\n    Ti=6\n\n    # Facteur d'actualisation B(t, Ti)\n    B_t_Ti = df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0]\n\n    # Taux forward Li(t)\n    L_i_t = (1/delta_i) * ((df_ZC.loc[df_ZC['T'] == Ti-1, 'B'].values[0]/df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0]) - 1)\n\n    # Strike du caplet\n    K = L_i_t + vol_data.loc[i, 'Strike en bps et en rel. / fwd']/10000\n\n    sigma_i = sigma_i\n\n    lambda_ = 5/100\n\n    caplet_price = price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_i, option_type='caplet', model='HW')\n    vol_data.loc[i, 'Caplet Price HW'] = caplet_price\n\nvol_data\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Strike en bps et en rel. / fwd</th>\n      <th>Vols Caplets</th>\n      <th>Vols Swaptions</th>\n      <th>Caplet Price MKT</th>\n      <th>Caplet Price HW</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>-100</td>\n      <td>0.311859</td>\n      <td>0.311859</td>\n      <td>0.012511</td>\n      <td>0.012015</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>-50</td>\n      <td>0.283274</td>\n      <td>0.283274</td>\n      <td>0.009788</td>\n      <td>0.009389</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>-25</td>\n      <td>0.265921</td>\n      <td>0.265921</td>\n      <td>0.008419</td>\n      <td>0.008215</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0</td>\n      <td>0.250000</td>\n      <td>0.250000</td>\n      <td>0.007137</td>\n      <td>0.007137</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>25</td>\n      <td>0.243451</td>\n      <td>0.243451</td>\n      <td>0.006185</td>\n      <td>0.006156</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>50</td>\n      <td>0.249019</td>\n      <td>0.249019</td>\n      <td>0.005661</td>\n      <td>0.005269</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>100</td>\n      <td>0.271828</td>\n      <td>0.271828</td>\n      <td>0.005167</td>\n      <td>0.003771</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nL'une des faiblesses du modèle de Hull et White est le fait qu'il n'arrive pas à capter le smile de volatilité. En effet, la volatilité implicite extraite est un skew. Pour constater ce phénomène, nous inverserons la formule de Black pour les caplets et nous en déduirons la volatilité implicite pour chaque strike. Nous utiliserons toujours la méthode de dichotomie pour trouver la volatilité implicite.\n\n::: {#7d3aba42 .cell execution_count=25}\n``` {.python .cell-code}\nfor i in vol_data.index:\n    N = 1\n    delta_i = 1\n    Ti = 6\n    B_t_Ti = df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0]\n    L_i_t = (1 / delta_i) * ((df_ZC.loc[df_ZC['T'] == Ti-1, 'B'].values[0] / df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0]) - 1)\n    K = L_i_t + vol_data.loc[i, 'Strike en bps et en rel. / fwd'] / 10000\n    lambda_ = 5 / 100\n    caplet_price_MKT = vol_data.loc[i, 'Caplet Price HW']\n\n    sigma_extracted =  Dichotomie(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, caplet_price_MKT, option_type='caplet', model='Black')\n    vol_data.loc[i, 'Sigma_HW'] = sigma_extracted\n\nvol_data\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Strike en bps et en rel. / fwd</th>\n      <th>Vols Caplets</th>\n      <th>Vols Swaptions</th>\n      <th>Caplet Price MKT</th>\n      <th>Caplet Price HW</th>\n      <th>Sigma_HW</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>-100</td>\n      <td>0.311859</td>\n      <td>0.311859</td>\n      <td>0.012511</td>\n      <td>0.012015</td>\n      <td>0.288669</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>-50</td>\n      <td>0.283274</td>\n      <td>0.283274</td>\n      <td>0.009788</td>\n      <td>0.009389</td>\n      <td>0.267386</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>-25</td>\n      <td>0.265921</td>\n      <td>0.265921</td>\n      <td>0.008419</td>\n      <td>0.008215</td>\n      <td>0.258287</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0</td>\n      <td>0.250000</td>\n      <td>0.250000</td>\n      <td>0.007137</td>\n      <td>0.007137</td>\n      <td>0.250009</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>25</td>\n      <td>0.243451</td>\n      <td>0.243451</td>\n      <td>0.006185</td>\n      <td>0.006156</td>\n      <td>0.242433</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>50</td>\n      <td>0.249019</td>\n      <td>0.249019</td>\n      <td>0.005661</td>\n      <td>0.005269</td>\n      <td>0.235466</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>100</td>\n      <td>0.271828</td>\n      <td>0.271828</td>\n      <td>0.005167</td>\n      <td>0.003771</td>\n      <td>0.223060</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#95d34c5b .cell execution_count=26}\n``` {.python .cell-code}\nplt.figure(figsize=(8, 5))\nplt.plot(vol_data[\"Strike en bps et en rel. / fwd\"], vol_data[\"Sigma_HW\"], label='Volatilité extraite', marker='o')\nplt.plot(vol_data[\"Strike en bps et en rel. / fwd\"], vol_data[\"Vols Caplets\"], label='Volatilité de marché', marker='o')\nplt.legend()\nplt.title('Comparaison de la volatilité extraite par le modèle HW et la volatilité de marché')\nplt.xlabel('Strike en bps et en rel. / fwd ')\nplt.ylabel('Volatilité')\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nText(0, 0.5, 'Volatilité')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-26-output-2.png){width=697 height=450}\n:::\n:::\n\n\n::: {#160af4ce .cell execution_count=27}\n``` {.python .cell-code}\nATM  = L_i_t\n```\n:::\n\n\n### 3.7 Valorisation d’un produit structuré\n\n<blockquote>\nRemarques préliminaires :\n\n- Nous garderons dans un premier temps la calibration ATM effectuée avec $\\lambda = 5\\%$.\n- Pour la partie Monte-Carlo, nous admettrons que l’EDS pour le processus $X_t$ sous la probabilité forward neutre $Q^T$ associée au numéraire $B(t,T)$ s’écrit comme :\n\n$$\ndX_t = \\left[\\phi(t) + \\sigma(t)\\Gamma(t,T) - \\lambda X_t\\right] dt + \\sigma(t) dW_t^T \\tag{12}\n$$\n\nOù $W_t^T$ est un brownien sous $Q^T$.\n</blockquote>\n\nNous souhaitons valoriser un caplet de strike $K$, de dates de fixing $T_i = 5Y$ et de paiement $T_{i+1} = 6Y$ et de barrière désactivante $B$ (avec $B > K$).\n\n1. Écrire le payoff de l’option et tracer la fonction de payoff en fonction de $L_i(T_i)$. Cette option est-elle plus ou moins chère qu’un simple caplet de strike $K$ ?\n\nLe payoff de l'option est donné par :\n\n$$\n\\text{Payoff} = \\delta_i\\, \\max\\Bigl( L_i(T_i) - K,\\; 0 \\Bigr) \\mathbb{1}_{L_i(T_i) < B}\n$$\n\n![image-2.png](attachment:image-2.png){width=50%}\n\nIl est possible de décomposer le payoff à partir d'options vanilles et digitales :\n\n$$\n\\text{Payoff} = C_K - CB - (B-K) \\times D_B\n$$\n\n<blockquote>\nUne option digitale est une option qui paie 1 si le sous-jacent est au-dessus d'un certain seuil et 0 sinon. De ce fait, le payoff de l'option est donné par :\n\n$$\nD_B = \\delta_i\\, \\max\\Bigl( L_i(T_i) - K,\\; 0 \\Bigr) \\mathbb{1}_{L_i(T_i) > K} \n$$\n\n![image.png](attachment:image.png){width=50%}\n\nUne option vanille est un contrat financier standardisé qui donne le droit, mais non l'obligation, d'acheter (call) ou de vendre (put) un actif sous-jacent à un prix fixé (strike) à une date donnée (maturité). De ce fait, dans le cas d'un call, le payoff de l'option est donné par :\n\n$$\nC_K = \\delta_i\\, \\max\\Bigl( L_i(T_i) - K,\\; 0 \\Bigr)\n$$\n\n![Capture d’écran 2025-03-05 à 00.17.09.png](<attachment:Capture d’écran 2025-03-05 à 00.17.09.png>){width=50%}\n\n</blockquote>\n\n3. Rappeler les principes du pricing par méthode de Monte-Carlo.\n\nLa méthode de Monte-Carlo est une méthode numérique qui permet de pricer des produits financiers complexes lorsque les formules fermées ne sont pas disponibles.  Elle consiste à simuler un grand nombre $N$ de trajectoires du processus stochastique et à calculer la moyenne empiriques des payoffs actualisés pour obtenir le prix de l'option.\n\n4. Rappeler comment on simule une loi gaussienne à partir d’une loi uniforme.\n\n\nPour simuler une variable aléatoire suivant une loi gaussienne standard $\\mathcal{N}(0,1)$ à partir d'une variable uniforme $U$ sur $[0,1]$, on applique l'**inverse de la fonction de répartition de la loi gaussienne standard** (aussi appelée la fonction quantile de la loi normale) :\n\n$$\nX = F^{-1}(U)\n$$\n\noù $F$ est la fonction de répartition de la loi normale standard.\n\n\n\n5. On considère un caplet sur euribor12M à barrière désactivante de strike $ K = ATM - 100 bps$, de barrière $B = ATM + 100 bps$ et de maturité $T_i = 5Y$. Pour valoriser cette option, nous allons utiliser une méthode numérique de type Monte-Carlo. Pour cela, il est necessaire de connaire la loi de X_t sachant X_s. En nous aidant de la question précédente, on peut déduire que la loi de $X_t|X_s$ est une loi normale de paramètres :\n\n$$\nX_t|X_s \\sim \\mathcal{N}\\left( X_s e^{-\\lambda (t-s)} + \\int_s^t e^{-\\lambda (t-u)} \\left( \\phi(u) - \\sigma \\Gamma(u,T) \\right) du, \\quad \\int_s^t e^{-2 \\lambda (t-u)} \\sigma^2 d \\right) \n$$\n\n\nPour valoriser cette option, nous pouvons directement utiliser la loi de $X_5|X_0$ pour simuler les trajectoires du taux court et calculer le payoff de l'option ou diffuser progressivement le taux court en utilisant la loi de $X_t|X_s$ pour chaque pas de temps. Ensuite, il s'agira de calculer le payoff de l'option à chaque date, en faire la moyenne et l'actualiser pour obtenir le prix de l'option.\n\n##### Méthode 1 : Simulation de la loi de $X_5|X_0$\n\n::: {#bf4450d6 .cell execution_count=28}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.integrate import quad\n\n# Fonction phi(t) - variance cumulée\ndef phi(t, sigma, lambda_):\n    return (sigma**2 / (2 * lambda_)) * (1 - np.exp(-2 * lambda_ * t))\n\n# Fonction beta(t, T)\ndef beta(t, T, lambda_):\n    return (1 - np.exp(-lambda_ * (T - t))) / lambda_\n\n# Fonction gamma(t, T)\ndef gamma(t, T, sigma, lambda_):\n    return (sigma / lambda_) * (np.exp(-lambda_ * (T - t)) - 1)\n\n# Fonction B(t, T)\ndef B_t_T(t, T, B0_T, B0_t, X_t, sigma, lambda_):\n    beta_t_T = beta(t, T, lambda_)**2\n    phi_t = phi(t, sigma, lambda_)\n    exponent = -0.5 * beta_t_T * phi_t - beta_t_T * X_t\n    return (B0_T / B0_t) * np.exp(exponent)\n\n# Fonction d'intégration avec paramètres supplémentaires\ndef integrand_mean(u, t, Xs, s, sigma, lambda_, T):\n    # t = borne sup\n    # s = borne inf\n    # T = maturité\n    Xt = Xs * np.exp(-lambda_ * (t - s))\n    exp_part = np.exp(-lambda_ * (t - u))\n    return Xt + exp_part * (phi(u, sigma, lambda_) + sigma * gamma(u, T, sigma, lambda_))\n\n# Paramètres\nT = Ti_1  = 5\nXs = X0 = 0  \ns = 0\nt = Ti_1 \n\n# Calcul de la moyenne conditionnelle\nmean_5_given_0, _ = quad(integrand_mean, s, t, args=(t, Xs, s, sigma, lambda_, T))\nprint(f\"Moyenne conditionnelle de X_5 | X_0 : {mean_5_given_0:.6f}\")\n\n# Calcul de la variance conditionnelle (indépendant de gamma ici)\n\ndef compute_variance(sigma, lambda_, t, s):\n    return (sigma**2) * (1 - np.exp(-2 * lambda_ * (t - s))) / (2 * lambda_)\nvar_5_given_0 = compute_variance(sigma, lambda_, t, s)\n# var_5_given_0 = (sigma**2) * (1 - np.exp(-2 * lambda_ * (t - s))) / (2 * lambda_)\nprint(f\"Variance conditionnelle de X_5 | X_0 : {var_5_given_0:.6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMoyenne conditionnelle de X_5 | X_0 : 0.000000\nVariance conditionnelle de X_5 | X_0 : 0.000452\n```\n:::\n:::\n\n\n::: {#a6413d3e .cell execution_count=29}\n``` {.python .cell-code}\nTi_1 = 5\nTi = 6\n\n# Simulation Monte Carlo\nn_simulations = 10000\n\npayoffs = np.zeros(n_simulations)\nfor sim in range(n_simulations):\n    phi_ = phi(Ti_1, sigma, lambda_)\n    gamma_ = gamma(Ti_1,Ti, sigma, lambda_)\n\n    # Moyenne\n    mu_X = mean_5_given_0\n\n    # Ecart-type\n    sigma_X = np.sqrt(var_5_given_0)\n\n    # X_5|X_0\n    X = np.random.normal(mu_X, sigma_X)  \n\n    # Calcul du prix B(5,6) selon Hull-White\n    B0_6 = df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0] # B(0,6)\n    B0_5 = df_ZC.loc[df_ZC['T'] == Ti_1, 'B'].values[0] # B(0,5)\n\n    B_5_6 = B_t_T(5, 6, B0_6, B0_5, X, sigma, lambda_)\n    B_5_5 = B_t_T(5, 5, B0_5, B0_5, X, sigma, lambda_)\n\n    # Calcul du taux forward L_i_t\n    L_i_t = ((B_5_5 / B_5_6) - 1)\n    bp = 100/10000\n\n    # Définition du strike\n    strike = ATM - bp\n\n    # Barrière\n    B = ATM + bp\n\n    # Payoff de l'option\n    payoff = np.maximum(L_i_t - strike, 0) * (L_i_t < B)\n    payoffs[sim] = payoff\n\n# Prix de l'option call\ncall_price = B0_6 * np.mean(payoffs)\nprint(f\"Prix du call : {call_price:.6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrix du call : 0.003048\n```\n:::\n:::\n\n\n##### Méthode 2 : Methode de diffusion\n\n::: {#5b230802 .cell execution_count=30}\n``` {.python .cell-code}\n# Simulation Monte Carlo\nn_simulations = 10000\n\npayoffs = np.zeros(n_simulations)\nX0 = 0\nTi = 6\nTi_1 = 5\nX = np.zeros(Ti)\nX[0] = X0\n\nfor sim in range(n_simulations):\n    phi_ = phi(Ti_1, sigma, lambda_)\n    gamma_ = gamma(Ti_1,Ti, sigma, lambda_)\n\n    for i in range(1,Ti):\n        t = i\n        s = i-1\n        T = 5 \n        Xs = X[i-1]\n\n        # Calcul de la moyenne conditionnelle\n        mu_X, _ = quad(integrand_mean, s, t, args=(t, Xs, s, sigma, lambda_, T))\n        sigma_X = np.sqrt(compute_variance(sigma, lambda_, t, s))\n        X[i] = np.random.normal(mu_X, sigma_X)\n\n    # Calcul du prix B(5,6) selon Hull-White\n    B0_6 = df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0] # B(0,6)\n    B0_5 = df_ZC.loc[df_ZC['T'] == Ti_1, 'B'].values[0] # B(0,5)\n\n    B_5_6 = B_t_T(5, 6, B0_6, B0_5, X[Ti_1], sigma, lambda_)\n    B_5_5 = B_t_T(5, 5, B0_5, B0_5, X[Ti_1], sigma, lambda_)\n\n    # Calcul du taux forward L_i_t\n    L_i_t = ((B_5_5 / B_5_6) - 1)\n    bp = 100/10000\n\n    # Définition du strike\n    strike = ATM - bp\n\n    # Barrière\n    B = ATM + bp\n\n    # Payoff de l'option\n    payoff = np.maximum(L_i_t - strike, 0) * (L_i_t < B)\n    payoffs[sim] = payoff\n\n# Prix de l'option call\ncall_price = B0_6 * np.mean(payoffs)\nprint(f\"Prix du call : {call_price:.6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrix du call : 0.003032\n```\n:::\n:::\n\n\nNous constatons qu'avec les deux méthodes, nous obtenons des prix d'options similaires (différent de 0.2bps). Cela confirme que les deux méthodes convergent vers le même résultat.\n\nEn dégénérant le produit en faisant tendre la barrière à $+\\infty$, nous constatons que le prix de l'option call est égal au prix de marché du forward.\nEn dégénérant le produit en faisant tendre la barrière à 0, nous constatons que le prix de l'option call est égal à 0. \n\nCela est cohérent car lorsque la barrière est très élevée, le produit est équivalent à un forward et lorsque la barrière est nulle, le produit est équivalent à un call classique. La fonction que nous avons implémenté est donc cohérente et bien implémentée.\n\n::: {#4b4de405 .cell execution_count=31}\n``` {.python .cell-code}\nTi_1 = 5\nTi = 6\n\n# Simulation Monte Carlo\nn_simulations = 10000\n\npayoffs = np.zeros(n_simulations)\nfor sim in range(n_simulations):\n    phi_ = phi(Ti_1, sigma, lambda_)\n    gamma_ = gamma(Ti_1,Ti, sigma, lambda_)\n\n    # Moyenne\n    mu_X = mean_5_given_0\n\n    # Ecart-type\n    sigma_X = np.sqrt(var_5_given_0)\n\n    # X_5|X_0\n    X = np.random.normal(mu_X, sigma_X)  \n\n    # Calcul du prix B(5,6) selon Hull-White\n    B0_6 = df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0] # B(0,6)\n    B0_5 = df_ZC.loc[df_ZC['T'] == Ti_1, 'B'].values[0] # B(0,5)\n\n    B_5_6 = B_t_T(5, 6, B0_6, B0_5, X, sigma, lambda_)\n    B_5_5 = B_t_T(5, 5, B0_5, B0_5, X, sigma, lambda_)\n\n    # Calcul du taux forward L_i_t\n    L_i_t = ((B_5_5 / B_5_6) - 1)\n    bp = 100/10000\n\n    # Définition du strike\n    strike = ATM # - bp\n\n    # Barrière\n    B = np.inf#ATM + bp\n\n    # Payoff de l'option\n    payoff = np.maximum(L_i_t - strike, 0) * (L_i_t < B)\n    payoffs[sim] = payoff\n\n# Prix de l'option call\ncall_price = B0_6 * np.mean(payoffs)\nprint(f\"Prix du call : {call_price:.6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrix du call : 0.007094\n```\n:::\n:::\n\n\nNous rendons la barrière 'bermudéenne' en étendant la condition de désactivation aux dates 1Y, 2Y, 3Y, 4Y et 5Y. De ce fait, le payoff de cette option s'écrit :\n\n$$\n\\text{Payoff} = \\delta_i \\max\\Bigl( L_i(T_i) - K,\\; 0 \\Bigr) \\mathbb{1}_{max_{i=1,\\dots,5}(L_i(T_i) < B)}\n$$\n\n::: {#00ad37a1 .cell execution_count=32}\n``` {.python .cell-code}\n# Option bermudienne\n\n# Simulation Monte Carlo\nn_simulations = 10000\n\npayoffs = np.zeros(n_simulations)\nX0 = 0\nTi = 6\nTi_1 = 5\nX = np.zeros(Ti)\nX[0] = X0\n\nfor sim in range(n_simulations):\n    phi_ = phi(Ti_1, sigma, lambda_)\n    gamma_ = gamma(Ti_1,Ti, sigma, lambda_)\n    L_i_t = np.zeros(Ti_1)\n    for i in range(1,Ti):\n        t = i\n        s = i-1\n        T = 5 \n        Xs = X[s]\n\n        # Calcul de la moyenne conditionnelle\n        mu_X, _ = quad(integrand_mean, s, t, args=(t, Xs, s, sigma, lambda_, T))\n        sigma_X = np.sqrt(compute_variance(sigma, lambda_, t, s))\n        X[i] = np.random.normal(mu_X, sigma_X)\n\n        # Calcul du prix B(5,6) selon Hull-White\n        Bi_t = df_ZC.loc[df_ZC['T'] == t, 'B'].values[0] # B(0,6)\n        Bi_s = df_ZC.loc[df_ZC['T'] == s, 'B'].values[0] # B(0,5)\n\n        B_s_t = B_t_T(s, t, Bi_t, Bi_s, X[i], sigma, lambda_)\n        B_s_s = B_t_T(s, s, Bi_s, Bi_s, X[i], sigma, lambda_)\n\n        # Calcul du taux forward L_i_t\n        L_i_t[i-1] = (1 / (t-s)) * ((B_s_s / B_s_t) - 1)\n    \n    # Calcul du prix B(5,6) selon Hull-White\n    B0_6 = df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0] # B(0,6)\n    B0_5 = df_ZC.loc[df_ZC['T'] == Ti_1, 'B'].values[0] # B(0,5)\n\n    B_5_6 = B_t_T(5, 6, B0_6, B0_5, X[Ti_1], sigma, lambda_)\n    B_5_5 = B_t_T(5, 5, B0_5, B0_5, X[Ti_1], sigma, lambda_)\n\n    # Calcul du taux forward L_i_t\n    L_t = ((B_5_5 / B_5_6) - 1)\n    bp = 100/10000\n\n\n    # Définition du strike\n    strike = ATM - bp\n\n    # Barrière\n    B = ATM + bp\n\n    # Payoff de l'option\n    payoff = np.maximum(L_t - strike, 0) * (np.max(L_i_t) < B)\n    payoffs[sim] = payoff\n\n# Prix de l'option call\ncall_price = B0_6 * np.mean(payoffs)\nprint(f\"Prix du call : {call_price:.6f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrix du call : 0.003071\n```\n:::\n:::\n\n\nL'un des paramètres important du modèle de Hull et White est la mean reversion $\\lambda$, qui caractérise la force de rappel à la moyenne du processus. Ce paramètre a un impact positive sur la valorisation de l'option, comme nous pouvons l'observer dans la figure ci dessous .\n\n::: {#0b757055 .cell execution_count=33}\n``` {.python .cell-code}\n# Liste des lambda à tester\nlambdas = np.linspace(0.01, 1, 15)  # Exemple de grille de lambda\nresults = []\n\nTi_1 = 5\nTi = 6\n# Boucle principale sur les lambdas\nfor lambda_ in lambdas:\n    n_touched = 0\n    payoffs = np.zeros(n_simulations)\n\n    for sim in range(n_simulations):\n        phi_ = phi(Ti_1, sigma, lambda_)\n        gamma_ = gamma(Ti_1,Ti, sigma, lambda_)\n\n        # Moyenne\n        mu_X = mean_5_given_0\n\n        # Ecart-type\n        sigma_X = np.sqrt(var_5_given_0)\n\n        # X_5|X_0\n        X = np.random.normal(mu_X, sigma_X)  \n\n        # Calcul du prix B(5,6) selon Hull-White\n        B0_6 = df_ZC.loc[df_ZC['T'] == Ti, 'B'].values[0] # B(0,6)\n        B0_5 = df_ZC.loc[df_ZC['T'] == Ti_1, 'B'].values[0] # B(0,5)\n\n        B_5_6 = B_t_T(5, 6, B0_6, B0_5, X, sigma, lambda_)\n        B_5_5 = B_t_T(5, 5, B0_5, B0_5, X, sigma, lambda_)\n\n        L_i_t = ((B_5_5 / B_5_6) - 1)\n        bp = 100 / 10000\n        strike = ATM - bp\n        B = ATM + bp\n\n        payoff = np.maximum(L_i_t - strike, 0) * (L_i_t < B)\n        payoffs[sim] = payoff\n\n        # Vérification de la barrière\n        if np.any(L_i_t>= B):\n            n_touched += 1\n\n    prob_toucher_barriere = n_touched / n_simulations\n\n    call_price = B0_6 * np.mean(payoffs)\n    results.append((lambda_, call_price,prob_toucher_barriere))\n```\n:::\n\n\n::: {#a7afeb0a .cell execution_count=34}\n``` {.python .cell-code}\n# Optionnel : Graphique de la sensibilité\nimport matplotlib.pyplot as plt\n\nlambdas, prices, probabilities = zip(*results)\nplt.plot(lambdas, prices, marker='o')\nplt.xlabel('Lambda (Mean Reversion)')\nplt.ylabel('Prix de l\\'option')\nplt.title('Sensibilité du prix à la mean reversion (λ)')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-34-output-1.png){width=614 height=450}\n:::\n:::\n\n\nDe plus, plus le paramètre de mean reversion $\\lambda$ est élevé, plus la probabilité de toucher la barrière est faible. Inversement, une faible mean reversion laisse plus de liberté au processus pour explorer des valeurs extrêmes, augmentant ainsi la probabilité de franchir la barrière.\n\n::: {#9de42ce7 .cell execution_count=35}\n``` {.python .cell-code}\nplt.plot(lambdas, probabilities, marker='o')\nplt.xlabel('Lambda (Mean Reversion)')\nplt.ylabel('Probabilité de toucher la barrière')\nplt.title('Probabilité de toucher la barrière en fonction de la mean reversion (λ)')\nplt.grid(True)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](pj_courbe_tx_files/figure-html/cell-35-output-1.png){width=626 height=449}\n:::\n:::\n\n\n",
    "supporting": [
      "pj_courbe_tx_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}