<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Cheryl Kouadio">
<meta name="author" content="Mariyam Ouyassin">
<meta name="dcterms.date" content="2025-03-04">

<title>Modèles de courbe de taux</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../img/logo-bg.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ea72dc5fed832574809a9c94082fbbb.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-79108a0fc1995748cbd19a5b0e3e3e7c.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-fdf986989e2058d46a90f864900247d8.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../img/logo-bg.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Accueil</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index_stat.html"> 
<span class="menu-text">Modélisation stat.</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index_gdr.html"> 
<span class="menu-text">Gestion des risques</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">À propos</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sommaire</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#i.-reconstitution-de-la-courbe-de-taux" id="toc-i.-reconstitution-de-la-courbe-de-taux" class="nav-link" data-scroll-target="#i.-reconstitution-de-la-courbe-de-taux">I. Reconstitution de la courbe de taux</a>
  <ul class="collapse">
  <li><a href="#i.1.-formules-de-valorisation-des-taux-de-marché" id="toc-i.1.-formules-de-valorisation-des-taux-de-marché" class="nav-link" data-scroll-target="#i.1.-formules-de-valorisation-des-taux-de-marché">I.1. Formules de valorisation des taux de marché</a></li>
  <li><a href="#i.2.-construction-de-la-courbe-des-taux-zéro-coupon" id="toc-i.2.-construction-de-la-courbe-des-taux-zéro-coupon" class="nav-link" data-scroll-target="#i.2.-construction-de-la-courbe-des-taux-zéro-coupon">I.2. Construction de la courbe des taux zéro-coupon</a></li>
  <li><a href="#i.3.-construction-de-la-courbe-des-taux-forward" id="toc-i.3.-construction-de-la-courbe-des-taux-forward" class="nav-link" data-scroll-target="#i.3.-construction-de-la-courbe-des-taux-forward">I.3. Construction de la courbe des taux forward</a></li>
  </ul></li>
  <li><a href="#ii.-valorisation-de-swaptions-et-de-caplets" id="toc-ii.-valorisation-de-swaptions-et-de-caplets" class="nav-link" data-scroll-target="#ii.-valorisation-de-swaptions-et-de-caplets">II. Valorisation de swaptions et de caplets</a></li>
  <li><a href="#iii.-modèle-de-hull-white" id="toc-iii.-modèle-de-hull-white" class="nav-link" data-scroll-target="#iii.-modèle-de-hull-white">III. Modèle de Hull-White</a>
  <ul class="collapse">
  <li><a href="#iii.6.-calibration-du-modèle" id="toc-iii.6.-calibration-du-modèle" class="nav-link" data-scroll-target="#iii.6.-calibration-du-modèle">III.6. Calibration du modèle</a></li>
  <li><a href="#valorisation-dun-produit-structuré" id="toc-valorisation-dun-produit-structuré" class="nav-link" data-scroll-target="#valorisation-dun-produit-structuré">3.7 Valorisation d’un produit structuré</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="pj_courbe_tx.ipynb" download="pj_courbe_tx.ipynb"><i class="bi bi-journal-code"></i>Jupyter</a></li></ul></div></nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content column-page-right" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Modèles de courbe de taux</h1>
</div>



<div class="quarto-title-meta column-page-right">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>Cheryl Kouadio </p>
             <p>Mariyam Ouyassin </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 4, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Que ce soit pour les banques, les assureurs ou les fonds de pension, la courbe de taux zéro-coupon constitue la brique de base pour la valorisation de nombreux instruments financiers, de la détermination du prix des obligations aux produits dérivés plus complexes tels que les swaps de taux, les caplets, les swaptions ou encore les produits structurés de taux. De ce fait, la construction fiable, cohérente et régulièrement mise à jour d’une courbe de taux zéro-coupon représente un enjeu majeur.</p>
<p>Dans ce contexte, ce projet propose une méthodologie complète de reconstitution de la courbe de taux zéro-coupon implicite, élaborée à partir des cotations de marché disponibles sur différents segments : Money Market (marché monétaire), Futures et Swaps. L’approche adoptée repose sur une combinaison de bootstrapping, permettant d’extraire les taux zéro-coupon pour chaque maturité observable, et d’interpolations par spline cubique, afin d’assurer la lissité et la continuité de la courbe sur l’ensemble de l’échéancier, y compris sur les maturités non directement observées.</p>
<p>La courbe obtenue sert ensuite de référence pour la valorisation de produits dérivés de taux, en particulier les caplets et les swaptions, via le modèle classique de Black, largement utilisé sur les marchés. Toutefois, afin de mieux capturer la dynamique temporelle des taux d’intérêt et de prendre en compte la structure temporelle de la volatilité implicite, la seconde partie du projet repose sur la calibration d’un modèle de Hull-White, un modèle de taux affine avec retour à la moyenne. La calibration est réalisée à partir des cotations de caplets at-the-money (ATM), à l’aide d’une procédure de recherche numérique par dichotomie.</p>
<p>Le projet met également en évidence la sensibilité de la courbe de taux forward et des prix d’options aux paramètres de marché, notamment la volatilité et le paramètre de mean reversion du modèle Hull-White. Cette analyse de sensibilité illustre comment la structure de la courbe de taux et son évolution future sont influencées par les hypothèses de modélisation, ce qui est particulièrement crucial pour les desks de trading, les gestionnaires d’actifs ou les équipes de gestion actif-passif (ALM).</p>
<p>Enfin, le projet se prolonge par une extension appliquée aux produits structurés : la valorisation de caplets à barrière désactivante (knock-out caplets), qui nécessite une approche par simulation Monte-Carlo. Cette extension illustre comment la dynamique du taux court, simulée sous la mesure forward neutre, peut être exploitée pour évaluer des produits de plus en plus complexes, répondant à des besoins spécifiques d’investisseurs ou de gestionnaires de risques.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>Le rapport de ce projet est disponible <a href="../rapports/Modèles_de_courbes_de_taux.pdf">ici</a>.</p>
</div>
</div>
</section>
<section id="i.-reconstitution-de-la-courbe-de-taux" class="level2">
<h2 class="anchored" data-anchor-id="i.-reconstitution-de-la-courbe-de-taux">I. Reconstitution de la courbe de taux</h2>
<section id="i.1.-formules-de-valorisation-des-taux-de-marché" class="level3">
<h3 class="anchored" data-anchor-id="i.1.-formules-de-valorisation-des-taux-de-marché">I.1. Formules de valorisation des taux de marché</h3>
<p>La courbe interbancaire est une courbe de taux qui représente les taux d’intérêt auxquels les banques se prêtent de l’argent entre elles. Elle est utilisée pour déterminer les taux d’intérêt des prêts et des emprunts à court terme. Elle est construite sur le court terme (maturité&lt;6M) à partir des taux du marchés monétaire (Money Market) basés sur les dépots non garantis entre banques. Sur le moyen terme (6m - 3y) elle est construite à partir des contrats futures, i.e.&nbsp;des forwards sur un marché OTC (Over The Counter) et sur le long terme (&gt;3y) elle est construite à partir des contrats de swap euribor (Euro Interbank Offered Rate) 3M ou 6M.</p>
<p>Ci dessous, nous disposons de ces données de taux de marché cotés sur le marché interbancaire. Nous allons essayer de reconstituer la courbe de taux zero coupon implicite, qui ne cote pas directement sur le marché. Le fichier de données contient trois variables : - Type d’instruments (Money Market, Futures, Swap) - Maturité (en années) - Taux d’intérêt</p>
<div id="0c4645ae" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">'ignore'</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.read_excel(<span class="st">'data/Data_tx.xlsx'</span>, sheet_name<span class="op">=</span><span class="st">'tx_marche'</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>data.columns <span class="op">=</span> [<span class="st">'type'</span>, <span class="st">'T'</span>, <span class="st">'tx'</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">type</th>
<th data-quarto-table-cell-role="th">T</th>
<th data-quarto-table-cell-role="th">tx</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>MM</td>
<td>0.25</td>
<td>0.030698</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>MM</td>
<td>0.50</td>
<td>0.026191</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>MM</td>
<td>0.75</td>
<td>0.023958</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>MM</td>
<td>1.00</td>
<td>0.022979</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>FUT</td>
<td>1.25</td>
<td>0.978691</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>FUT</td>
<td>1.50</td>
<td>0.977094</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>FUT</td>
<td>1.75</td>
<td>0.974981</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>FUT</td>
<td>2.00</td>
<td>0.972911</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>FUT</td>
<td>2.25</td>
<td>0.970984</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>FUT</td>
<td>2.50</td>
<td>0.969711</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">10</td>
<td>FUT</td>
<td>2.75</td>
<td>0.968436</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">11</td>
<td>SWAP</td>
<td>3.00</td>
<td>0.026112</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">12</td>
<td>SWAP</td>
<td>4.00</td>
<td>0.028117</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">13</td>
<td>SWAP</td>
<td>5.00</td>
<td>0.029680</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">14</td>
<td>SWAP</td>
<td>6.00</td>
<td>0.031107</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">15</td>
<td>SWAP</td>
<td>7.00</td>
<td>0.032313</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">16</td>
<td>SWAP</td>
<td>8.00</td>
<td>0.033382</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">17</td>
<td>SWAP</td>
<td>9.00</td>
<td>0.034385</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">18</td>
<td>SWAP</td>
<td>10.00</td>
<td>0.035312</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">19</td>
<td>SWAP</td>
<td>11.00</td>
<td>0.036197</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">20</td>
<td>SWAP</td>
<td>12.00</td>
<td>0.037003</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">21</td>
<td>SWAP</td>
<td>13.00</td>
<td>0.037668</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">22</td>
<td>SWAP</td>
<td>14.00</td>
<td>0.038201</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">23</td>
<td>SWAP</td>
<td>15.00</td>
<td>0.038624</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">24</td>
<td>SWAP</td>
<td>20.00</td>
<td>0.039380</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">25</td>
<td>SWAP</td>
<td>25.00</td>
<td>0.038501</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">26</td>
<td>SWAP</td>
<td>30.00</td>
<td>0.037668</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>En l’absence d’oppotunité d’arbitrage, les valorisations des instruments de marché s’expriment en fonction des taux zéro coupon implicites suivantes :</p>
<ul>
<li><p>Sur le segment <strong>Money Market</strong>, on cote en taux monétaires :</p>
<p><span class="math display">\[
  L_t(T,T+\delta) = \frac{1}{\delta} \left( \frac{B(t,T)}{B(t,T+\delta)} - 1 \right),
  \]</span></p>
<p>avec t le temps courant, T la maturité et <span class="math inline">\(\delta\)</span> la période de capitalisation. Dans notre cas, t=T=0 et <span class="math inline">\(\delta\)</span> varie en fonction de la maturité.</p></li>
<li><p>Sur le segment <strong>Future</strong>, on côte en 1 - tx forward :</p>
<p><span class="math display">\[
  future(T, T+\delta) = 1 - L_t(T,T+\delta).
  \]</span> Dans notre cas, t=0, T= maturité - 3m et <span class="math inline">\(\delta = 3m\)</span>.</p></li>
<li><p>Sur le segment <strong>Swap</strong>, on côte en taux swap :</p>
<p><span class="math display">\[
  Swap(t, T_0, T_n) = B(t, T_0)−B(t, T_n)−K ×lvl(t),
  \]</span></p>
<p>avec K le taux fixe du swap qui égalise la PV du swap vaut 0 et <span class="math inline">\(lvl(t)=\sum_{i=1}^{n} \delta_i B(t, T_i)\)</span> le taux de marché à la maturité <span class="math inline">\(T_n\)</span>. Dans notre cas, la date de départ est le spot, i.e.&nbsp;<span class="math inline">\(T_0=0\)</span> et <span class="math inline">\(T_n\)</span> est la maturité du swap, et t=0 (vu d’aujourd’hui).</p></li>
</ul>
<p>De ce fait, le données ne sont pas homogènes en taux du fait de la différente cotations des instruments. Nous allons donc les transformer en taux monétaires pour les homogénéiser.</p>
<p><strong>Remarques préliminaires</strong> : - En zone EURO, les swaps standards côtés sur le marché ont une fréquence de paiement semestrielle pour la patte variable et annuelle pour la patte fixe. Ainsi pour le calcul du level du swap, <span class="math inline">\(\delta=1\)</span> et on ajoute progressivement les taux de marché. - Pour simplifier les calculs, nous supposerons que les dates de départ des taux monétaires et des taux de swap sont spot (i.e.&nbsp;T0 = 0 et non 1 ou 2 jours).</p>
<p><strong>Methode de bootstrapping &amp; stripping</strong> :</p>
<p>Pour extraire les taux zéro coupon implicites, nous allons utiliser la méthode de bootstrapping. Cette méthode consiste à calculer les taux zéro coupon implicites à partir des taux de marché. Pour cela, nous allons utiliser les formules des taux monétaires présentées ci-dessus, qui sont vu comme des fonctions de taux zéro coupon implicites.</p>
<p>Comme les taux de swap ne sont pas nécessairement disponibles pour toutes les maturités annuelles, il faut interpoler les taux intermédiaires. Cela permettra de simplifier la méthode de bootstrapping. Nous allons utiliser une interpolation par spline cubic afin d’avoir des taux swap par an. Une interpolation par spline permet d’avoir des bonnes propriétés en terme de dérivabilité et de continuité de la courbe de taux.</p>
<p>Il s’agira donc de construire une nouvelle courbe de taux de marché discrète avec des cotations annuelles de taux swap à l’aide d’une méthode d’interpolation par spline, en plus des autres instruments. Par la suite, on supposera que cette nouvelle courbe est la courbe de marché de référence, i.e.&nbsp;la courbe utilisée pour impliciter les taux zéro coupon.</p>
<p>Enfin, nous allons faire du stripping afin de reconstituer une courbe de taux zero coupon implicite plus lisse à l’aide de différentes méthodes d’interpolations (linéaire, spline, etc).</p>
</section>
<section id="i.2.-construction-de-la-courbe-des-taux-zéro-coupon" class="level3">
<h3 class="anchored" data-anchor-id="i.2.-construction-de-la-courbe-des-taux-zéro-coupon">I.2. Construction de la courbe des taux zéro-coupon</h3>
<div id="a36e0da8" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.interpolate <span class="im">import</span> interp1d</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interpolate_and_update_df(data, col_x, col_y, kind<span class="op">=</span><span class="st">'cubic'</span>, start<span class="op">=</span><span class="dv">3</span>, end<span class="op">=</span><span class="dv">30</span>, step<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Interpole les taux SWAP et met à jour le DataFrame avec les nouvelles valeurs interpolées.</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Paramètres :</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - data : DataFrame d'origine contenant une colonne 'type' avec 'SWAP', 'T' et 'tx'.</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - kind : Type d'interpolation (par défaut 'cubic', peut être 'linear', 'quadratic', etc.).</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - start : Valeur minimale de T pour l'interpolation (par défaut 3).</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - end : Valeur maximale de T pour l'interpolation (par défaut 31).</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">    - step : Pas d'incrémentation pour la grille interpolée (par défaut 1).</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Retourne :</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co">    - new_df : DataFrame mis à jour avec les taux SWAP interpolés.</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    data <span class="op">=</span> data.copy()</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> data[col_x].values, data[col_y].values</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> interp1d(x, y, kind<span class="op">=</span>kind)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    xnew <span class="op">=</span> np.arange(start, end<span class="op">+</span>step, step)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    tx_new <span class="op">=</span> f(xnew)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame({col_x: xnew, col_y: tx_new})</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>df_interp <span class="op">=</span> interpolate_and_update_df(data, <span class="st">'T'</span>, <span class="st">'tx'</span>) </span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>df_interp[<span class="st">'type'</span>] <span class="op">=</span> <span class="st">'SWAP'</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>df_interp.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">T</th>
<th data-quarto-table-cell-role="th">tx</th>
<th data-quarto-table-cell-role="th">type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>3</td>
<td>0.026112</td>
<td>SWAP</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>4</td>
<td>0.028117</td>
<td>SWAP</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>5</td>
<td>0.029680</td>
<td>SWAP</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>6</td>
<td>0.031107</td>
<td>SWAP</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>7</td>
<td>0.032313</td>
<td>SWAP</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="78344364" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Le rajoiuter dans le df</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>new_df <span class="op">=</span> pd.concat([data[data[<span class="st">"type"</span>] <span class="op">!=</span> <span class="st">"SWAP"</span>], df_interp], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>new_df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">type</th>
<th data-quarto-table-cell-role="th">T</th>
<th data-quarto-table-cell-role="th">tx</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>MM</td>
<td>0.25</td>
<td>0.030698</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>MM</td>
<td>0.50</td>
<td>0.026191</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>MM</td>
<td>0.75</td>
<td>0.023958</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>MM</td>
<td>1.00</td>
<td>0.022979</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>FUT</td>
<td>1.25</td>
<td>0.978691</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="708397fe" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Affichage d'une courbe homogène de taux de marché en fonction de la maturité</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>new_df[<span class="st">'tx_h'</span>] <span class="op">=</span> new_df.<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="dv">1</span> <span class="op">-</span> x[<span class="st">'tx'</span>] <span class="cf">if</span> x[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'FUT'</span> <span class="cf">else</span> x[<span class="st">'tx'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>plt.plot(new_df[<span class="st">"T"</span>], new_df[<span class="st">"tx_h"</span>], marker<span class="op">=</span><span class="st">'o'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, color<span class="op">=</span><span class="st">'b'</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Maturité'</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Taux de marché'</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Courbe des taux de marché'</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-5-output-1.png" width="689" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="extraction-du-taux-zero-coupon-sur-le-segment-money-market" class="level4">
<h4 class="anchored" data-anchor-id="extraction-du-taux-zero-coupon-sur-le-segment-money-market">Extraction du taux zero coupon sur le segment Money Market</h4>
<p>Les taux zéro-coupon continus sont définis par la formule suivante :</p>
<p><span class="math display">\[
r(t,T) = -\frac{1}{T-t} \ln B(t,T),
\]</span></p>
<p>où B(t,T) est le facteur d’actualisation (<span class="math inline">\(B(t,T) = exp(-r(t,T) \times  T)\)</span> ), i.e.&nbsp;le prix d’une obligation zéro-coupon de maturité T à la date t.</p>
<p>Ils sont la brique de base pour la valorisation des produits dérivés et des obligations. De ce fait, nous allons essayer de reconstituer la courbe des taux zéro-coupon implicite à partir de la courbe des taux de marché à l’aide de la méthode du bootstrapping. Cette méthode consiste à calculer les taux zéro-coupon implicites à partir des taux de marché en utilisant la formule suivante selon le segment Money Market :</p>
<p><span class="math display">\[
L_0(0,\delta) = \frac{1}{\delta} \left( \frac{1}{B(0,\delta)} - 1 \right)
\]</span></p>
<p>De ce fait, le facteur d’actualisation est : <span class="math display">\[
B(0,\delta) = \frac{1}{1 + \delta L_0(0,\delta)}
\]</span></p>
<div id="ac700ad2" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extraction des facteurs d'actualisation pour les Money Market</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>mm <span class="op">=</span> new_df[new_df[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'MM'</span>]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>mm.loc[:, <span class="st">'B'</span>] <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> mm[<span class="st">'tx'</span>] <span class="op">*</span> mm[<span class="st">'T'</span>])</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>mm.loc[:, <span class="st">'R'</span>] <span class="op">=</span> <span class="op">-</span> np.log(mm[<span class="st">'B'</span>]) <span class="op">/</span> mm[<span class="st">'T'</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>df_ZC <span class="op">=</span> mm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="extraction-du-taux-zero-coupon-sur-le-segment-future" class="level4">
<h4 class="anchored" data-anchor-id="extraction-du-taux-zero-coupon-sur-le-segment-future">Extraction du taux zero coupon sur le segment Future</h4>
<p>Sur le segment Future, on a :</p>
<p><span class="math display">\[
Future = 1 - L_0(T,T+\delta) = 1 - \frac{1}{\delta} \left( \frac{B(0,T)}{B(0,T+\delta)} - 1 \right)
\]</span></p>
<p>De ce fait, le facteur d’actualisation est : <span class="math display">\[
B(0,T+\delta) = \frac{B(0,T)}{1 + \delta (1- Future)}
\]</span></p>
<div id="b0c2e75e" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extraction des facteurs d'actualisation pour les Futures</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>fut <span class="op">=</span> new_df[new_df[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'FUT'</span>]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># concat à mm</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>df_ZC <span class="op">=</span> pd.concat([df_ZC, fut], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>mm_len <span class="op">=</span> <span class="bu">len</span>(mm)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(mm_len, <span class="bu">len</span>(df_ZC)):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    df_ZC.loc[i, <span class="st">'B'</span>] <span class="op">=</span> df_ZC.loc[i<span class="op">-</span><span class="dv">1</span>, <span class="st">'B'</span>] <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> df_ZC.loc[i, <span class="st">'tx'</span>])<span class="op">*</span> <span class="fl">0.25</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    df_ZC.loc[i, <span class="st">'R'</span>] <span class="op">=</span> <span class="op">-</span> np.log(df_ZC.loc[i, <span class="st">'B'</span>]) <span class="op">/</span> df_ZC.loc[i, <span class="st">'T'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="extraction-du-taux-zero-coupon-sur-le-segment-swap" class="level4">
<h4 class="anchored" data-anchor-id="extraction-du-taux-zero-coupon-sur-le-segment-swap">Extraction du taux zero coupon sur le segment swap</h4>
<p>Pour le segment swap payeur, on a :</p>
<p><span class="math display">\[
Swap(t, T_0, T_n) = B(t, T_0)−B(t, T_n)−K ×lvl(t) = 0,
\]</span></p>
<p>avec K le taux fixe du swap qui fait que la PV du swap vaut 0 et <span class="math inline">\(lvl(t)=\sum_{i=1}^{n} \delta_i B(t, T_i)\)</span> le taux de marché à la maturité <span class="math inline">\(T_n\)</span>. De ce fait, le facteur d’actualisation est : <span class="math display">\[
B(0,T_n) = \frac{1 - K \sum_{i=1}^{n-1} \delta_i B(0,T_i)}{1 + K}
\]</span></p>
<div id="1e3fdcf6" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extraction des facteurs d'actualisation pour les Swaps</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>swap <span class="op">=</span> new_df[new_df[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'SWAP'</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>fut_len <span class="op">=</span> <span class="bu">len</span>(fut)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>df_ZC <span class="op">=</span> pd.concat([df_ZC, swap], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(mm_len<span class="op">+</span>fut_len, <span class="bu">len</span>(df_ZC)):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    T_n <span class="op">=</span> df_ZC.loc[i, <span class="st">'T'</span>]  <span class="co"># Récupère la valeur de T actuelle</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> (df_ZC[<span class="st">'T'</span>] <span class="op">&lt;</span> T_n) <span class="op">&amp;</span> (df_ZC[<span class="st">'T'</span>] <span class="op">%</span> <span class="dv">1</span> <span class="op">==</span> <span class="dv">0</span>)  <span class="co"># Sélectionne uniquement les T entiers &lt; T_n</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    df_ZC.loc[i, <span class="st">'B'</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> df_ZC.loc[i, <span class="st">'tx'</span>] <span class="op">*</span> <span class="bu">sum</span>(df_ZC.loc[mask, <span class="st">'B'</span>].fillna(<span class="dv">0</span>)))<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span>df_ZC.loc[i, <span class="st">'tx'</span>])</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    df_ZC.loc[i, <span class="st">'R'</span>] <span class="op">=</span> <span class="op">-</span> np.log(df_ZC.loc[i, <span class="st">'B'</span>]) <span class="op">/</span> T_n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="c719afa8" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plt.plot(df_ZC[<span class="st">'T'</span>], df_ZC[<span class="st">'R'</span>], label<span class="op">=</span><span class="st">'Courbe de taux zéro coupon'</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>plt.plot(new_df[<span class="st">"T"</span>], new_df[<span class="st">"tx_h"</span>], label<span class="op">=</span><span class="st">'Taux de marché'</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'T'</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'R'</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Courbe de taux zéro coupon discrétisée'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>Text(0.5, 1.0, 'Courbe de taux zéro coupon discrétisée')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-9-output-2.png" width="689" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Comme on peut le constater, le mode d’interpolation a un impact significatif sur le calcul des taux de marché car il affecte la forme de la courbe des taux et donc la valorisation des instruments financiers.</p>
</section>
</section>
<section id="i.3.-construction-de-la-courbe-des-taux-forward" class="level3">
<h3 class="anchored" data-anchor-id="i.3.-construction-de-la-courbe-des-taux-forward">I.3. Construction de la courbe des taux forward</h3>
<p>A partir de la courbe des taux zéro-coupon issue de la méthode de bootstrapping, nous souhaitons tracer la courbe des taux forwards de tenor 3M en fonction de la maturité à l’aide des méthodes d’interpolation linéaire et par spline, avec une discrétisation de 0.1 an.</p>
<p>Pour tracer la courbe taux forward, on utilisera la formule suivante pour calculer les taux forward :</p>
<p><span class="math display">\[
L_0(T,T+\delta) = \frac{1}{\delta} (\frac{B(0,T)}{B(0,T+\delta)} - 1)
\]</span> avec <span class="math inline">\(\delta = 0.25\)</span>.</p>
<p>Pour le segment swap, il s’agira d’interpoler les taux zéro-coupon implicites pour avoir des tx forwards 3M. # changer la discretisatio à 1an ce qui est différent du ténor.</p>
<div id="d886d6d8" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>df_ZC <span class="op">=</span> pd.concat([pd.DataFrame({<span class="st">"T"</span>: [<span class="dv">0</span>], <span class="st">"B"</span>: [<span class="dv">1</span>], <span class="st">"R"</span>: [<span class="dv">0</span>]}), df_ZC], ignore_index<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="7ec78c17" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>new_df_ZC<span class="op">=</span> interpolate_and_update_df(df_ZC, <span class="st">'T'</span>, <span class="st">'R'</span>, kind<span class="op">=</span><span class="st">'linear'</span>, start<span class="op">=</span><span class="dv">0</span>, end<span class="op">=</span><span class="dv">30</span>, step<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>tau <span class="op">=</span> <span class="fl">0.25</span>  <span class="co"># 3 mois = 0.25 an</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_forward_rates(R, T_range, tau):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" Calcule les taux forward pour chaque maturité """</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    fwd_rates <span class="op">=</span> []</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    T_values <span class="op">=</span> []</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(T_range)<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        T <span class="op">=</span> T_range[i]</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        T_tau <span class="op">=</span> T <span class="op">+</span> tau</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> T_tau <span class="op">&gt;=</span> <span class="bu">max</span>(T_range):</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span>  <span class="co"># Éviter d'extrapoler au-delà des données disponibles</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        B_T <span class="op">=</span> np.exp(<span class="op">-</span>R[i] <span class="op">*</span> T)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        R_T_tau <span class="op">=</span> np.interp(T_tau, T_range, R) </span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        B_T_tau <span class="op">=</span> np.exp(<span class="op">-</span>R_T_tau <span class="op">*</span> T_tau)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Formule du taux forward instantané</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        fwd_rate <span class="op">=</span> (B_T <span class="op">/</span> B_T_tau <span class="op">-</span> <span class="dv">1</span>) <span class="op">/</span> tau</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        fwd_rates.append(fwd_rate)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        T_values.append(T)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame({<span class="st">"T"</span>: T_values, <span class="st">"tx_fwd"</span>: fwd_rates})</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>fwd_rates <span class="op">=</span> compute_forward_rates(new_df_ZC[<span class="st">'R'</span>], new_df_ZC[<span class="st">'T'</span>], tau)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>plt.plot(fwd_rates[<span class="st">"T"</span>],fwd_rates[<span class="st">"tx_fwd"</span>], label<span class="op">=</span><span class="st">'Taux forward'</span>)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'T'</span>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Taux forward'</span>)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Courbe des taux forward avec interpolation linéaire'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>Text(0.5, 1.0, 'Courbe des taux forward avec interpolation linéaire')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-11-output-2.png" width="680" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="31e0037d" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>new_df_ZC<span class="op">=</span> interpolate_and_update_df(df_ZC, <span class="st">'T'</span>, <span class="st">'R'</span>, kind<span class="op">=</span><span class="st">'cubic'</span>, start<span class="op">=</span><span class="dv">0</span>, end<span class="op">=</span><span class="dv">30</span>, step<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>tau <span class="op">=</span> <span class="fl">0.25</span>  <span class="co"># 3 mois = 0.25 an</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>fwd_rates <span class="op">=</span> compute_forward_rates(new_df_ZC[<span class="st">'R'</span>], new_df_ZC[<span class="st">'T'</span>], tau)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>plt.plot(fwd_rates[<span class="st">"T"</span>],fwd_rates[<span class="st">"tx_fwd"</span>], label<span class="op">=</span><span class="st">'Taux forward'</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'T'</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Taux forward'</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Courbe des taux forward avec interpolation par spline'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>Text(0.5, 1.0, 'Courbe des taux forward avec interpolation par spline')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-12-output-2.png" width="680" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Lorsqu’on utilise une interpolation linéaire, on obtient une courbe plus discontinue. La courbe a une structure en marches d’escalier. Il y a des sauts brusques lorsque l’on passe d’un intervalle à un autre. En effet, par nature, l’interpolation linéaire qui ne prend pas en compte les points intermédiaires. En interpolant avec une fonction spline, on obtient une courbe plus lisse et continue.Elle est plus cohérente avec l’évolution naturelle des taux d’intérêt. En effet, la fonction spline est une fonction polynomiale qui passe par tous les points de la courbe. Elle est plus flexible et permet de mieux capturer les variations des taux d’intérêt.</p>
<p>Nous sommes intéressés à ce qui pourrait se passer lorsque nous shiftons le taux de swap 5Y de 10 points de base. Cela permet de déterminer la sensibilité de la courbe des taux forward aux variations des taux de swap et donc donner des indications sur comment hedger ce risque.</p>
<p>Nous allons donc calculer le taux forward 3M pour les deux courbes de taux forward et comparer les résultats.</p>
<div id="0f561488" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>choc <span class="op">=</span> <span class="dv">10</span><span class="op">/</span><span class="dv">10000</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>new_df[<span class="st">"tx_s"</span>] <span class="op">=</span> new_df.<span class="bu">apply</span>(<span class="kw">lambda</span> x: x[<span class="st">'tx_h'</span>]<span class="op">+</span>choc <span class="cf">if</span> x[<span class="st">'T'</span>] <span class="op">==</span> <span class="dv">5</span> <span class="cf">else</span> x[<span class="st">'tx_h'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plot</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>plt.plot(new_df[<span class="st">"T"</span>], new_df[<span class="st">"tx_s"</span>], label<span class="op">=</span><span class="st">'Taux de marché shiftés'</span>, color<span class="op">=</span><span class="st">"r"</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>plt.plot(new_df[<span class="st">"T"</span>], new_df[<span class="st">"tx_h"</span>], label<span class="op">=</span><span class="st">'Taux de marché'</span>, color<span class="op">=</span><span class="st">"b"</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Maturité'</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Taux de marché'</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Courbe des taux de marché'</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>new_df[<span class="st">"tx_s"</span>] <span class="op">=</span> new_df.<span class="bu">apply</span>(<span class="kw">lambda</span> x: x[<span class="st">'tx'</span>]<span class="op">+</span>choc <span class="cf">if</span> x[<span class="st">'T'</span>] <span class="op">==</span> <span class="dv">5</span> <span class="cf">else</span> x[<span class="st">'tx'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-13-output-1.png" width="689" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="6f837689" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extraction des facteurs d'actualisation pour les Money Market</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_discount_factors(new_df, col_T<span class="op">=</span><span class="st">"T"</span>, col_tx<span class="op">=</span><span class="st">"tx"</span>):</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcule les facteurs d'actualisation (B) et les taux zéro-coupon (R) </span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co">    à partir des taux du marché pour les instruments MM, FUT et SWAP.</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Paramètres :</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - new_df : DataFrame contenant les taux du marché avec les colonnes spécifiées.</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - col_T : Nom de la colonne contenant les maturités (ex: "T").</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - col_tx : Nom de la colonne contenant les taux du marché (ex: "tx").</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Retourne :</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="co">    - df_ZC : DataFrame contenant les facteurs d'actualisation et les taux zéro-coupon.</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Extraction des données du marché monétaire (MM) ---</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    mm <span class="op">=</span> new_df[new_df[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'MM'</span>].copy()</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    mm.loc[:, <span class="st">'B'</span>] <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> mm[col_tx] <span class="op">*</span> mm[col_T])</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    mm.loc[:, <span class="st">'R'</span>] <span class="op">=</span> <span class="op">-</span> np.log(mm[<span class="st">'B'</span>]) <span class="op">/</span> mm[col_T]</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    df_ZC <span class="op">=</span> mm.copy()</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Extraction des données Futures (FUT) ---</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    fut <span class="op">=</span> new_df[new_df[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'FUT'</span>].copy()</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    df_ZC <span class="op">=</span> pd.concat([df_ZC, fut], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    mm_len <span class="op">=</span> <span class="bu">len</span>(mm)</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Calcul des facteurs d'actualisation pour les Futures ---</span></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(mm_len, <span class="bu">len</span>(df_ZC)):</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>        df_ZC.loc[i, <span class="st">'B'</span>] <span class="op">=</span> df_ZC.loc[i<span class="op">-</span><span class="dv">1</span>, <span class="st">'B'</span>] <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> df_ZC.loc[i, col_tx]) <span class="op">*</span> <span class="fl">0.25</span>)</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>        df_ZC.loc[i, <span class="st">'R'</span>] <span class="op">=</span> <span class="op">-</span> np.log(df_ZC.loc[i, <span class="st">'B'</span>]) <span class="op">/</span> df_ZC.loc[i, col_T]</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Extraction des données Swaps (SWAP) ---</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>    swap <span class="op">=</span> new_df[new_df[<span class="st">'type'</span>] <span class="op">==</span> <span class="st">'SWAP'</span>].copy()</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    fut_len <span class="op">=</span> <span class="bu">len</span>(fut)</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>    df_ZC <span class="op">=</span> pd.concat([df_ZC, swap], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># --- Calcul des facteurs d'actualisation pour les Swaps ---</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(mm_len <span class="op">+</span> fut_len, <span class="bu">len</span>(df_ZC)):</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>        T_n <span class="op">=</span> df_ZC.loc[i, col_T]  <span class="co"># Maturité actuelle</span></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> (df_ZC[col_T] <span class="op">&lt;</span> T_n) <span class="op">&amp;</span> (df_ZC[col_T] <span class="op">%</span> <span class="dv">1</span> <span class="op">==</span> <span class="dv">0</span>)  <span class="co"># Sélection des T entiers &lt; T_n</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>        sum_B <span class="op">=</span> <span class="bu">sum</span>(df_ZC.loc[mask, <span class="st">'B'</span>].fillna(<span class="dv">0</span>))</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a>        df_ZC.loc[i, <span class="st">'B'</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> df_ZC.loc[i, col_tx] <span class="op">*</span> sum_B) <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> df_ZC.loc[i, col_tx])</span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>        df_ZC.loc[i, <span class="st">'R'</span>] <span class="op">=</span> <span class="op">-</span> np.log(df_ZC.loc[i, <span class="st">'B'</span>]) <span class="op">/</span> T_n</span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_ZC</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>df_ZC_s <span class="op">=</span> compute_discount_factors(new_df, col_T<span class="op">=</span><span class="st">"T"</span>, col_tx<span class="op">=</span><span class="st">"tx_s"</span>)</span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>df_ZC_s<span class="op">=</span>pd.concat([pd.DataFrame({<span class="st">"T"</span>: [<span class="dv">0</span>], <span class="st">"B"</span>: [<span class="dv">1</span>], <span class="st">"R"</span>: [<span class="dv">0</span>]}), df_ZC_s], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>plt.plot(df_ZC_s.loc[<span class="dv">1</span>:,<span class="st">'T'</span>], df_ZC_s.loc[<span class="dv">1</span>:,<span class="st">'R'</span>], label<span class="op">=</span><span class="st">'Courbe de taux zéro coupon shifté'</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>plt.plot(df_ZC.loc[<span class="dv">1</span>:,<span class="st">"T"</span>], df_ZC.loc[<span class="dv">1</span>:,<span class="st">"R"</span>], label<span class="op">=</span><span class="st">'Courbe de taux zéro coupon non shifté'</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'T'</span>)</span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'R'</span>)</span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Courbe de taux zéro coupon discrétisée'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>Text(0.5, 1.0, 'Courbe de taux zéro coupon discrétisée')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-14-output-2.png" width="689" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="1e8a5e30" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>new_df_ZC<span class="op">=</span> interpolate_and_update_df(df_ZC_s, <span class="st">'T'</span>, <span class="st">'R'</span>, kind<span class="op">=</span><span class="st">'linear'</span>, start<span class="op">=</span><span class="dv">0</span>, end<span class="op">=</span><span class="dv">30</span>, step<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>tau <span class="op">=</span> <span class="fl">0.25</span>  <span class="co"># 3 mois = 0.25 an</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>fwd_rates <span class="op">=</span> compute_forward_rates(new_df_ZC[<span class="st">'R'</span>], new_df_ZC[<span class="st">'T'</span>], tau)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>plt.plot(fwd_rates[<span class="st">"T"</span>],fwd_rates[<span class="st">"tx_fwd"</span>], label<span class="op">=</span><span class="st">'Taux forward'</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'T'</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Taux forward'</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Courbe des taux forward avec interpolation par spline'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>Text(0.5, 1.0, 'Courbe des taux forward avec interpolation par spline')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-15-output-2.png" width="680" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="08a3bafa" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>new_df_ZC<span class="op">=</span> interpolate_and_update_df(df_ZC_s, <span class="st">'T'</span>, <span class="st">'R'</span>, kind<span class="op">=</span><span class="st">'cubic'</span>, start<span class="op">=</span><span class="dv">0</span>, end<span class="op">=</span><span class="dv">30</span>, step<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>tau <span class="op">=</span> <span class="fl">0.25</span>  <span class="co"># 3 mois = 0.25 an</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>fwd_rates <span class="op">=</span> compute_forward_rates(new_df_ZC[<span class="st">'R'</span>], new_df_ZC[<span class="st">'T'</span>], tau)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>plt.plot(fwd_rates[<span class="st">"T"</span>],fwd_rates[<span class="st">"tx_fwd"</span>], label<span class="op">=</span><span class="st">'Taux forward'</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'T'</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Taux forward'</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Courbe des taux forward avec interpolation par spline'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>Text(0.5, 1.0, 'Courbe des taux forward avec interpolation par spline')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-16-output-2.png" width="680" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>En shiftant le taux de swap 5Y, la courbe de forward baisse brusquement pour T=5Y. Il y a une déformation locale de la courbe des taux forward. Cela signifie que la courbe des taux forward est sensible aux variations des taux de swap. En effet, les taux swap sont des instruments financiers qui permettent de se couvrir contre les variations des taux d’intérêt.</p>
</section>
</section>
<section id="ii.-valorisation-de-swaptions-et-de-caplets" class="level2">
<h2 class="anchored" data-anchor-id="ii.-valorisation-de-swaptions-et-de-caplets">II. Valorisation de swaptions et de caplets</h2>
<ol type="1">
<li><p>Pour coter les caplets/floorlets et swaptions, le modèle de Black est souvent utilisé. Ce modèle est basé sur l’hypothèse que les taux d’intérêt sont log-normalement distribués. Il permet de calculer le prix d’un caplet/floorlet et d’un swaption en fonction des taux d’intérêt et de la volatilité implicite.</p></li>
<li><p>L’EDS (Equation Différentielle Stochastique) de Black est donnée par :</p></li>
</ol>
<p><span class="math display">\[
dL(t) = \sigma L(t) dW(t)
\]</span></p>
<p>avec <span class="math inline">\(L(t)\)</span> le taux, <span class="math inline">\(\sigma\)</span> la volatilité du taux et <span class="math inline">\(W(t)\)</span> un mouvement brownien. En utilisant le changement de numéraire, ce taux est une martingale sous la mesure du numeraire (probabilité risque neutre). Cela permet de calculer le prix d’un caplet/floorlet ou d’une swaption.</p>
<p><strong>Caplets et Floorlets</strong></p>
<ol start="3" type="1">
<li>Pour un caplet, le prix est donné par la formule suivante :</li>
</ol>
<p><span class="math display">\[
Caplet(t,T_{i-1},T_i) = N \delta_i B(t,T_i) \left[ L_i(t) \phi(d) - K \phi (d - \sigma_i \sqrt{T_{i-1}-t} )\right]
\]</span></p>
<p>avec <span class="math inline">\(d = \frac{1}{\sigma \sqrt{T_{i-1}-t}} \left( \ln \left( \frac{L_i(t)}{K} \right) + \frac{\sigma^2(T_{i-1}-t)}{2} \right)\)</span>, <span class="math inline">\(L_i(t)\)</span> le taux forward 3M à la date t, <span class="math inline">\(K\)</span> le strike du caplet, <span class="math inline">\(N\)</span> le nominal, <span class="math inline">\(\delta_i\)</span> la période de capitalisation, <span class="math inline">\(B(t,T_i)\)</span> le facteur d’actualisation à la maturité <span class="math inline">\(T_i\)</span>, <span class="math inline">\(\sigma_i\)</span> la volatilité du taux forward 3M à la maturité <span class="math inline">\(T_i\)</span> et <span class="math inline">\(\phi\)</span> la fonction de répartition de la loi normale standard.</p>
<p>Pour un floorlet, le prix est donné par la formule suivante :</p>
<p><span class="math display">\[
Floorlet(t,T_{i-1},T_i) = N \delta_i B(t,T_i) \left[ K \phi (d - \sigma_i \sqrt(T_{i-1}-t) ) - L_i(t) \phi(d) \right]
\]</span></p>
<p><strong>Swaptions</strong></p>
<p>Pour un swaption donneur, le prix est donné par la formule suivante :</p>
<p><span class="math display">\[
\text{Swaption}_t = \left( \sum_{j=1}^{n} N \delta B(t, T_j) \right) \left[ F_S(t) \Phi(d) - K \Phi(d - \sigma_S \sqrt{T_0 - t}) \right]
\]</span></p>
<p>avec <span class="math inline">\(F_S(t)\)</span> le taux swap à la date t, <span class="math inline">\(K\)</span> le strike du swaption, <span class="math inline">\(N\)</span> le nominal, <span class="math inline">\(\delta\)</span> la période de capitalisation, <span class="math inline">\(B(t,T_j)\)</span> le facteur d’actualisation à la maturité <span class="math inline">\(T_j\)</span>, <span class="math inline">\(\sigma_S\)</span> la volatilité du taux swap et <span class="math inline">\(\Phi\)</span> la fonction de répartition de la loi normale standard.</p>
<p>d est donné par la formule suivante :</p>
<p><span class="math display">\[
d = \frac{1}{\sigma_S \sqrt{T_0 - t}} \left( \ln \left( \frac{F_S(t)}{K} \right) + \frac{\sigma_S^2(T_0 - t)}{2} \right)
\]</span></p>
<p>Pour un swaption receveur, le prix est donné par la formule suivante :</p>
<p><span class="math display">\[
\text{Swaption}_t = \left( \sum_{j=1}^{n} N \delta B(t, T_j) \right) \left[ K \Phi(d - \sigma_S \sqrt{T_0 - t}) - F_S(t) \Phi(d) \right]
\]</span></p>
<p>Il s’agit, à partir des cotations décrites dans le tableau ci-dessous et de la courbe des taux zéro-coupon construite précédemment, calculer les prix de marché de caplets sur euribor12M, ce qui implique une période de capitalisation annuelle, de maturité T = 5Y, i.e.&nbsp;payé à 6Y, et de strikes K associés au tableau. Nous souhaitons ainsi calculer : - Le prix des caplets Caplet(t, 5Y, 6Y) pour les strikes du tableau ci-dessous. - Le prix des swaptions Swaption(t, 5Y, 6Y) pour les strikes du tableau ci-dessous.</p>
<div id="adc05a4a" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>vol_data <span class="op">=</span> pd.read_excel(<span class="st">'data/Data_tx.xlsx'</span>, sheet_name<span class="op">=</span><span class="st">'vol'</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>vol_data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Strike en bps et en rel. / fwd</th>
<th data-quarto-table-cell-role="th">Vols Caplets</th>
<th data-quarto-table-cell-role="th">Vols Swaptions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>-100</td>
<td>0.311859</td>
<td>0.311859</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>-50</td>
<td>0.283274</td>
<td>0.283274</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>-25</td>
<td>0.265921</td>
<td>0.265921</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>0</td>
<td>0.250000</td>
<td>0.250000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>25</td>
<td>0.243451</td>
<td>0.243451</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>50</td>
<td>0.249019</td>
<td>0.249019</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>100</td>
<td>0.271828</td>
<td>0.271828</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="f1836d22" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> price_oplet(N, delta_i, B_t_Ti, L_i_t, K, sigma_i, Ti, t, option_type<span class="op">=</span><span class="st">'caplet'</span>):</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Calcule la valeur d'un caplet selon le modèle de Black.</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Paramètres :</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">    - N : Notional</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="co">    - delta_i : Période du caplet </span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co">    - B_t_Ti : Facteur d'actualisation B(t, Ti)</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="co">    - L_i_t : Taux forward Li(t)</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co">    - K : Strike du caplet</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="co">    - sigma_i : Volatilité implicite</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="co">    - Ti_1 : Date de début de la période</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="co">    - Ti : Date de fin de la période</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a><span class="co">    - t : Temps actuel</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Retourne :</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="co">    - Valeur du caplet</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    Ti_1 <span class="op">=</span> Ti <span class="op">-</span> delta_i</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    d1 <span class="op">=</span> (np.log(L_i_t <span class="op">/</span> K) <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> sigma_i<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (Ti_1 <span class="op">-</span> t)) <span class="op">/</span> (sigma_i <span class="op">*</span> np.sqrt(Ti_1 <span class="op">-</span> t))</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    d2 <span class="op">=</span> sigma_i <span class="op">*</span> np.sqrt(Ti_1 <span class="op">-</span> t) <span class="op">-</span> d1</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> option_type <span class="op">==</span> <span class="st">'caplet'</span>:</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>        price <span class="op">=</span> N <span class="op">*</span> delta_i <span class="op">*</span> B_t_Ti <span class="op">*</span> (L_i_t <span class="op">*</span> norm.cdf(d1) <span class="op">-</span> K <span class="op">*</span> norm.cdf(<span class="op">-</span>d2))</span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> option_type <span class="op">==</span> <span class="st">'floorlet'</span>:</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>        price <span class="op">=</span> N <span class="op">*</span> delta_i <span class="op">*</span> B_t_Ti <span class="op">*</span> (K <span class="op">*</span> norm.cdf(d2) <span class="op">-</span> L_i_t <span class="op">*</span> norm.cdf(<span class="op">-</span>d1))</span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> price</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> vol_data.index:</span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Notional</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">1</span>  </span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Période du caplet</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>    delta_i <span class="op">=</span> <span class="dv">1</span> </span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Maturité du caplet</span></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>    T<span class="op">=</span><span class="dv">5</span> </span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Facteur d'actualisation B(t, Ti)</span></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>    B_t_Ti <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> T<span class="op">+</span><span class="dv">1</span>, <span class="st">'B'</span>].values[<span class="dv">0</span>]</span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Taux forward Li(t)</span></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>    L_i_t <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>delta_i) <span class="op">*</span> ((df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> T, <span class="st">'B'</span>].values[<span class="dv">0</span>]<span class="op">/</span>df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> T<span class="op">+</span><span class="dv">1</span>, <span class="st">'B'</span>].values[<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Strike du caplet</span></span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> L_i_t <span class="op">+</span> vol_data.loc[i, <span class="st">'Strike en bps et en rel. / fwd'</span>]<span class="op">/</span><span class="dv">10000</span></span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Volatilité implicite</span></span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a>    sigma_i <span class="op">=</span> vol_data.loc[i, <span class="st">"Vols Caplets"</span>]  </span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Date de début de la période</span></span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a>    Ti <span class="op">=</span> T <span class="op">+</span> delta_i</span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Temps actuel</span></span>
<span id="cb23-57"><a href="#cb23-57" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="dv">0</span>  </span>
<span id="cb23-58"><a href="#cb23-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-59"><a href="#cb23-59" aria-hidden="true" tabindex="-1"></a>    caplet_price <span class="op">=</span> price_oplet(N, delta_i, B_t_Ti, L_i_t, K, sigma_i, Ti, t, option_type<span class="op">=</span><span class="st">'caplet'</span>)</span>
<span id="cb23-60"><a href="#cb23-60" aria-hidden="true" tabindex="-1"></a>    vol_data.loc[i, <span class="st">'Caplet Price MKT'</span>] <span class="op">=</span> caplet_price</span>
<span id="cb23-61"><a href="#cb23-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-62"><a href="#cb23-62" aria-hidden="true" tabindex="-1"></a>vol_data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Strike en bps et en rel. / fwd</th>
<th data-quarto-table-cell-role="th">Vols Caplets</th>
<th data-quarto-table-cell-role="th">Vols Swaptions</th>
<th data-quarto-table-cell-role="th">Caplet Price MKT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>-100</td>
<td>0.311859</td>
<td>0.311859</td>
<td>0.012511</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>-50</td>
<td>0.283274</td>
<td>0.283274</td>
<td>0.009788</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>-25</td>
<td>0.265921</td>
<td>0.265921</td>
<td>0.008419</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>0</td>
<td>0.250000</td>
<td>0.250000</td>
<td>0.007137</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>25</td>
<td>0.243451</td>
<td>0.243451</td>
<td>0.006185</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>50</td>
<td>0.249019</td>
<td>0.249019</td>
<td>0.005661</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>100</td>
<td>0.271828</td>
<td>0.271828</td>
<td>0.005167</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="a1cbec8f" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># pricer les swaptions</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="iii.-modèle-de-hull-white" class="level2">
<h2 class="anchored" data-anchor-id="iii.-modèle-de-hull-white">III. Modèle de Hull-White</h2>
<section id="iii.1-du-modèle-hjm-vers-le-modèle-hullwhite" class="level4">
<h4 class="anchored" data-anchor-id="iii.1-du-modèle-hjm-vers-le-modèle-hullwhite">III.1 Du modèle HJM vers le modèle Hull&amp;White</h4>
<p>Pour une maturité <span class="math inline">\(T\)</span> fixée, Heath, Jarrow et Morton ont supposé que le taux forward instantané évolue selon la dynamique suivante :</p>
<p><span class="math display">\[
df(t, T) = \alpha(t, T)\, dt + \sigma(t, T)\, dW_t \quad (1)
\]</span></p>
<p>La dynamique (1) ne se place pas forcément dans un cadre sans opportunité d’arbitrage. Les auteurs ont montré que le processus <span class="math inline">\(\alpha\)</span> ne pouvait pas être choisi arbitrairement et que, pour qu’il existe une unique mesure martingale équivalente, <span class="math inline">\(\alpha\)</span> devait être lié à la volatilité du zéro coupon.</p>
<p>Supposons donc l’existence d’une unique mesure martingale équivalente <span class="math inline">\(\mathbb{Q}\)</span> (mesure risque-neutre) dont le numéraire est l’actif sans risque.</p>
<p>On suppose que le prix du zéro coupon (payant une unité de devise en date <span class="math inline">\(T\)</span>) évolue sous <span class="math inline">\(\mathbb{Q}\)</span> selon l’EDS :</p>
<p><span class="math display">\[
\frac{dB(t, T)}{B(t, T)} = r_t\, dt + \Gamma(t, T)\, dW_t^Q \quad (2)
\]</span></p>
<p>Par définition, on sait que $ B(t, T) = e^{-_t^T f(t,s), ds}$ et que $ f(t, T) = -_T (B(t, T)). $</p>
<p>En appliquant le lemme d’Itô, on obtient : $ df(t, T) = (t, T), _T (t, T), dt - _T (t, T), dW_t^Q. $</p>
<p>En posant $ -_T (t, T) = (t, T), $ nous obtenons :</p>
<p><span class="math display">\[
df(t, T) = \gamma(t, T) \int_t^T \gamma(t, u)\, du \, dt + \gamma(t, T)\, dW_t^Q \quad (3)
\]</span></p>
<p>Après intégration, on retrouve finalement :</p>
<p><span class="math display">\[
f(t, T) = f(0, T) + \int_0^t \gamma(s, T) \left( \int_s^T \gamma(s, u)\, du \right) ds + \int_0^t \gamma(s, T)\, dW_s^Q \quad (4)
\]</span></p>
</section>
<section id="iii.2-hypothèses-du-modèle-hullwhite" class="level4">
<h4 class="anchored" data-anchor-id="iii.2-hypothèses-du-modèle-hullwhite">III.2 Hypothèses du modèle Hull&amp;White</h4>
<p>On suppose que le modèle HJM est gaussien, linéaire et calibrable. Ces hypothèses permettent d’écrire :</p>
<p><span class="math display">\[
\gamma(t, T) = \sigma(t)\, e^{-\lambda (T-t)}  \quad \text{ et} \quad \Gamma(t, T) = \frac{\sigma(t)}{\lambda}\Bigl(e^{-\lambda (T-t)} - 1\Bigr)
\]</span></p>
<p>où la fonction de volatilité instantanée <span class="math inline">\(\sigma(t)\)</span> est constante par morceaux.</p>
</section>
<section id="iii.3-construction-de-la-formule-zéro-coupon" class="level4">
<h4 class="anchored" data-anchor-id="iii.3-construction-de-la-formule-zéro-coupon">III.3 Construction de la formule zéro-coupon</h4>
<p>Dans le cadre du modèle Hull&amp;White, la dynamique du taux court instantané <span class="math inline">\(r_t\)</span> s’écrit :</p>
<p><span class="math display">\[
dr_t = \left[\lambda\bigl(f(0,t) - r_t\bigr) + \partial_t f(0,t) + \int_0^t \sigma^2(s)\, e^{-2\lambda (t-s)} ds \right] dt + \sigma(t)\, dW_t^Q \quad (5)
\]</span></p>
<p>On introduit alors une nouvelle variable d’état : $ X_t = r_t - f(0,t)$</p>
<p>La dynamique de <span class="math inline">\(X_t\)</span> devient :</p>
<p><span class="math display">\[
dX_t = \left[\varphi(t) - \lambda X_t\right] dt + \sigma(t)\, dW_t^Q \quad (8)
\]</span></p>
<p>avec $ (t) = _0^t ^2(s), e^{-2(t-s)} ds. $</p>
<p>La formule du prix du zéro coupon s’exprime alors comme une fonction déterministe de <span class="math inline">\(X_t\)</span> :</p>
<p><span class="math display">\[
B(t, T) = \frac{B(0,T)}{B(0,t)} \exp\!\Biggl\{ -\frac{1}{2\beta^2(t,T)} \varphi(t) - \beta(t,T) X_t \Biggr\} \quad (9)
\]</span></p>
<p>où $ (t, T) = . $</p>
<ol type="1">
<li>A quelle catégorie de modèle appartient le modèle Hull&amp;White? Justifier.</li>
</ol>
<p>Le modèle Hull &amp; White est un modèle à structure à terme aﬃne, i.e.&nbsp;un modèle de taux d’intérêt pour lequel le taux zéro-coupon continu R(t, T ) est une fonction aﬃne du taux court r (t).</p>
<p>Il ressemble à un processus d’Ornstein-Uhlenbeck ou mean reversing process, qui est un processus gaussien définit de la manière suivante :</p>
<p><span class="math display">\[
dY_t = - \theta \left[Y_t - \mu \right] dt + \sigma dW_t,
\]</span></p>
<p>où <span class="math inline">\(\theta, \mu, \sigma\)</span> sont des paramètres déterministes et <span class="math inline">\(W_t\)</span> est le processus de Wiener.</p>
<p>Dans notre cas, on a <span class="math inline">\(\theta = \lambda\)</span>, <span class="math inline">\(\mu = \frac{\phi(t)}{\lambda}\)</span> et <span class="math inline">\(\sigma = \sigma(t)\)</span>. De ce fait, la moyenne et la variance dépend du temps et le paramètre de vitesse de retour à la moyenne est constant.</p>
<ol start="2" type="1">
<li>Déterminer la loi du processus <span class="math inline">\(X_t|X_s\)</span>?</li>
</ol>
<p>Sous la probabilité risque neute <span class="math inline">\(\mathbb{Q}\)</span>, le processus <span class="math inline">\(X_t\)</span> s’ecrit :</p>
<p><span class="math display">\[
dX_t = \left(\phi(t)- \lambda X_t \right) dt + \sigma(t) dW_t^Q,
\]</span></p>
<p>avec <span class="math inline">\(\phi(t) = \int_0^t \sigma^2(s) e^{-2\lambda(t-s)} ds\)</span>.</p>
<p>Posons <span class="math inline">\(K_t = e^{\lambda t} X_t  = f(X_t, t)\implies X_t = e^{-\lambda t} K_t\)</span>, par la formule d’Itô, on a :</p>
<span class="math display">\[\begin{aligned}
df(X_t, t) &amp;= e^{\lambda t} dX_t + de^{\lambda t} X_t \\
&amp;= e^{\lambda t} \left( \phi(t) - \lambda X_t \right) dt + e^{\lambda t} \sigma(t) dW_t^Q + e^{\lambda t} X_t dt \\
&amp;= e^{\lambda t}\phi(t) dt + e^{\lambda t}\sigma(t)dW_t^Q \\
&amp;\implies f(X_t, t) = K_t = e^{- \lambda t}K_s  + \int_s^t e^{-\lambda(t-u)}\phi(u) du + \int_s^t e^{-\lambda(t-u)}\sigma(u)dW_u^Q \\
&amp;\Leftrightarrow X_t = X_s e^{-\lambda (t-s)} + \int_s^t e^{-\lambda (t-u)} \phi(u)  du + \int_s^t e^{-\lambda (t-u)} \sigma(u) dW_u^T
\end{aligned}\]</span>
<p>De ce fait, on en déduit que $X_t|X_s ( X_s e^{-(t-s)} + _s^t e^{-(t-u)} (u) du, _s^t e^{-2 (t-u)} (u)^2 d ) $.</p>
</section>
<section id="iii.4-dynamique-des-taux-forwards" class="level4">
<h4 class="anchored" data-anchor-id="iii.4-dynamique-des-taux-forwards">III.4 Dynamique des taux forwards</h4>
<p>On note ensuite <span class="math inline">\(L_i(t)\)</span> le taux LIBOR forward à la date <span class="math inline">\(t\)</span> qui fixe en <span class="math inline">\(T_i\)</span> et paie en <span class="math inline">\(T_{i+1}\)</span>. Sous l’hypothèse d’absence d’opportunité d’arbitrage, ce taux s’exprime à partir de la courbe de taux : Î <span class="math display">\[
L_i(t) = \frac{1}{\delta_i}\left(\frac{B(t, T_i)}{B(t, T_{i+1})} - 1\right)  = \frac{1}{\delta_i}\left(Z_t- 1\right) ,
\]</span></p>
<p>Pour connaitre la dynamique des taux forwards, on applique le lemme d’Itô au processus :</p>
<p><span class="math display">\[
Z_t = \frac{B(t, T_i)}{B(t, T_{i+1})}.
\]</span></p>
<blockquote class="blockquote">
<p>Rappel du lemme d’Itô : Considérons deux actifs <span class="math inline">\(X\)</span> et <span class="math inline">\(Y\)</span> et posons <span class="math inline">\(Z = \frac{X}{Y}\)</span> (la valeur de <span class="math inline">\(X\)</span> exprimée en numéraire <span class="math inline">\(Y\)</span>). Le lemme d’Itô nous donne l’évolution de <span class="math inline">\(Z\)</span> par :</p>
<span class="math display">\[
\frac{dZ}{Z} = \left(\frac{dX}{X} - \frac{dY}{Y}\right) - \left\langle \frac{dX}{X} - \frac{dY}{Y},\, \frac{dY}{Y}\right\rangle.
\]</span>
</blockquote>
<p>En appliquant le lemme d’Itô à <span class="math inline">\(Z_t\)</span>, on obtient :</p>
<span class="math display">\[\begin{aligned}
\frac{dZ_t}{Z_t} &amp;= \frac{dB(t, T_i)}{B(t, T_i)} - \frac{dB(t, T_{i+1})}{B(t, T_{i+1})} \\
&amp;- \frac{1}{\cancel{B(t,T_{i+1})^2}} \cancel{B(t,T_{i+1})^2} \, \Gamma(t,T_i,T_{i+1})^2 \, dt \\
&amp;-  \frac{-1}{\cancel{B(t,T_i)B(t,T_{i+1})}} \cancel{B(t,T_i)B(t,T_{i+1})}\,\Gamma(t,T_i)\Gamma(t,T_{i+1})\,dt\\
&amp;= \Gamma(t,T_i,T_{i+1})\left(\Gamma(t,T_{i+1}) - \Gamma(t,T_i)\right)dt + \left(\Gamma(t,T_i) - \Gamma(t,T_{i+1})\right)dW_t^Q\\
&amp;\implies \frac{dZ_t}{Z_t} = \mu(t,T_i,T_{i+1})\,dt + \sigma(t,T_i,T_{i+1})\,dW_t^Q
\end{aligned}\]</span>
<p>avec</p>
<span class="math display">\[\begin{cases}
\sigma(t,T_i,T_{i+1}) = \Gamma(t,T_i) - \Gamma(t,T_{i+1})\\
\mu(t,T_i,T_{i+1}) = \Gamma(t,T_i)\left(\Gamma(t,T_{i+1}) - \Gamma(t,T_i) \right) = - \Gamma(t,T_i) \sigma(t,T_i,T_{i+1})
\end{cases}\]</span>
<p>De ce fait, on a :</p>
<span class="math display">\[\begin{aligned}
\frac{dZ_t}{Z_t} &amp;= - \Gamma(t,T_i) \sigma(t,T_i,T_{i+1})\,dt + \sigma(t,T_i,T_{i+1})\,dW_t^Q\\
&amp;= \sigma(t,T_i,T_{i+1}) \underbrace{\left( - \Gamma(t,T_i)\,dt + dW_t^Q \right)}_{d\tilde{W_t}}\\
&amp;= \sigma(t,T_i,T_{i+1}) d\tilde{W_t}
\end{aligned}\]</span>
<p>où <span class="math inline">\(d\tilde{W_t}\)</span> est un mouvement brownien selon le théorème de Girsanov.</p>
<p>La diffusion de <span class="math inline">\(Z_t\)</span> est une loi log-normale, sans drift sous la probabilité risque forward. De ce fait, il suit le modèle de Black pour la valorisation des options.</p>
<p>On peut écrire ainsi la dynamique du taux forward <span class="math inline">\(L_i(t)\)</span> sous la probabilité risque forward :</p>
<span class="math display">\[\begin{aligned}
dL_i(t) &amp;= \frac{Z_t}{\delta_i} \sigma(t,T_i,T_{i+1})  d\tilde{W_t}  \\
&amp;= (L_i(t) + \frac{1}{\delta_i}) \sigma(t,T_i,T_{i+1})  d\tilde{W_t}
\end{aligned}\]</span>
</section>
<section id="iii.5-valorisation-des-instruments-de-calibration" class="level4">
<h4 class="anchored" data-anchor-id="iii.5-valorisation-des-instruments-de-calibration">III.5 Valorisation des instruments de calibration</h4>
<ol type="1">
<li><strong>Payoff d’un caplet vanille :</strong><br>
Le payoff d’un caplet sur le taux LIBOR <span class="math inline">\(L_i(T_i)\)</span>, de maturité <span class="math inline">\(T_i\)</span>, avec paiement en <span class="math inline">\(T_{i+1}\)</span> et de strike <span class="math inline">\(K\)</span> est donné par :</li>
</ol>
<p><span class="math display">\[
\text{Payoff} = \delta_i\, \max\Bigl( L_i(T_i) - K,\; 0 \Bigr).
\]</span></p>
<ol start="2" type="1">
<li><strong>Formule de valorisation dans le cadre du modèle H&amp;W :</strong><br>
Il peut être démontré que la formule de valorisation de ce caplet s’exprime de la manière suivante :</li>
</ol>
<p><span class="math display">\[
C\Bigl( Z_t,\, \tilde{K},\, T_i,\, \sigma_i^*,\, B(t, T_{i+1}) \Bigr) \quad (11)
\]</span></p>
<p>avec :</p>
<ul>
<li>$ Z_t = $,</li>
<li>$ (_i^*)^2 = <em>t^{T_i} ( (s, T_i) - (s, T</em>{i+1}) )^2 ds = ^2(T_i, T_{i+1}), (T_i) $,</li>
<li>$ = 1 + _i K $,</li>
<li>$ C() $ désigne le prix d’un Call selon le cadre Black, en fonction du forward, du strike, de la maturité, de la volatilité et du facteur d’actualisation.</li>
</ul>
<p>En effet, on peut réécrire le payoff d’un caplet sous la forme d’un Call sur <span class="math inline">\(Z_t\)</span> qui suit un modèle de Black :</p>
<span class="math display">\[\begin{aligned}
\text{Payoff} &amp;= \delta_i\, \max\Bigl( L_i(T_i) - K,\; 0 \Bigr) \\
&amp;= \delta_i\, \max\Bigl( \frac{Z_t}{\delta_i} - 1 - K; 0 \Bigr) \\
&amp;= \delta_i\, \max\Bigl( \frac{Z_t - 1 - \delta_i K}{\delta_i}; 0 \Bigr) \\
&amp;= \max\Bigl(Z_t - 1 - \delta_i K; 0 \Bigr) \\
\text{Payoff} &amp;= \max\Bigl( Z_t - \tilde{K},\; 0 \Bigr) \\
\end{aligned}\]</span>
</section>
<section id="iii.6.-calibration-du-modèle" class="level3">
<h3 class="anchored" data-anchor-id="iii.6.-calibration-du-modèle">III.6. Calibration du modèle</h3>
<p>Le modèle de Hull White permet d’avoir une formule fermée pour le prix des caplets. De fait, puisqu’on a calculé les prix de marché de caplets sur euribor12M, ce qui implique une période de capitalisation annuelle, de maturité T = 5Y, nous pouvons desormais calibrer le paramètre de volatilité <span class="math inline">\(\sigma_i^*\)</span> avec la méthode de dichotomie et aussi extraire de manière analytique la volatilité instantanée <span class="math inline">\(\sigma(t)\)</span> du modèle Hull&amp;White, qu’on supposera constante, i.e.&nbsp;<span class="math inline">\(\sigma(t) = \sigma\)</span>.</p>
<p>On pose également, pour la calibration, <span class="math inline">\(\lambda = 5\%\)</span>.</p>
<p>Pour extraire la volatilité spot, nous utiliserons uniquement le prix de marche ATM.</p>
<div id="8c82239f" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>caplet_price_MKT <span class="op">=</span> vol_data.loc[<span class="dv">3</span>, <span class="st">'Caplet Price MKT'</span>]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Le prix de marché caplet sur euribor 12M de maturité T=5Y est de </span><span class="sc">{</span>caplet_price_MKT<span class="sc">:.4%}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Le prix de marché caplet sur euribor 12M de maturité T=5Y est de 0.7137%</code></pre>
</div>
</div>
<div id="3b9ee3b4" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_i, option_type<span class="op">=</span><span class="st">'caplet'</span>, model<span class="op">=</span><span class="st">'HW'</span>):</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> model <span class="op">==</span> <span class="st">"HW"</span> :</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        Z_t <span class="op">=</span> delta_i <span class="op">*</span> L_i_t <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        K <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> delta_i <span class="op">*</span> K</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> price_oplet(N<span class="op">=</span>N, delta_i<span class="op">=</span>delta_i, B_t_Ti<span class="op">=</span>B_t_Ti, L_i_t<span class="op">=</span>Z_t, K<span class="op">=</span>K, sigma_i<span class="op">=</span>sigma_i, Ti<span class="op">=</span>Ti, t<span class="op">=</span>t, option_type<span class="op">=</span>option_type)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> price_oplet(N<span class="op">=</span>N, delta_i<span class="op">=</span>delta_i, B_t_Ti<span class="op">=</span>B_t_Ti, L_i_t<span class="op">=</span>L_i_t, K<span class="op">=</span>K, sigma_i<span class="op">=</span>sigma_i, Ti<span class="op">=</span>Ti, t<span class="op">=</span>t, option_type<span class="op">=</span>option_type)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="45e22637" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Dichotomie(N, delta_i, B_t_Ti, L_i_t, K, Ti, t,caplet_price_MKT,option_type<span class="op">=</span><span class="st">'caplet'</span>, model<span class="op">=</span><span class="st">"HW"</span>,tol<span class="op">=</span><span class="fl">1e-6</span>, sigma_low<span class="op">=</span><span class="dv">1</span><span class="op">/</span><span class="dv">10000</span>, sigma_high<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Extrait la volatilité implicite sigma en utilisant la méthode de dichotomie.</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    fmin <span class="op">=</span> price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_low, option_type<span class="op">=</span>option_type, model<span class="op">=</span>model)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    fmax <span class="op">=</span> price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_high,option_type<span class="op">=</span>option_type, model<span class="op">=</span>model)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    price <span class="op">=</span> caplet_price_MKT</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> fmin<span class="op">&gt;</span>price :</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sigma_low</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> fmax<span class="op">&lt;</span>price :</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sigma_high</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> sigma_high<span class="op">-</span>sigma_low<span class="op">&gt;</span>tol:</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>            sigma_mid <span class="op">=</span> (sigma_low <span class="op">+</span> sigma_high) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>            fmin <span class="op">=</span> price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_low, option_type<span class="op">=</span>option_type, model<span class="op">=</span>model)</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>            fmid <span class="op">=</span> price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_mid,option_type<span class="op">=</span>option_type, model<span class="op">=</span>model)</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> ((fmin <span class="op">-</span> price) <span class="op">*</span> (fmid <span class="op">-</span> price) <span class="op">&gt;</span> <span class="dv">0</span>) : <span class="co"># jette la moitié de gauche</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>                sigma_low <span class="op">=</span> sigma_mid</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: <span class="co"># jette la moitié de droite</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>                sigma_high <span class="op">=</span> sigma_mid</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        sigma_mid <span class="op">=</span> (sigma_low <span class="op">+</span> sigma_high) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sigma_mid</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Notional</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">1</span>  </span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Période du caplet</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>delta_i <span class="op">=</span> <span class="dv">1</span> </span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Maturité du caplet</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>Ti<span class="op">=</span><span class="dv">6</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Facteur d'actualisation B(t, Ti)</span></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>B_t_Ti <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>]</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Taux forward Li(t)</span></span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>L_i_t <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>delta_i) <span class="op">*</span> ((df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti<span class="op">-</span><span class="dv">1</span>, <span class="st">'B'</span>].values[<span class="dv">0</span>]<span class="op">/</span>df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Strike du caplet</span></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> L_i_t <span class="op">+</span> vol_data.loc[<span class="dv">3</span>, <span class="st">'Strike en bps et en rel. / fwd'</span>]<span class="op">/</span><span class="dv">10000</span></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>lambda_ <span class="op">=</span> <span class="dv">5</span><span class="op">/</span><span class="dv">100</span></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>sigma_i <span class="op">=</span> Dichotomie(N, delta_i, B_t_Ti, L_i_t, K, Ti, t,caplet_price_MKT, option_type<span class="op">=</span><span class="st">'caplet'</span>,model<span class="op">=</span><span class="st">"HW"</span>)</span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Volatilité implicite (en %) :"</span>, sigma_i<span class="op">*</span><span class="dv">100</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Volatilité implicite (en %) : 0.9271045541763303</code></pre>
</div>
</div>
<div id="d9959dd1" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>beta_Ti_Ti_1 <span class="op">=</span>  ((<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span> lambda_ <span class="op">*</span> delta_i))<span class="op">/</span>lambda_)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>Ti_1 <span class="op">=</span> Ti <span class="op">-</span> delta_i</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>phi <span class="op">=</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>lambda_<span class="op">*</span>(Ti_1<span class="op">-</span>t)))<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>lambda_)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> np.sqrt((sigma_i<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> Ti_1)<span class="op">/</span> (beta_Ti_Ti_1 <span class="op">*</span> phi))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Volatilité instantanée (en %) :"</span>, sigma<span class="op">*</span><span class="dv">100</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Volatilité instantanée (en %) : 1.071446257025021</code></pre>
</div>
</div>
<ol start="2" type="1">
<li>Cette volatilité spot nous permet de valoriiser les caplets pour des strikes différents de l’ATM à l’aide de la formule de valorisation fermée du modèle Hull et White.</li>
</ol>
<div id="4d41d6ea" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> vol_data.index:</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Notional</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">1</span>  </span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Période du caplet</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    delta_i <span class="op">=</span> <span class="dv">1</span> </span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Maturité du caplet</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    Ti<span class="op">=</span><span class="dv">6</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Facteur d'actualisation B(t, Ti)</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    B_t_Ti <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>]</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Taux forward Li(t)</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    L_i_t <span class="op">=</span> (<span class="dv">1</span><span class="op">/</span>delta_i) <span class="op">*</span> ((df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti<span class="op">-</span><span class="dv">1</span>, <span class="st">'B'</span>].values[<span class="dv">0</span>]<span class="op">/</span>df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Strike du caplet</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> L_i_t <span class="op">+</span> vol_data.loc[i, <span class="st">'Strike en bps et en rel. / fwd'</span>]<span class="op">/</span><span class="dv">10000</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    sigma_i <span class="op">=</span> sigma_i</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    lambda_ <span class="op">=</span> <span class="dv">5</span><span class="op">/</span><span class="dv">100</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>    caplet_price <span class="op">=</span> price_oplet_HW(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, sigma_i, option_type<span class="op">=</span><span class="st">'caplet'</span>, model<span class="op">=</span><span class="st">'HW'</span>)</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>    vol_data.loc[i, <span class="st">'Caplet Price HW'</span>] <span class="op">=</span> caplet_price</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>vol_data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Strike en bps et en rel. / fwd</th>
<th data-quarto-table-cell-role="th">Vols Caplets</th>
<th data-quarto-table-cell-role="th">Vols Swaptions</th>
<th data-quarto-table-cell-role="th">Caplet Price MKT</th>
<th data-quarto-table-cell-role="th">Caplet Price HW</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>-100</td>
<td>0.311859</td>
<td>0.311859</td>
<td>0.012511</td>
<td>0.012015</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>-50</td>
<td>0.283274</td>
<td>0.283274</td>
<td>0.009788</td>
<td>0.009389</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>-25</td>
<td>0.265921</td>
<td>0.265921</td>
<td>0.008419</td>
<td>0.008215</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>0</td>
<td>0.250000</td>
<td>0.250000</td>
<td>0.007137</td>
<td>0.007137</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>25</td>
<td>0.243451</td>
<td>0.243451</td>
<td>0.006185</td>
<td>0.006156</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>50</td>
<td>0.249019</td>
<td>0.249019</td>
<td>0.005661</td>
<td>0.005269</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>100</td>
<td>0.271828</td>
<td>0.271828</td>
<td>0.005167</td>
<td>0.003771</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>L’une des faiblesses du modèle de Hull et White est le fait qu’il n’arrive pas à capter le smile de volatilité. En effet, la volatilité implicite extraite est un skew. Pour constater ce phénomène, nous inverserons la formule de Black pour les caplets et nous en déduirons la volatilité implicite pour chaque strike. Nous utiliserons toujours la méthode de dichotomie pour trouver la volatilité implicite.</p>
<div id="7d3aba42" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> vol_data.index:</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    delta_i <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    Ti <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    B_t_Ti <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>]</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    L_i_t <span class="op">=</span> (<span class="dv">1</span> <span class="op">/</span> delta_i) <span class="op">*</span> ((df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti<span class="op">-</span><span class="dv">1</span>, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="op">/</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> L_i_t <span class="op">+</span> vol_data.loc[i, <span class="st">'Strike en bps et en rel. / fwd'</span>] <span class="op">/</span> <span class="dv">10000</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    lambda_ <span class="op">=</span> <span class="dv">5</span> <span class="op">/</span> <span class="dv">100</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    caplet_price_MKT <span class="op">=</span> vol_data.loc[i, <span class="st">'Caplet Price HW'</span>]</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    sigma_extracted <span class="op">=</span>  Dichotomie(N, delta_i, B_t_Ti, L_i_t, K, Ti, t, caplet_price_MKT, option_type<span class="op">=</span><span class="st">'caplet'</span>, model<span class="op">=</span><span class="st">'Black'</span>)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    vol_data.loc[i, <span class="st">'Sigma_HW'</span>] <span class="op">=</span> sigma_extracted</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>vol_data</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Strike en bps et en rel. / fwd</th>
<th data-quarto-table-cell-role="th">Vols Caplets</th>
<th data-quarto-table-cell-role="th">Vols Swaptions</th>
<th data-quarto-table-cell-role="th">Caplet Price MKT</th>
<th data-quarto-table-cell-role="th">Caplet Price HW</th>
<th data-quarto-table-cell-role="th">Sigma_HW</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>-100</td>
<td>0.311859</td>
<td>0.311859</td>
<td>0.012511</td>
<td>0.012015</td>
<td>0.288669</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>-50</td>
<td>0.283274</td>
<td>0.283274</td>
<td>0.009788</td>
<td>0.009389</td>
<td>0.267386</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>-25</td>
<td>0.265921</td>
<td>0.265921</td>
<td>0.008419</td>
<td>0.008215</td>
<td>0.258287</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>0</td>
<td>0.250000</td>
<td>0.250000</td>
<td>0.007137</td>
<td>0.007137</td>
<td>0.250009</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>25</td>
<td>0.243451</td>
<td>0.243451</td>
<td>0.006185</td>
<td>0.006156</td>
<td>0.242433</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>50</td>
<td>0.249019</td>
<td>0.249019</td>
<td>0.005661</td>
<td>0.005269</td>
<td>0.235466</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>100</td>
<td>0.271828</td>
<td>0.271828</td>
<td>0.005167</td>
<td>0.003771</td>
<td>0.223060</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="95d34c5b" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">5</span>))</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>plt.plot(vol_data[<span class="st">"Strike en bps et en rel. / fwd"</span>], vol_data[<span class="st">"Sigma_HW"</span>], label<span class="op">=</span><span class="st">'Volatilité extraite'</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>plt.plot(vol_data[<span class="st">"Strike en bps et en rel. / fwd"</span>], vol_data[<span class="st">"Vols Caplets"</span>], label<span class="op">=</span><span class="st">'Volatilité de marché'</span>, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Comparaison de la volatilité extraite par le modèle HW et la volatilité de marché'</span>)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Strike en bps et en rel. / fwd '</span>)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Volatilité'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>Text(0, 0.5, 'Volatilité')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-26-output-2.png" width="697" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="160af4ce" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>ATM  <span class="op">=</span> L_i_t</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="valorisation-dun-produit-structuré" class="level3">
<h3 class="anchored" data-anchor-id="valorisation-dun-produit-structuré">3.7 Valorisation d’un produit structuré</h3>
<blockquote class="blockquote">
<p>Remarques préliminaires :</p>
<ul>
<li>Nous garderons dans un premier temps la calibration ATM effectuée avec <span class="math inline">\(\lambda = 5\%\)</span>.</li>
<li>Pour la partie Monte-Carlo, nous admettrons que l’EDS pour le processus <span class="math inline">\(X_t\)</span> sous la probabilité forward neutre <span class="math inline">\(Q^T\)</span> associée au numéraire <span class="math inline">\(B(t,T)\)</span> s’écrit comme :</li>
</ul>
<p><span class="math display">\[
dX_t = \left[\phi(t) + \sigma(t)\Gamma(t,T) - \lambda X_t\right] dt + \sigma(t) dW_t^T \tag{12}
\]</span></p>
Où <span class="math inline">\(W_t^T\)</span> est un brownien sous <span class="math inline">\(Q^T\)</span>.
</blockquote>
<p>Nous souhaitons valoriser un caplet de strike <span class="math inline">\(K\)</span>, de dates de fixing <span class="math inline">\(T_i = 5Y\)</span> et de paiement <span class="math inline">\(T_{i+1} = 6Y\)</span> et de barrière désactivante <span class="math inline">\(B\)</span> (avec <span class="math inline">\(B &gt; K\)</span>).</p>
<ol type="1">
<li>Écrire le payoff de l’option et tracer la fonction de payoff en fonction de <span class="math inline">\(L_i(T_i)\)</span>. Cette option est-elle plus ou moins chère qu’un simple caplet de strike <span class="math inline">\(K\)</span> ?</li>
</ol>
<p>Le payoff de l’option est donné par :</p>
<p><span class="math display">\[
\text{Payoff} = \delta_i\, \max\Bigl( L_i(T_i) - K,\; 0 \Bigr) \mathbb{1}_{L_i(T_i) &lt; B}
\]</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="attachment:image-2.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>image-2.png</figcaption>
</figure>
</div>
<p>Il est possible de décomposer le payoff à partir d’options vanilles et digitales :</p>
<p><span class="math display">\[
\text{Payoff} = C_K - CB - (B-K) \times D_B
\]</span></p>
<blockquote class="blockquote">
<p>Une option digitale est une option qui paie 1 si le sous-jacent est au-dessus d’un certain seuil et 0 sinon. De ce fait, le payoff de l’option est donné par :</p>
<p><span class="math display">\[
D_B = \delta_i\, \max\Bigl( L_i(T_i) - K,\; 0 \Bigr) \mathbb{1}_{L_i(T_i) &gt; K}
\]</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="attachment:image.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>image.png</figcaption>
</figure>
</div>
<p>Une option vanille est un contrat financier standardisé qui donne le droit, mais non l’obligation, d’acheter (call) ou de vendre (put) un actif sous-jacent à un prix fixé (strike) à une date donnée (maturité). De ce fait, dans le cas d’un call, le payoff de l’option est donné par :</p>
<p><span class="math display">\[
C_K = \delta_i\, \max\Bigl( L_i(T_i) - K,\; 0 \Bigr)
\]</span></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="attachment:Capture%20d’écran%202025-03-05%20à%2000.17.09.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Capture d’écran 2025-03-05 à 00.17.09.png</figcaption>
</figure>
</div>
</blockquote>
<ol start="3" type="1">
<li>Rappeler les principes du pricing par méthode de Monte-Carlo.</li>
</ol>
<p>La méthode de Monte-Carlo est une méthode numérique qui permet de pricer des produits financiers complexes lorsque les formules fermées ne sont pas disponibles. Elle consiste à simuler un grand nombre <span class="math inline">\(N\)</span> de trajectoires du processus stochastique et à calculer la moyenne empiriques des payoffs actualisés pour obtenir le prix de l’option.</p>
<ol start="4" type="1">
<li>Rappeler comment on simule une loi gaussienne à partir d’une loi uniforme.</li>
</ol>
<p>Pour simuler une variable aléatoire suivant une loi gaussienne standard <span class="math inline">\(\mathcal{N}(0,1)\)</span> à partir d’une variable uniforme <span class="math inline">\(U\)</span> sur <span class="math inline">\([0,1]\)</span>, on applique l’<strong>inverse de la fonction de répartition de la loi gaussienne standard</strong> (aussi appelée la fonction quantile de la loi normale) :</p>
<p><span class="math display">\[
X = F^{-1}(U)
\]</span></p>
<p>où <span class="math inline">\(F\)</span> est la fonction de répartition de la loi normale standard.</p>
<ol start="5" type="1">
<li>On considère un caplet sur euribor12M à barrière désactivante de strike $ K = ATM - 100 bps$, de barrière <span class="math inline">\(B = ATM + 100 bps\)</span> et de maturité <span class="math inline">\(T_i = 5Y\)</span>. Pour valoriser cette option, nous allons utiliser une méthode numérique de type Monte-Carlo. Pour cela, il est necessaire de connaire la loi de X_t sachant X_s. En nous aidant de la question précédente, on peut déduire que la loi de <span class="math inline">\(X_t|X_s\)</span> est une loi normale de paramètres :</li>
</ol>
<p><span class="math display">\[
X_t|X_s \sim \mathcal{N}\left( X_s e^{-\lambda (t-s)} + \int_s^t e^{-\lambda (t-u)} \left( \phi(u) - \sigma \Gamma(u,T) \right) du, \quad \int_s^t e^{-2 \lambda (t-u)} \sigma^2 d \right)
\]</span></p>
<p>Pour valoriser cette option, nous pouvons directement utiliser la loi de <span class="math inline">\(X_5|X_0\)</span> pour simuler les trajectoires du taux court et calculer le payoff de l’option ou diffuser progressivement le taux court en utilisant la loi de <span class="math inline">\(X_t|X_s\)</span> pour chaque pas de temps. Ensuite, il s’agira de calculer le payoff de l’option à chaque date, en faire la moyenne et l’actualiser pour obtenir le prix de l’option.</p>
<section id="méthode-1-simulation-de-la-loi-de-x_5x_0" class="level5">
<h5 class="anchored" data-anchor-id="méthode-1-simulation-de-la-loi-de-x_5x_0">Méthode 1 : Simulation de la loi de <span class="math inline">\(X_5|X_0\)</span></h5>
<div id="bf4450d6" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> quad</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Fonction phi(t) - variance cumulée</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> phi(t, sigma, lambda_):</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (sigma<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> lambda_)) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">2</span> <span class="op">*</span> lambda_ <span class="op">*</span> t))</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Fonction beta(t, T)</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> beta(t, T, lambda_):</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span>lambda_ <span class="op">*</span> (T <span class="op">-</span> t))) <span class="op">/</span> lambda_</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Fonction gamma(t, T)</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gamma(t, T, sigma, lambda_):</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (sigma <span class="op">/</span> lambda_) <span class="op">*</span> (np.exp(<span class="op">-</span>lambda_ <span class="op">*</span> (T <span class="op">-</span> t)) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Fonction B(t, T)</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> B_t_T(t, T, B0_T, B0_t, X_t, sigma, lambda_):</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>    beta_t_T <span class="op">=</span> beta(t, T, lambda_)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>    phi_t <span class="op">=</span> phi(t, sigma, lambda_)</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>    exponent <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> beta_t_T <span class="op">*</span> phi_t <span class="op">-</span> beta_t_T <span class="op">*</span> X_t</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (B0_T <span class="op">/</span> B0_t) <span class="op">*</span> np.exp(exponent)</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Fonction d'intégration avec paramètres supplémentaires</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> integrand_mean(u, t, Xs, s, sigma, lambda_, T):</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># t = borne sup</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># s = borne inf</span></span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># T = maturité</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>    Xt <span class="op">=</span> Xs <span class="op">*</span> np.exp(<span class="op">-</span>lambda_ <span class="op">*</span> (t <span class="op">-</span> s))</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>    exp_part <span class="op">=</span> np.exp(<span class="op">-</span>lambda_ <span class="op">*</span> (t <span class="op">-</span> u))</span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Xt <span class="op">+</span> exp_part <span class="op">*</span> (phi(u, sigma, lambda_) <span class="op">+</span> sigma <span class="op">*</span> gamma(u, T, sigma, lambda_))</span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Paramètres</span></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> Ti_1  <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>Xs <span class="op">=</span> X0 <span class="op">=</span> <span class="dv">0</span>  </span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> Ti_1 </span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcul de la moyenne conditionnelle</span></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>mean_5_given_0, _ <span class="op">=</span> quad(integrand_mean, s, t, args<span class="op">=</span>(t, Xs, s, sigma, lambda_, T))</span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Moyenne conditionnelle de X_5 | X_0 : </span><span class="sc">{</span>mean_5_given_0<span class="sc">:.6f}</span><span class="ss">"</span>)</span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Calcul de la variance conditionnelle (indépendant de gamma ici)</span></span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_variance(sigma, lambda_, t, s):</span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (sigma<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">2</span> <span class="op">*</span> lambda_ <span class="op">*</span> (t <span class="op">-</span> s))) <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> lambda_)</span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a>var_5_given_0 <span class="op">=</span> compute_variance(sigma, lambda_, t, s)</span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a><span class="co"># var_5_given_0 = (sigma**2) * (1 - np.exp(-2 * lambda_ * (t - s))) / (2 * lambda_)</span></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Variance conditionnelle de X_5 | X_0 : </span><span class="sc">{</span>var_5_given_0<span class="sc">:.6f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Moyenne conditionnelle de X_5 | X_0 : 0.000000
Variance conditionnelle de X_5 | X_0 : 0.000452</code></pre>
</div>
</div>
<div id="a6413d3e" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>Ti_1 <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>Ti <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation Monte Carlo</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>n_simulations <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>payoffs <span class="op">=</span> np.zeros(n_simulations)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sim <span class="kw">in</span> <span class="bu">range</span>(n_simulations):</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    phi_ <span class="op">=</span> phi(Ti_1, sigma, lambda_)</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    gamma_ <span class="op">=</span> gamma(Ti_1,Ti, sigma, lambda_)</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Moyenne</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    mu_X <span class="op">=</span> mean_5_given_0</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ecart-type</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    sigma_X <span class="op">=</span> np.sqrt(var_5_given_0)</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># X_5|X_0</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.random.normal(mu_X, sigma_X)  </span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du prix B(5,6) selon Hull-White</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    B0_6 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,6)</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>    B0_5 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti_1, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,5)</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>    B_5_6 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">6</span>, B0_6, B0_5, X, sigma, lambda_)</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>    B_5_5 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">5</span>, B0_5, B0_5, X, sigma, lambda_)</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du taux forward L_i_t</span></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>    L_i_t <span class="op">=</span> ((B_5_5 <span class="op">/</span> B_5_6) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>    bp <span class="op">=</span> <span class="dv">100</span><span class="op">/</span><span class="dv">10000</span></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Définition du strike</span></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>    strike <span class="op">=</span> ATM <span class="op">-</span> bp</span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Barrière</span></span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> ATM <span class="op">+</span> bp</span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Payoff de l'option</span></span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>    payoff <span class="op">=</span> np.maximum(L_i_t <span class="op">-</span> strike, <span class="dv">0</span>) <span class="op">*</span> (L_i_t <span class="op">&lt;</span> B)</span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>    payoffs[sim] <span class="op">=</span> payoff</span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Prix de l'option call</span></span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>call_price <span class="op">=</span> B0_6 <span class="op">*</span> np.mean(payoffs)</span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Prix du call : </span><span class="sc">{</span>call_price<span class="sc">:.6f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Prix du call : 0.003048</code></pre>
</div>
</div>
</section>
<section id="méthode-2-methode-de-diffusion" class="level5">
<h5 class="anchored" data-anchor-id="méthode-2-methode-de-diffusion">Méthode 2 : Methode de diffusion</h5>
<div id="5b230802" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation Monte Carlo</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>n_simulations <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>payoffs <span class="op">=</span> np.zeros(n_simulations)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>X0 <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>Ti <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>Ti_1 <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.zeros(Ti)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>X[<span class="dv">0</span>] <span class="op">=</span> X0</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sim <span class="kw">in</span> <span class="bu">range</span>(n_simulations):</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    phi_ <span class="op">=</span> phi(Ti_1, sigma, lambda_)</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    gamma_ <span class="op">=</span> gamma(Ti_1,Ti, sigma, lambda_)</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,Ti):</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> i</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> i<span class="op">-</span><span class="dv">1</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>        T <span class="op">=</span> <span class="dv">5</span> </span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>        Xs <span class="op">=</span> X[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calcul de la moyenne conditionnelle</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>        mu_X, _ <span class="op">=</span> quad(integrand_mean, s, t, args<span class="op">=</span>(t, Xs, s, sigma, lambda_, T))</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>        sigma_X <span class="op">=</span> np.sqrt(compute_variance(sigma, lambda_, t, s))</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>        X[i] <span class="op">=</span> np.random.normal(mu_X, sigma_X)</span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du prix B(5,6) selon Hull-White</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>    B0_6 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,6)</span></span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>    B0_5 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti_1, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,5)</span></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>    B_5_6 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">6</span>, B0_6, B0_5, X[Ti_1], sigma, lambda_)</span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>    B_5_5 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">5</span>, B0_5, B0_5, X[Ti_1], sigma, lambda_)</span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du taux forward L_i_t</span></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>    L_i_t <span class="op">=</span> ((B_5_5 <span class="op">/</span> B_5_6) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>    bp <span class="op">=</span> <span class="dv">100</span><span class="op">/</span><span class="dv">10000</span></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Définition du strike</span></span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a>    strike <span class="op">=</span> ATM <span class="op">-</span> bp</span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Barrière</span></span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> ATM <span class="op">+</span> bp</span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Payoff de l'option</span></span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a>    payoff <span class="op">=</span> np.maximum(L_i_t <span class="op">-</span> strike, <span class="dv">0</span>) <span class="op">*</span> (L_i_t <span class="op">&lt;</span> B)</span>
<span id="cb41-45"><a href="#cb41-45" aria-hidden="true" tabindex="-1"></a>    payoffs[sim] <span class="op">=</span> payoff</span>
<span id="cb41-46"><a href="#cb41-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-47"><a href="#cb41-47" aria-hidden="true" tabindex="-1"></a><span class="co"># Prix de l'option call</span></span>
<span id="cb41-48"><a href="#cb41-48" aria-hidden="true" tabindex="-1"></a>call_price <span class="op">=</span> B0_6 <span class="op">*</span> np.mean(payoffs)</span>
<span id="cb41-49"><a href="#cb41-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Prix du call : </span><span class="sc">{</span>call_price<span class="sc">:.6f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Prix du call : 0.003032</code></pre>
</div>
</div>
<p>Nous constatons qu’avec les deux méthodes, nous obtenons des prix d’options similaires (différent de 0.2bps). Cela confirme que les deux méthodes convergent vers le même résultat.</p>
<p>En dégénérant le produit en faisant tendre la barrière à <span class="math inline">\(+\infty\)</span>, nous constatons que le prix de l’option call est égal au prix de marché du forward. En dégénérant le produit en faisant tendre la barrière à 0, nous constatons que le prix de l’option call est égal à 0.</p>
<p>Cela est cohérent car lorsque la barrière est très élevée, le produit est équivalent à un forward et lorsque la barrière est nulle, le produit est équivalent à un call classique. La fonction que nous avons implémenté est donc cohérente et bien implémentée.</p>
<div id="4b4de405" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>Ti_1 <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>Ti <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation Monte Carlo</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>n_simulations <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>payoffs <span class="op">=</span> np.zeros(n_simulations)</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sim <span class="kw">in</span> <span class="bu">range</span>(n_simulations):</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    phi_ <span class="op">=</span> phi(Ti_1, sigma, lambda_)</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    gamma_ <span class="op">=</span> gamma(Ti_1,Ti, sigma, lambda_)</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Moyenne</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>    mu_X <span class="op">=</span> mean_5_given_0</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ecart-type</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    sigma_X <span class="op">=</span> np.sqrt(var_5_given_0)</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># X_5|X_0</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.random.normal(mu_X, sigma_X)  </span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du prix B(5,6) selon Hull-White</span></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>    B0_6 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,6)</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>    B0_5 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti_1, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,5)</span></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>    B_5_6 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">6</span>, B0_6, B0_5, X, sigma, lambda_)</span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>    B_5_5 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">5</span>, B0_5, B0_5, X, sigma, lambda_)</span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du taux forward L_i_t</span></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>    L_i_t <span class="op">=</span> ((B_5_5 <span class="op">/</span> B_5_6) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>    bp <span class="op">=</span> <span class="dv">100</span><span class="op">/</span><span class="dv">10000</span></span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Définition du strike</span></span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a>    strike <span class="op">=</span> ATM <span class="co"># - bp</span></span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Barrière</span></span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> np.inf<span class="co">#ATM + bp</span></span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Payoff de l'option</span></span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a>    payoff <span class="op">=</span> np.maximum(L_i_t <span class="op">-</span> strike, <span class="dv">0</span>) <span class="op">*</span> (L_i_t <span class="op">&lt;</span> B)</span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a>    payoffs[sim] <span class="op">=</span> payoff</span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Prix de l'option call</span></span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a>call_price <span class="op">=</span> B0_6 <span class="op">*</span> np.mean(payoffs)</span>
<span id="cb43-44"><a href="#cb43-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Prix du call : </span><span class="sc">{</span>call_price<span class="sc">:.6f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Prix du call : 0.007094</code></pre>
</div>
</div>
<p>Nous rendons la barrière ‘bermudéenne’ en étendant la condition de désactivation aux dates 1Y, 2Y, 3Y, 4Y et 5Y. De ce fait, le payoff de cette option s’écrit :</p>
<p><span class="math display">\[
\text{Payoff} = \delta_i \max\Bigl( L_i(T_i) - K,\; 0 \Bigr) \mathbb{1}_{max_{i=1,\dots,5}(L_i(T_i) &lt; B)}
\]</span></p>
<div id="00ad37a1" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Option bermudienne</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulation Monte Carlo</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>n_simulations <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>payoffs <span class="op">=</span> np.zeros(n_simulations)</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>X0 <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>Ti <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>Ti_1 <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.zeros(Ti)</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>X[<span class="dv">0</span>] <span class="op">=</span> X0</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> sim <span class="kw">in</span> <span class="bu">range</span>(n_simulations):</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    phi_ <span class="op">=</span> phi(Ti_1, sigma, lambda_)</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>    gamma_ <span class="op">=</span> gamma(Ti_1,Ti, sigma, lambda_)</span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>    L_i_t <span class="op">=</span> np.zeros(Ti_1)</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,Ti):</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> i</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> i<span class="op">-</span><span class="dv">1</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>        T <span class="op">=</span> <span class="dv">5</span> </span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>        Xs <span class="op">=</span> X[s]</span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calcul de la moyenne conditionnelle</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>        mu_X, _ <span class="op">=</span> quad(integrand_mean, s, t, args<span class="op">=</span>(t, Xs, s, sigma, lambda_, T))</span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>        sigma_X <span class="op">=</span> np.sqrt(compute_variance(sigma, lambda_, t, s))</span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>        X[i] <span class="op">=</span> np.random.normal(mu_X, sigma_X)</span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calcul du prix B(5,6) selon Hull-White</span></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>        Bi_t <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> t, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,6)</span></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>        Bi_s <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> s, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,5)</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a>        B_s_t <span class="op">=</span> B_t_T(s, t, Bi_t, Bi_s, X[i], sigma, lambda_)</span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a>        B_s_s <span class="op">=</span> B_t_T(s, s, Bi_s, Bi_s, X[i], sigma, lambda_)</span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calcul du taux forward L_i_t</span></span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a>        L_i_t[i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">/</span> (t<span class="op">-</span>s)) <span class="op">*</span> ((B_s_s <span class="op">/</span> B_s_t) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du prix B(5,6) selon Hull-White</span></span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a>    B0_6 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,6)</span></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a>    B0_5 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti_1, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,5)</span></span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true" tabindex="-1"></a>    B_5_6 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">6</span>, B0_6, B0_5, X[Ti_1], sigma, lambda_)</span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true" tabindex="-1"></a>    B_5_5 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">5</span>, B0_5, B0_5, X[Ti_1], sigma, lambda_)</span>
<span id="cb45-44"><a href="#cb45-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-45"><a href="#cb45-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calcul du taux forward L_i_t</span></span>
<span id="cb45-46"><a href="#cb45-46" aria-hidden="true" tabindex="-1"></a>    L_t <span class="op">=</span> ((B_5_5 <span class="op">/</span> B_5_6) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb45-47"><a href="#cb45-47" aria-hidden="true" tabindex="-1"></a>    bp <span class="op">=</span> <span class="dv">100</span><span class="op">/</span><span class="dv">10000</span></span>
<span id="cb45-48"><a href="#cb45-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-49"><a href="#cb45-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-50"><a href="#cb45-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Définition du strike</span></span>
<span id="cb45-51"><a href="#cb45-51" aria-hidden="true" tabindex="-1"></a>    strike <span class="op">=</span> ATM <span class="op">-</span> bp</span>
<span id="cb45-52"><a href="#cb45-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-53"><a href="#cb45-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Barrière</span></span>
<span id="cb45-54"><a href="#cb45-54" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> ATM <span class="op">+</span> bp</span>
<span id="cb45-55"><a href="#cb45-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-56"><a href="#cb45-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Payoff de l'option</span></span>
<span id="cb45-57"><a href="#cb45-57" aria-hidden="true" tabindex="-1"></a>    payoff <span class="op">=</span> np.maximum(L_t <span class="op">-</span> strike, <span class="dv">0</span>) <span class="op">*</span> (np.<span class="bu">max</span>(L_i_t) <span class="op">&lt;</span> B)</span>
<span id="cb45-58"><a href="#cb45-58" aria-hidden="true" tabindex="-1"></a>    payoffs[sim] <span class="op">=</span> payoff</span>
<span id="cb45-59"><a href="#cb45-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-60"><a href="#cb45-60" aria-hidden="true" tabindex="-1"></a><span class="co"># Prix de l'option call</span></span>
<span id="cb45-61"><a href="#cb45-61" aria-hidden="true" tabindex="-1"></a>call_price <span class="op">=</span> B0_6 <span class="op">*</span> np.mean(payoffs)</span>
<span id="cb45-62"><a href="#cb45-62" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Prix du call : </span><span class="sc">{</span>call_price<span class="sc">:.6f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Prix du call : 0.003071</code></pre>
</div>
</div>
<p>L’un des paramètres important du modèle de Hull et White est la mean reversion <span class="math inline">\(\lambda\)</span>, qui caractérise la force de rappel à la moyenne du processus. Ce paramètre a un impact positive sur la valorisation de l’option, comme nous pouvons l’observer dans la figure ci dessous .</p>
<div id="0b757055" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Liste des lambda à tester</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>lambdas <span class="op">=</span> np.linspace(<span class="fl">0.01</span>, <span class="dv">1</span>, <span class="dv">15</span>)  <span class="co"># Exemple de grille de lambda</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> []</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>Ti_1 <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>Ti <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Boucle principale sur les lambdas</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> lambda_ <span class="kw">in</span> lambdas:</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    n_touched <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    payoffs <span class="op">=</span> np.zeros(n_simulations)</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> sim <span class="kw">in</span> <span class="bu">range</span>(n_simulations):</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>        phi_ <span class="op">=</span> phi(Ti_1, sigma, lambda_)</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>        gamma_ <span class="op">=</span> gamma(Ti_1,Ti, sigma, lambda_)</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Moyenne</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>        mu_X <span class="op">=</span> mean_5_given_0</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ecart-type</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>        sigma_X <span class="op">=</span> np.sqrt(var_5_given_0)</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># X_5|X_0</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> np.random.normal(mu_X, sigma_X)  </span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calcul du prix B(5,6) selon Hull-White</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>        B0_6 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,6)</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>        B0_5 <span class="op">=</span> df_ZC.loc[df_ZC[<span class="st">'T'</span>] <span class="op">==</span> Ti_1, <span class="st">'B'</span>].values[<span class="dv">0</span>] <span class="co"># B(0,5)</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>        B_5_6 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">6</span>, B0_6, B0_5, X, sigma, lambda_)</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>        B_5_5 <span class="op">=</span> B_t_T(<span class="dv">5</span>, <span class="dv">5</span>, B0_5, B0_5, X, sigma, lambda_)</span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>        L_i_t <span class="op">=</span> ((B_5_5 <span class="op">/</span> B_5_6) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>        bp <span class="op">=</span> <span class="dv">100</span> <span class="op">/</span> <span class="dv">10000</span></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>        strike <span class="op">=</span> ATM <span class="op">-</span> bp</span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>        B <span class="op">=</span> ATM <span class="op">+</span> bp</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>        payoff <span class="op">=</span> np.maximum(L_i_t <span class="op">-</span> strike, <span class="dv">0</span>) <span class="op">*</span> (L_i_t <span class="op">&lt;</span> B)</span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a>        payoffs[sim] <span class="op">=</span> payoff</span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Vérification de la barrière</span></span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.<span class="bu">any</span>(L_i_t<span class="op">&gt;=</span> B):</span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a>            n_touched <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a>    prob_toucher_barriere <span class="op">=</span> n_touched <span class="op">/</span> n_simulations</span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a>    call_price <span class="op">=</span> B0_6 <span class="op">*</span> np.mean(payoffs)</span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a>    results.append((lambda_, call_price,prob_toucher_barriere))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="a7afeb0a" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Optionnel : Graphique de la sensibilité</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>lambdas, prices, probabilities <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>results)</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>plt.plot(lambdas, prices, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Lambda (Mean Reversion)'</span>)</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Prix de l</span><span class="ch">\'</span><span class="st">option'</span>)</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Sensibilité du prix à la mean reversion (λ)'</span>)</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-34-output-1.png" width="614" height="450" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>De plus, plus le paramètre de mean reversion <span class="math inline">\(\lambda\)</span> est élevé, plus la probabilité de toucher la barrière est faible. Inversement, une faible mean reversion laisse plus de liberté au processus pour explorer des valeurs extrêmes, augmentant ainsi la probabilité de franchir la barrière.</p>
<div id="9de42ce7" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>plt.plot(lambdas, probabilities, marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Lambda (Mean Reversion)'</span>)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Probabilité de toucher la barrière'</span>)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Probabilité de toucher la barrière en fonction de la mean reversion (λ)'</span>)</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="pj_courbe_tx_files/figure-html/cell-35-output-1.png" width="626" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>


</section>
</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>